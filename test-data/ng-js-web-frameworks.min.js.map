{"version":3,"sources":["@angular/core/src/util/property.ts","@angular/core/src/util/stringify.ts","@angular/core/src/di/forward_ref.ts","@angular/core/src/di/interface/defs.ts","@angular/core/src/di/interface/injector.ts","@angular/core/src/di/inject_switch.ts","@angular/core/src/util/closure.ts","@angular/core/src/change_detection/constants.ts","@angular/core/src/metadata/view.ts","@angular/core/src/util/global.ts","@angular/core/src/render3/empty.ts","@angular/core/src/render3/fields.ts","@angular/core/src/render3/definition.ts","@angular/core/src/render3/interfaces/type_checks.ts","@angular/core/src/render3/interfaces/container.ts","@angular/core/src/render3/definition_factory.ts","@angular/core/src/render3/error_code.ts","@angular/core/src/render3/util/stringify_utils.ts","@angular/core/src/render3/errors_di.ts","@angular/core/src/interface/simple_change.ts","@angular/core/src/render3/features/ng_onchanges_feature.ts","@angular/core/src/render3/interfaces/document.ts","@angular/core/src/render3/interfaces/renderer.ts","@angular/core/src/render3/util/view_utils.ts","@angular/core/src/render3/interfaces/view.ts","@angular/core/src/render3/state.ts","@angular/core/src/render3/hooks.ts","@angular/core/src/render3/interfaces/injector.ts","@angular/core/src/render3/util/attrs_utils.ts","@angular/core/src/render3/util/injector_utils.ts","@angular/core/src/render3/di.ts","@angular/core/src/util/decorators.ts","@angular/core/src/di/injection_token.ts","@angular/core/src/util/array_utils.ts","@angular/core/src/di/metadata.ts","@angular/core/src/di/injector_compatibility.ts","@angular/core/src/errors.ts","@angular/core/src/error_handler.ts","@angular/core/src/render3/context_discovery.ts","@angular/core/src/render3/util/misc_utils.ts","@angular/core/src/render/api_flags.ts","@angular/core/src/render3/i18n/i18n_tree_shaking.ts","@angular/core/src/render3/util/view_traversal_utils.ts","@angular/core/src/render3/node_manipulation.ts","@angular/core/src/render3/styling/class_differ.ts","@angular/core/src/render3/node_selector_matcher.ts","@angular/core/src/render3/tokens.ts","@angular/core/src/render3/instructions/advance.ts","@angular/core/src/render3/interfaces/styling.ts","@angular/core/src/render3/instructions/shared.ts","@angular/core/src/render3/styling/static_styling.ts","@angular/core/src/di/injector_token.ts","@angular/core/src/di/null_injector.ts","@angular/core/src/di/scope.ts","@angular/core/src/di/r3_injector.ts","@angular/core/src/di/injector.ts","@angular/core/src/render3/component.ts","@angular/core/src/util/symbol.ts","@angular/core/src/change_detection/change_detection_util.ts","@angular/core/src/render3/bindings.ts","@angular/core/src/render3/instructions/di.ts","@angular/core/src/render3/instructions/property.ts","@angular/core/src/render3/instructions/element.ts","@angular/core/src/render3/interfaces/node.ts","@angular/core/src/util/lang.ts","@angular/core/src/render3/instructions/listener.ts","@angular/core/src/render3/instructions/next_context.ts","@angular/core/src/util/empty.ts","@angular/core/src/render3/styling/style_binding_list.ts","@angular/core/src/render3/instructions/styling.ts","@angular/core/src/sanitization/bypass.ts","@angular/core/src/render3/instructions/text.ts","@angular/core/src/render3/instructions/text_interpolation.ts","@angular/core/src/render3/instructions/interpolation.ts","@angular/core/src/i18n/locale_en.ts","@angular/core/src/i18n/locale_data_api.ts","@angular/core/src/render3/i18n/i18n_locale_id.ts","@angular/core/src/i18n/localization.ts","@angular/core/src/util/assert.ts","@angular/core/src/linker/component_factory.ts","@angular/core/src/linker/component_factory_resolver.ts","@angular/core/src/util/noop.ts","@angular/core/src/linker/element_ref.ts","@angular/core/src/render/api.ts","@angular/core/src/sanitization/sanitizer.ts","@angular/core/src/version.ts","@angular/core/src/change_detection/differs/default_iterable_differ.ts","@angular/core/src/change_detection/differs/default_keyvalue_differ.ts","@angular/core/src/change_detection/differs/iterable_differs.ts","@angular/core/src/change_detection/differs/keyvalue_differs.ts","@angular/core/src/render3/collect_native_nodes.ts","@angular/core/src/render3/view_ref.ts","@angular/core/src/change_detection/change_detection.ts","@angular/core/src/linker/template_ref.ts","@angular/core/src/linker/ng_module_factory.ts","@angular/core/src/linker/view_container_ref.ts","@angular/core/src/view/provider.ts","@angular/core/src/render3/component_ref.ts","@angular/core/src/render3/namespaces.ts","@angular/core/src/linker/ng_module_factory_registration.ts","@angular/core/src/render3/ng_module_ref.ts","rxjs/node_modules/tslib/tslib.es6.js","rxjs/src/internal/config.ts","rxjs/src/internal/Observer.ts","rxjs/src/internal/util/isObject.ts","rxjs/src/internal/util/UnsubscriptionError.ts","rxjs/src/internal/Subscription.ts","rxjs/src/internal/symbol/rxSubscriber.ts","rxjs/src/internal/Subscriber.ts","rxjs/src/internal/util/pipe.ts","rxjs/src/internal/Observable.ts","rxjs/src/internal/util/toSubscriber.ts","rxjs/src/internal/util/canReportError.ts","rxjs/src/internal/util/ObjectUnsubscribedError.ts","rxjs/src/internal/SubjectSubscription.ts","rxjs/src/internal/Subject.ts","rxjs/src/internal/operators/refCount.ts","rxjs/src/internal/observable/ConnectableObservable.ts","rxjs/src/internal/util/isScheduler.ts","rxjs/src/internal/util/subscribeToArray.ts","rxjs/src/internal/observable/fromArray.ts","rxjs/src/internal/scheduled/scheduleArray.ts","rxjs/src/internal/operators/map.ts","rxjs/src/internal/OuterSubscriber.ts","rxjs/src/internal/InnerSubscriber.ts","rxjs/src/internal/symbol/iterator.ts","rxjs/src/internal/util/subscribeTo.ts","rxjs/src/internal/util/subscribeToObservable.ts","rxjs/src/internal/util/subscribeToPromise.ts","rxjs/src/internal/util/subscribeToIterable.ts","rxjs/src/internal/operators/mergeMap.ts","rxjs/src/internal/observable/from.ts","rxjs/src/internal/util/subscribeToResult.ts","rxjs/src/internal/operators/mergeAll.ts","@angular/core/src/event_emitter.ts","@angular/core/src/application_init.ts","@angular/core/src/application_tokens.ts","@angular/core/src/i18n/tokens.ts","@angular/core/src/linker/compiler.ts","@angular/core/src/util/microtask.ts","@angular/core/src/zone/ng_zone.ts","@angular/core/src/util/raf.ts","@angular/core/src/testability/testability.ts","@angular/core/src/util/is_dev_mode.ts","@angular/core/src/application_ref.ts","@angular/core/src/console.ts","rxjs/src/internal/observable/merge.ts","rxjs/src/internal/operators/multicast.ts","@angular/core/src/platform_core_providers.ts","@angular/core/src/application_module.ts","@angular/common/src/dom_adapter.ts","@angular/common/src/dom_tokens.ts","@angular/common/src/i18n/locale_data_api.ts","@angular/common/src/i18n/localization.ts","@angular/common/src/directives/ng_for_of.ts","@angular/common/src/common_module.ts","@angular/platform-browser/src/browser/browser_adapter.ts","@angular/platform-browser/src/browser/generic_browser_adapter.ts","@angular/common/src/cookie.ts","@angular/platform-browser/src/browser/server-transition.ts","@angular/platform-browser/src/browser/testability.ts","@angular/platform-browser/src/dom/debug/ng_probe.ts","@angular/platform-browser/src/dom/events/event_manager.ts","@angular/platform-browser/src/dom/shared_styles_host.ts","@angular/platform-browser/src/dom/dom_renderer.ts","@angular/platform-browser/src/dom/events/dom_events.ts","@angular/platform-browser/src/dom/events/hammer_gestures.ts","@angular/platform-browser/src/dom/events/key_events.ts","@angular/platform-browser/src/browser.ts","@angular/common/src/platform_id.ts","../../../../../../../../modules/benchmarks/src/util.ts","../../../../../../../../modules/benchmarks/src/js-web-frameworks/ng2/init.ts","@angular/core/src/render3/instructions/get_current_view.ts","../../../../../../../../modules/benchmarks/src/js-web-frameworks/ng2/rows.ts","@angular/core/src/render3/instructions/template.ts","../../../../../../../../modules/benchmarks/src/js-web-frameworks/ng2/rows.ngfactory.ts","../../../../../../../../modules/benchmarks/src/js-web-frameworks/ng2/index_aot.ts"],"names":["getClosureSafeProperty","objWithPropertyToExtract","key","Error","stringify","token","Array","isArray","map","join","overriddenName","name","res","toString","newLineIndex","indexOf","substring","concatStringsWithSpace","before","after","__forward_ref__","forwardRef","forwardRefFn","this","resolveForwardRef","type","fn","hasOwnProperty","ɵɵdefineInjectable","opts","providedIn","factory","value","undefined","ɵɵdefineInjector","options","providers","imports","getInjectableDef","getOwnDefinition","NG_PROV_DEF","NG_INJECTABLE_DEF","field","getInjectorDef","NG_INJ_DEF","NG_INJECTOR_DEF","ɵprov","ɵinj","ngInjectableDef","ngInjectorDef","InjectFlags","_injectImplementation","setInjectImplementation","impl","previous","injectRootLimpMode","notFoundValue","flags","injectableDef","Optional","noSideEffects","ChangeDetectionStrategy","ViewEncapsulation","__globalThis","globalThis","__window","window","__self","self","WorkerGlobalScope","__global","global","_global","EMPTY_OBJ","EMPTY_ARRAY","NG_COMP_DEF","ɵcmp","NG_DIR_DEF","ɵdir","NG_PIPE_DEF","ɵpipe","NG_MOD_DEF","ɵmod","NG_LOC_ID_DEF","ɵloc","NG_FACTORY_DEF","ɵfac","NG_ELEMENT_ID","__NG_ELEMENT_ID__","_renderCompCount","ɵɵdefineComponent","componentDefinition","declaredInputs","def","providersResolver","decls","vars","template","consts","ngContentSelectors","hostBindings","hostVars","hostAttrs","contentQueries","inputs","outputs","exportAs","onPush","changeDetection","OnPush","directiveDefs","pipeDefs","selectors","viewQuery","features","data","encapsulation","Emulated","id","styles","_","setInput","schemas","tView","directiveTypes","directives","feature","pipeTypes","pipes","invertObject","forEach","extractDirectiveDef","extractPipeDef","getComponentDef","getDirectiveDef","getPipeDef","autoRegisterModuleById","ɵɵdefineNgModule","bootstrap","declarations","exports","transitiveCompileScopes","obj","secondary","newLookup","minifiedKey","publicName","declaredName","ɵɵdefineDirective","getNgModuleDef","throwNotFound","ngModuleDef","isLView","isLContainer","isContentQueryHost","tNode","isComponentHost","isDirectiveHost","isComponentDef","getFactoryDef","RuntimeError","[object Object]","code","message","super","formatRuntimeError","renderStringify","String","stringifyForError","throwProviderNotFoundError","injectorName","injectorDetails","SimpleChange","previousValue","currentValue","firstChange","rememberChangeHistoryAndInvokeOnChangesHook","simpleChangesStore","getSimpleChangesStore","current","ngOnChanges","ngOnChangesSetInput","instance","privateName","store","setSimpleChangesStore","previousChange","DOCUMENT","isProceduralRenderer","renderer","domRendererFactory3","createRenderer","hostElement","rendererType","document","unwrapRNode","getNativeByIndex","index","lView","getNativeByTNode","getTNode","getComponentLViewByIndex","nodeIndex","hostView","slotValue","readPatchedLView","target","readPatchedData","viewAttachedToChangeDetector","view","getConstant","resetPreOrderHookFlags","updateTransplantedViewCount","lContainer","amount","viewOrContainer","parent","instructionState","lFrame","createLFrame","bindingsEnabled","isInCheckNoChangesMode","getLView","getTView","ɵɵrestoreView","viewToRestore","contextLView","getCurrentTNode","currentTNode","getCurrentTNodePlaceholderOk","setCurrentTNode","isParent","isCurrentTNodeParent","setIsInCheckNoChangesMode","mode","nextBindingIndex","bindingIndex","setBindingRootForHostBindings","bindingRootIndex","currentDirectiveIndex","setCurrentDirectiveIndex","setCurrentQueryIndex","currentQueryIndex","getDeclarationTNode","declTNode","enterDI","SkipSelf","parentTNode","parentLView","Host","allocLFrame","enterView","newView","newLFrame","firstChild","bindingStartIndex","inI18n","currentLFrame","childLFrame","child","selectedIndex","elementDepthCount","currentNamespace","leaveViewLight","oldLFrame","leaveDI","leaveView","getSelectedIndex","setSelectedIndex","registerPostOrderHooks","i","directiveStart","end","directiveEnd","lifecycleHooks","prototype","ngAfterContentInit","ngAfterContentChecked","ngAfterViewInit","ngAfterViewChecked","ngOnDestroy","contentHooks","push","contentCheckHooks","viewHooks","viewCheckHooks","destroyHooks","executeCheckHooks","hooks","callHooks","executeInitAndCheckHooks","initPhase","incrementInitPhaseFlags","currentView","arr","currentNodeIndex","nodeIndexLimit","lastNodeIndexFound","length","callHook","isInitHook","hook","directive","call","NodeInjectorFactory","isViewProvider","injectImplementation","resolving","canSeeViewProviders","injectImpl","setUpAttributes","native","attrs","isProc","namespaceURI","attrName","attrVal","setAttribute","setAttributeNS","isAnimationProp","setProperty","charCodeAt","mergeHostAttrs","dst","src","slice","srcMarker","item","mergeHostAttribute","marker","key1","key2","markerInsertPosition","dstValue","splice","hasParentInjector","parentLocation","getParentInjectorIndex","getParentInjectorView","location","startView","viewOffset","parentView","includeViewProviders","setIncludeViewProviders","v","oldValue","nextNgElementId","getOrCreateNodeInjectorForNode","existingInjectorIndex","getInjectorIndex","firstCreatePass","injectorIndex","insertBloom","blueprint","parentLoc","getParentInjectorLocation","parentIndex","parentData","footer","declarationViewOffset","lViewCursor","tViewType","diPublicInInjector","bloomBit","BLOOM_SIZE","mask","b6","b5","tData","bloomAdd","notFoundValueOrThrow","lookupTokenUsingModuleInjector","Self","moduleInjector","previousInjectImplementation","get","getOrCreateInjectable","Default","bloomHash","tokenId","createNodeInjector","bloomHashBitOrFactory","previousTView","hostTElementNode","shouldSearchParent","bloomHasToken","searchTokensOnInjector","NOT_FOUND","NodeInjector","currentTView","injectableIdx","canAccessViewProviders","isHostSpecialCase","nodeProviderIndexes","providerIndexes","tInjectables","injectablesStart","directivesStart","cptViewProvidersCount","endIndex","providerTokenOrDef","dirDef","locateDirectiveOrProvider","getNodeInjectable","path","throwCyclicDependencyError","previousIncludeViewProviders","directiveIndex","directiveDef","ngOnInit","ngDoCheck","wrappedOnChanges","definition","preOrderHooks","preOrderCheckHooks","registerPreOrderHooks","injectorView","isFirstHostTNode","_tNode","_lView","makeParamDecorator","props","parentClass","metaCtor","args","values","propName","makeMetadataCtor","ParamDecoratorFactory","apply","annotationInstance","ParamDecorator","annotation","cls","unusedKey","parameters","Object","defineProperty","create","ngMetadataName","annotationCls","InjectionToken","_desc","deepForEach","input","addToArray","removeFromArray","pop","keyValueArraySet","keyValueArray","keyValueArrayIndexOf","array","value1","value2","arrayInsert2","keyValueArrayGet","shift","start","middle","_arrayIndexOfSorted","Inject","THROW_IF_NOT_FOUND","NEW_LINE","USE_VALUE","provide","useValue","_currentInjector","setCurrentInjector","injector","former","injectInjectorOnly","ɵɵinject","injectArgs","types","arg","j","meta","getDebugContext","error","getOriginalError","defaultErrorLogger","console","ErrorHandler","_console","originalError","_findOriginalError","context","_findContext","errorLogger","getErrorLogger","e","attachPatchData","defaultScheduler","requestAnimationFrame","setTimeout","bind","maybeUnwrapFn","Function","RendererStyleFlags2","icuContainerIterate","tIcuContainerNode","_icuContainerIterate","getLViewParent","getFirstLContainer","getNearestLContainer","getNextLContainer","container","applyToElementOrContainer","action","lNodeToHandle","beforeNode","isComponent","rNode","nativeAppendChild","nativeInsertBefore","isHostElement","nativeParent","nativeParentNode","removeChild","nativeRemoveChild","nativeRemoveNode","destroyNode","parentRElement","anchor","applyView","applyContainer","createElementNode","namespace","createElement","createElementNS","detachMovedView","declarationContainer","movedViews","declarationViewIndex","insertionLContainer","detachView","removeIndex","indexInContainer","viewToDetach","declarationLContainer","removedLView","lQueries","destroyLView","rootView","lViewOrLContainer","cleanUpView","next","firstView","destroyViewTree","toCall","executeOnDestroys","tCleanup","cleanup","lCleanup","lastLCleanupIndex","idxOrTargetGetter","listener","useCaptureOrSubIdx","removeEventListener","unsubscribe","instanceCleanupFn","processCleanups","destroy","isMove","insertBefore","appendChild","nativeAppendOrInsertBefore","node","parentNode","childRNode","childTNode","parentRNode","None","getClosestRElement","getParentRElement","anchorNode","_getInsertInFrontOfRNodeWithI18n","getInsertInFrontOfRNode","getFirstNativeNode","tNodeType","getBeforeNodeForView","elIcuContainerChild","rNodeOrLContainer","nextRNode","componentView","componentHost","firstProjectedTNode","projection","viewIndexInContainer","nextViewIndex","firstTNodeOfView","applyNodes","isProjection","rawSlotValue","applyProjectionRecursive","projectionNext","tProjectionNode","componentLView","nodeToProjectOrRNodes","writeDirectStyle","element","newValue","style","cssText","writeDirectClass","removeAttribute","className","classIndexOf","classToSearch","startingIndex","foundIndex","isCssClassMatching","cssClassToMatch","isProjectionMode","toLowerCase","isInlineTemplate","hasTagAndTypeMatch","currentSelector","isNodeMatchingSelector","selector","nodeAttrs","nameOnlyMarkerIdx","getNameOnlyMarkerIndex","skipToNextSelector","isPositive","selectorAttrValue","attrIndexInNode","findAttrIndexInNode","nodeAttrValue","compareAgainstClassName","bindingsMode","maybeAttrName","attr","matchTemplateAttribute","isNodeMatchingSelectorList","maybeWrapInNotSelector","isNegativeMode","chunk","trim","stringifyCSSSelector","result","currentChunk","valueOrMarker","attrValue","NO_CHANGE","ɵɵadvance","delta","selectIndexInternal","checkNoChangesMode","toTStylingRange","prev","getTStylingRangePrev","tStylingRange","setTStylingRangePrevDuplicate","getTStylingRangeNext","setTStylingRangeNext","setTStylingRangeNextDuplicate","refreshContentQueries","queryStartIdx","directiveDefIdx","createLView","host","tHostNode","rendererFactory","sanitizer","getOrCreateTNode","tParent","insertBeforeIndex","directiveStylingLast","propertyBindings","mergedAttrs","localNames","initialInputs","tViews","stylesWithoutHost","residualStyles","classes","classesWithoutHost","residualClasses","classBindings","styleBindings","createTNode","createTNodeAtIndex","getCurrentParentTNode","allocExpando","numSlotsToAlloc","initialValue","allocIdx","renderView","executeViewQueryFn","templateFn","executeTemplate","staticContentQueries","staticViewQueries","components","hostLView","renderComponent","renderChildComponents","incompleteFirstPass","refreshView","isInCheckNoChangesPass","hooksInitPhaseCompleted","movedLView","markTransplantedViewsForRefresh","embeddedLView","embeddedTView","refreshEmbeddedViews","hostBindingOpCodes","opCode","directiveIdx","bindingRootIndx","hostBindingFn","processHostBindingOpCodes","refreshComponent","refreshChildComponents","firstUpdatePass","renderComponentOrTemplate","normalExecutionPath","creationModeIsActive","begin","rf","prevSelectedIndex","createDirectivesInstances","addComponentLogic","setInputsFromAttrs","instantiateAllDirectives","elementIndex","dirIndex","invokeHostBindingsInCreationMode","invokeDirectivesHostBindings","saveResolvedLocalsInData","viewData","localRefExtractor","localIndex","getOrCreateTComponentView","createTView","constsOrFactory","initialViewLength","createViewBlueprint","queries","fill","expandoStartIndex","directiveRegistry","pipeRegistry","generatePropertyAliases","inputAliasMap","propStore","internalName","resolveDirectives","localRefs","hasDirectives","registry","matches","markAsComponentHost","unshift","findDirectiveDefMatches","exportsMap","","initTNodeFlags","preOrderHooksFound","preOrderCheckHooksFound","configureViewWithDirective","saveNameToExportMap","lifeCycleHooks","tViewData","tNodeAttrs","inputsFromAttrs","inputsStore","outputsStore","directiveInputs","generateInitialInputs","initializeInputAndOutputAliases","cacheMatchingLocalNames","registerHostBindingOpCodes","directiveVarsIdx","elementIndx","lastSelectedElementIdx","hostTNode","numberOfDirectives","directiveFactory","nodeInjectorFactory","addToViewTree","initialInputData","inputsToStore","createLContainer","hostNative","componentHostIdx","refreshContainsDirtyView","componentTView","syncViewWithBlueprint","markViewDirty","detectChangesInternal","handleError","detectChangesInRootView","rootContext","rootComponent","tickRootContext","viewQueryFn","component","CLEAN_PROMISE","Promise","resolve","getLCleanup","errorHandler","setInputsForProperty","computeStaticStyling","writeToHost","INJECTOR","NullInjector","INJECTOR_SCOPE","NOT_YET","CIRCULAR","NULL_INJECTOR","getNullInjector","createInjectorWithoutInjectorInstances","defType","additionalProviders","R3Injector","source","records","Map","injectorDefTypes","Set","onDestroy","_destroyed","dedupStack","provider","processProvider","injectorDef","processInjectorType","set","makeRecord","record","scope","destroyed","assertNotDestroyed","service","clear","previousInjector","injectableDefInScope","injectableDefOrInjectorDefFactory","hydrate","injectorErrorName","tokenPath","text","charAt","substr","parts","JSON","replace","formatError","catchInjectorError","tokens","defOrWrappedDef","parents","ngModule","isDuplicate","importTypesWithProviders","imported","add","defProviders","injectorType","ngModuleType","isTypeProvider","isValueProvider","unwrappedProvider","useFactory","deps","useExisting","isExistingProvider","classRef","useClass","hasDeps","providerToFactory","providerToRecord","multi","multiRecord","has","paramLength","size","list","newArray","inheritedInjectableDef","typeName","match","getTypeName","warn","getInheritedInjectableDef","getUndecoratedInjectableFactory","INJECTOR_IMPL","_resolveInjectorDefTypes","createInjector","Injector","NULL","LifecycleHooksFeature","_symbolIterator","getSymbolIterator","Symbol","iterator","keys","getOwnPropertyNames","isListLikeIterable","isJsObject","o","bindingUpdated","is","ɵɵdirectiveInject","ɵɵproperty","nativeOnly","dataValue","inputData","viewIndex","childComponentLView","markDirtyIfOnPush","elementPropertyInternal","getSelectedTNode","setDirectiveInputsWhichShadowsStyling","isClassBased","property","ɵɵelementStart","attrsIndex","localRefsIndex","adjustedIndex","tViewConsts","elementStart","elementStartFirstCreatePass","executeContentQueries","ɵɵelementEnd","elementEnd","hasClassInput","hasStyleInput","ɵɵelement","isPromise","then","ɵɵlistener","eventName","listenerFn","useCapture","eventTargetResolver","isTNodeDirectiveHost","getTViewCleanup","processOutputs","resolved","lCleanupIndex","existingListener","tNodeIdx","cleanupEventName","listenerIdxInLCleanup","findExistingListener","__ngLastListenerFn__","__ngNextListenerFn__","wrapListener","cleanupFn","listen","addEventListener","propsLength","subscription","subscribe","idx","listenerInternal","executeListenerWithErrorHandling","wrapWithPreventDefault","wrapListenerIn_markDirtyAndPreventDefault","nextListenerFn","preventDefault","returnValue","ɵɵnextContext","level","nestingLevel","walkUpViews","nextContextImpl","markDuplicates","tStylingKey","isPrevDir","isClassBinding","tStylingAtIndex","isMap","cursor","foundDuplicate","tStyleRangeAtCursor","isStylingMatch","tStylingKeyCursor","ɵɵclassProp","prop","suffix","count","incrementBindingIndex","isHostBindings","isInHostBindings","hasStylingInputShadow","stylingKey","hostDirectiveDef","getCurrentDirectiveDef","residual","collectStylingFromTAttrs","collectStylingFromDirectives","templateStylingKey","bindings","getTemplateHeadTStylingKey","setTemplateHeadTStylingKey","collectResidual","wrapInStaticStylingKey","tStylingKeyWithStatic","isHostBinding","tBindings","tmplHead","tmplTail","isKeyDuplicateOfStatic","staticKeyValueArray","previousNode","markDuplicateOfResidualStyling","insertTStylingBinding","stylingFirstUpdatePass","tRange","isStylingValuePresent","findStylingValue","isProcedural","addClass","classList","removeClass","remove","applyStyling","updateStyling","changingThisBreaksApplicationSecurity","unwrapSafeValue","normalizeSuffix","checkStylingProperty","currentDirective","desiredMarker","currentMarker","isPrevDirection","rawKey","containsStatics","isStylingMap","valueAtLViewIndex","ɵɵtext","textNative","createText","createTextNode","ɵɵtextInterpolate","v0","ɵɵtextInterpolate1","prefix","interpolated","interpolation1","setValue","textContent","updateTextNode","textBindingInternal","u","localeEn","n","Math","floor","abs","LOCALE_DATA","getLocaleData","normalizedLocale","ng","common","locales","LocaleDataIndex","LOCALE_ID","setLocaleId","localeId","actual","msg","expected","comparison","throwError","ComponentFactory","_NullComponentFactoryResolver","noComponentFactoryError","ComponentFactoryResolver","noop","createElementRef","ElementRef","SWITCH_ELEMENT_REF_FACTORY","nativeElement","RendererFactory2","Sanitizer","Version","full","major","split","minor","patch","VERSION","DefaultIterableDifferFactory","trackByFn","DefaultIterableDiffer","trackByIdentity","_linkedRecords","_unlinkedRecords","_previousItHead","_itHead","_itTail","_additionsHead","_additionsTail","_movesHead","_movesTail","_removalsHead","_removalsTail","_identityChangesHead","_identityChangesTail","_trackByFn","_next","nextIt","nextRemove","addRemoveOffset","moveOffsets","currentIndex","getPreviousIndex","adjPreviousIndex","_nextRemoved","previousIndex","localMovePreviousIndex","localCurrentIndex","offset","_nextPrevious","_nextAdded","_nextMoved","_nextIdentityChange","collection","check","_reset","itemTrackBy","mayBeDirty","trackById","_verifyReinsertion","_addIdentityChange","_mismatch","iterateListLike","_truncate","isDirty","previousRecord","_prev","_remove","_moveAfter","_reinsertAfter","_addAfter","IterableChangeRecord_","reinsertRecord","_addToMoves","nextRecord","_addToRemovals","_unlink","prevRecord","_prevRemoved","_insertAfter","_DuplicateMap","put","toIndex","_prevDup","_nextDup","_DuplicateItemRecordList","_head","_tail","atOrAfterIndex","duplicates","recordList","delete","isEmpty","moveOffset","DefaultKeyValueDifferFactory","DefaultKeyValueDiffer","_records","_mapHead","_appendAfter","_previousMapHead","_changesHead","_changesTail","_nextChanged","_forEach","_maybeAddToChanges","_getOrCreateRecordForKey","_insertBeforeOrAppend","KeyValueChangeRecord_","_addToAdditions","_addToChanges","k","defaultIterableDiffersFactory","IterableDiffers","factories","copied","concat","iterable","find","f","supports","defaultKeyValueDiffersFactory","KeyValueDiffers","kv","collectNativeNodes","lNode","lViewInAContainer","lViewFirstChildTNode","nodesInSlot","ViewRef","_cdRefInjectingView","_appRef","_viewContainerRef","rootNodes","detach","callback","checkNoChangesInternal","vcRef","appRef","RootViewRef","_view","checkNoChangesInRootView","keyValDiff","defaultIterableDiffers","defaultKeyValueDiffers","SWITCH_TEMPLATE_REF_FACTORY","R3TemplateRef","TemplateRef","ViewEngineTemplateRef","_declarationLView","_declarationTContainer","elementRef","declarationViewLQueries","createEmbeddedView","R3_ViewRef","NgModuleRef","SWITCH_VIEW_CONTAINER_REF_FACTORY","commentNode","createComment","nextSibling","nativeNextSibling","R3ViewContainerRef","createContainerRef","ViewContainerRef","VE_ViewContainerRef","_lContainer","_hostTNode","_hostLView","parentInjector","viewRefs","getViewRefs","templateRef","viewRef","insert","componentFactory","projectableNodes","ngModuleRef","contextInjector","componentRef","prevIdx","prevLContainer","prevVCRef","adjustedIdx","_adjustIndex","containerLength","trackMovedView","insertView","parentNativeNode","addViewToContainer","attachToViewContainerRef","getOrCreateViewRefs","newIndex","viewRefsArr","detachedView","R3ViewRef","NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR","viewEngine_ComponentFactoryResolver","componentDef","toRefArray","nonMinified","templateName","SCHEDULER","viewEngine_ComponentFactory","componentType","isBoundToModule","rootSelectorOrNode","rootViewInjector","createChainedInjector","hostRenderer","elementName","hostRNode","elementOrSelector","selectRootElement","ShadowDom","rElement","querySelector","locateHostElement","getNamespace","rootFlags","scheduler","clean","playerHandler","rootTView","rootLView","tElementNode","viewRenderer","createRootComponentView","extractAttrsAndClassesFromSelector","nodesforSlot","from","hostFeatures","rootTNode","instantiateRootComponent","createRootComponent","ComponentRef","_rootLView","changeDetectorRef","modules","viewEngine_NgModuleRef","_parent","_bootstrapComponents","destroyCbs","componentFactoryResolver","ngLocaleIdDef","_r3Injector","injectFlags","NgModuleFactory","moduleType","visited","recurse","incoming","assertSameOrNotExisting","registerNgModuleType","extendStatics","d","b","setPrototypeOf","__proto__","p","__extends","__","constructor","_enable_super_gross_mode_that_will_cause_bad_things","config","closed","useDeprecatedSynchronousErrorHandling","x","UnsubscriptionErrorImpl","errors","err","Subscription","_parentOrParents","_subscriptions","_a","_unsubscribe","isFunction","len","sub","isObject","UnsubscriptionError","teardown","tmp","subscriptions","subscriptionIndex","empty","rxSubscriber","Subscriber","_super","_this","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","destinationOrNext","SafeSubscriber","complete","tslib_1.__extends","subscriber","_error","_complete","_parentSubscriber","observerOrNext","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","hostReportError","fns","Observable","_isScalar","lift","operator","observable","sink","nextOrObserver","toSubscriber","_subscribe","observer","canReportError","promiseCtor","getPromiseCtor","reject","operations","toPromise","ObjectUnsubscribedErrorImpl","SubjectSubscription","subject","observers","subscriberIndex","SubjectSubscriber","Subject","hasError","AnonymousSubject","copy","thrownError","_trySubscribe","asObservable","RefCountOperator","connectable","_refCount","refCounter","RefCountSubscriber","refCount","connection","sharedConnection","_connection","ConnectableObservable","subjectFactory","getSubject","_subject","connect","_isComplete","ConnectableSubscriber","connectableProto","writable","isScheduler","schedule","MapOperator","project","MapSubscriber","thisArg","OuterSubscriber","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","InnerSubscriber","notifyComplete","getSymbolIterator$1","obs","promise","Symbol_iterator","done","iterator$1","return","concurrent","Number","POSITIVE_INFINITY","pipe","mergeMap","a","ii","resultSelector","MergeMapOperator","hasCompleted","MergeMapSubscriber","_tryNext","buffer","active","_innerSub","innerSubscriber","innerSubscription","outerSubscriber","subscribeToResult","ish","EventEmitter","isAsync","__isAsync","generatorOrNext","schedulerFn","errorFn","completeFn","APP_INITIALIZER","ApplicationInitStatus","appInits","initialized","donePromise","rej","asyncInitPromises","initResult","all","catch","APP_ID","APP_ID_RANDOM_PROVIDER","_randomChar","fromCharCode","random","PLATFORM_INITIALIZER","PLATFORM_ID","APP_BOOTSTRAP_LISTENER","DEFAULT_CURRENCY_CODE","ModuleWithComponentFactories","ngModuleFactory","componentFactories","Compiler_compileModuleSync__POST_R3__","NgModuleFactoryR3","Compiler_compileModuleSync","Compiler_compileModuleAsync","Compiler_compileModuleAndAllComponentsSync__POST_R3__","reduce","declaration","ComponentFactoryR3","Compiler_compileModuleAndAllComponentsSync","Compiler_compileModuleAndAllComponentsAsync","Compiler","compileModuleSync","compileModuleAsync","compileModuleAndAllComponentsSync","compileModuleAndAllComponentsAsync","scheduleMicroTask","Zone","NgZone","enableLongStackTrace","shouldCoalesceEventChangeDetection","shouldCoalesceRunChangeDetection","hasPendingMacrotasks","hasPendingMicrotasks","isStable","onUnstable","onMicrotaskEmpty","onStable","onError","assertZonePatched","_nesting","_outer","_inner","fork","lastRequestAnimationFrameId","nativeRequestAnimationFrame","nativeCancelAnimationFrame","unpatchedRequestAnimationFrame","__symbol__","unpatchedCancelAnimationFrame","getNativeRequestAnimationFrame","zone","delayChangeDetectionForEventsDelegate","fakeTopEventTask","root","scheduleEventTask","updateMicroTaskStatus","checkStable","invoke","delayChangeDetectionForEvents","properties","isAngularZone","onInvokeTask","delegate","task","applyThis","applyArgs","onEnter","invokeTask","onLeave","onInvoke","onHasTask","hasTaskState","hasTask","change","_hasPendingMicrotasks","microTask","macroTask","onHandleError","runOutsideAngular","emit","forkInnerZoneWithAngularBehavior","isInAngularZone","run","EMPTY_PAYLOAD","runTask","cancelTask","runGuarded","NoopNgZone","Testability","_ngZone","_pendingCount","_isZoneStable","_didWork","_callbacks","taskTrackingZone","_watchAngularEvents","assertNotInAngularZone","_runCallbacksIfReady","cb","clearTimeout","timeoutId","doneCb","pending","getPendingTasks","filter","updateCb","macroTasks","t","creationLocation","timeout","addCallback","using","exactMatch","TestabilityRegistry","_applications","_testabilityGetter","addToWindow","testability","elem","findInAncestors","findTestabilityInTree","_NoopGetTestability","_devMode","_runModeLocked","isDevMode","_platform","Console","log","ALLOW_MULTIPLE_PLATFORMS","createPlatformFactory","parentPlatformFactory","desc","extraProviders","platform","getPlatform","injectedProviders","PlatformRef","inits","init","createPlatform","requiredToken","assertPlatform","_injector","_modules","_destroyListeners","moduleFactory","ngZone","ngZoneOption","extra","ngZoneEventCoalescing","ngZoneRunCoalescing","getNgZone","ngZoneInjector","moduleRef","exceptionHandler","_callAndReportToErrorHandler","initStatus","runInitializers","_moduleDoBootstrap","compilerOptions","optionsReducer","R3NgModuleFactory","compileNgModuleFactory","bootstrapModuleFactory","ApplicationRef","ngDoBootstrap","module","objs","assign","_zone","_exceptionHandler","_componentFactoryResolver","_initStatus","_bootstrapListeners","_views","_runningTick","_stable","componentTypes","_onMicrotaskEmptySubscription","tick","isCurrentlyStable","stableSub","unstableSub","assertInAngularZone","last","observables","merge","subjectOrSubjectFactory","connectableObservableDescriptor","componentOrFactory","resolveComponentFactory","compRef","testabilityRegistry","registerApplication","unregisterApplication","_loadComponent","detectChanges","attachToAppRef","detachFromAppRef","attachView","viewCount","el","platformCore","APPLICATION_MODULE_PROVIDERS","queue","locale","$localize","ApplicationModule","_DOM","getDOM","Plural","NgLocalization","NgLocaleLocalization","normalizeLocale","parentLocale","findLocaleData","PluralCase","getLocalePluralCase","Zero","One","Two","Few","Many","NgForOfContext","$implicit","ngForOf","first","even","odd","NgForOf","_viewContainer","_template","_differs","_ngForOf","_ngForOfDirty","_differ","ngForTrackBy","ngForTemplate","changes","diff","_applyChanges","insertTuples","forEachOperation","adjustedPreviousIndex","tuple","RecordViewTuple","move","_perViewChange","ilen","forEachIdentityChange","dir","ctx","CommonModule","BrowserDomAdapter","adapter","group","groupEnd","evt","dispatchEvent","tagName","doc","getDefaultDocument","implementation","createHTMLDocument","nodeType","Node","ELEMENT_NODE","DocumentFragment","body","history","href","baseElement","getAttribute","url","urlParsingNode","pathname","navigator","userAgent","performance","now","Date","getTime","cookieStr","encodeURIComponent","cookie","eqIndex","cookieName","cookieValue","decodeURIComponent","parseCookieValue","TRANSITION_ID","SERVER_TRANSITION_PROVIDERS","transitionId","dom","querySelectorAll","BrowserGetTestability","getter","getAllTestabilities","getAllRootElements","testabilities","didWork","decrement","didWork_","whenStable","getTestability","isShadowRoot","parentElement","EVENT_MANAGER_PLUGINS","EventManager","plugins","_eventNameToPlugin","manager","_plugins","reverse","handler","_findPluginFor","addGlobalEventListener","plugin","EventManagerPlugin","_doc","getGlobalEventTarget","SharedStylesHost","_stylesSet","additions","onStylesAdded","DomSharedStylesHost","_hostNodes","_styleNodes","head","styleEl","hostNode","_addStylesToHost","styleNode","NAMESPACE_URIS","svg","xhtml","xlink","xml","xmlns","COMPONENT_REGEX","flattenStyles","compId","decoratePreventDefault","eventHandler","event","DomRendererFactory2","eventManager","sharedStylesHost","appId","rendererByCompId","defaultRenderer","DefaultDomRenderer2","EmulatedEncapsulationDomRenderer2","applyToHost","ShadowDomRenderer","addStyles","newChild","refChild","oldChild","selectorOrNode","preserveContent","namespaceUri","removeAttributeNS","DashCase","Important","removeProperty","nodeValue","contentAttr","hostAttr","hostEl","shadowRoot","attachShadow","addHost","removeHost","nodeOrShadowRoot","DomEventsPlugin","MODIFIER_KEYS","_keyMap","\b","\t","","\u001b","Del","Esc","Left","Right","Up","Down","Menu","Scroll","Win","_chromeNumKeyPadMap","A","B","C","D","E","F","G","H","I","J","K","M","N","O","`","","MODIFIER_KEY_GETTERS","alt","altKey","control","ctrlKey","metaKey","shiftKey","KeyEventsPlugin","parseEventName","parsedEvent","outsideHandler","eventCallback","getZone","onAndCancel","domEventName","_normalizeKey","fullKey","modifierName","keyIdentifier","startsWith","parseInt","getEventKey","modifierGetter","getEventFullKey","keyName","platformBrowser","makeCurrent","ɵsetDocument","BROWSER_MODULE_PROVIDERS","BrowserModule","parentModule","params","bindAction","_random","max","round","buildData","label","ADJECTIVES","COLOURS","NOUNS","regex","search","exec","els","checked","urlParamsToForm","i0.ɵɵelementStart","i0.ɵɵtext","i0.ɵɵelementEnd","i0.ɵɵlistener","$event","i0.ɵɵelement","i0.ɵɵclassProp","i0.ɵɵadvance","i0.ɵɵtextInterpolate","JsWebFrameworksComponent","itemId","selected","l","templateFirstCreatePass","comment","i0.ɵɵtemplate","i0.ɵɵproperty","itemById","JsWebFrameworksModule","JsWebFrameworksModuleNgFactory","i0.ɵNgModuleFactory","enableProdMode"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty as any) {\n      return key;\n    }\n  }\n  throw Error('Could not find renamed property on target object.');\n}\n\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nexport function fillProperties(target: {[key: string]: string}, source: {[key: string]: string}) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nexport function concatStringsWithSpace(before: string|null, after: string|null): string {\n  return (before == null || before === '') ?\n      (after === null ? '' : after) :\n      ((after == null || after === '') ? before : before + ' ' + after);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\n\n\n\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @publicApi\n */\nexport interface ForwardRefFn {\n  (): any;\n}\n\nconst __forward_ref__ = getClosureSafeProperty({__forward_ref__: getClosureSafeProperty});\n\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nexport function forwardRef(forwardRefFn: ForwardRefFn): Type<any> {\n  (<any>forwardRefFn).__forward_ref__ = forwardRef;\n  (<any>forwardRefFn).toString = function() {\n    return stringify(this());\n  };\n  return (<Type<any>><any>forwardRefFn);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nexport function resolveForwardRef<T>(type: T): T {\n  return isForwardRef(type) ? type() : type;\n}\n\n/** Checks whether a function is wrapped by a `forwardRef`. */\nexport function isForwardRef(fn: any): fn is() => any {\n  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&\n      fn.__forward_ref__ === forwardRef;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../../interface/type';\nimport {getClosureSafeProperty} from '../../util/property';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, ValueProvider} from './provider';\n\n\n\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `InjectorDef`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * @codeGenApi\n * @publicApi The ViewEngine compiler emits code with this type for injectables. This code is\n *   deployed to npm, and should be treated as public api.\n\n */\nexport interface ɵɵInjectableDef<T> {\n  /**\n   * Specifies that the given type belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n   *   `providers`.\n   */\n  providedIn: InjectorType<any>|'root'|'platform'|'any'|null;\n\n  /**\n   * The token to which this definition belongs.\n   *\n   * Note that this may not be the same as the type that the `factory` will create.\n   */\n  token: unknown;\n\n  /**\n   * Factory method to execute to create an instance of the injectable.\n   */\n  factory: (t?: Type<any>) => T;\n\n  /**\n   * In a case of no explicit injector, a location where the instance of the injectable is stored.\n   */\n  value: T|undefined;\n}\n\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n *\n * @codeGenApi\n */\nexport interface ɵɵInjectorDef<T> {\n  factory: () => T;\n\n  // TODO(alxhub): Narrow down the type here once decorators properly change the return type of the\n  // class they are decorating (to add the ɵprov property for example).\n  providers: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n              StaticClassProvider|ClassProvider|any[])[];\n\n  imports: (InjectorType<any>|InjectorTypeWithProviders<any>)[];\n}\n\n/**\n * A `Type` which has an `InjectableDef` static field.\n *\n * `InjectableDefType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  ɵprov: never;\n}\n\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorDefTypes` can be used to configure a `StaticInjector`.\n *\n * @publicApi\n */\nexport interface InjectorType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  ɵinj: never;\n}\n\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorDefType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorTypeWithProviders<T> {\n  ngModule: InjectorType<T>;\n  providers?: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n               StaticClassProvider|ClassProvider|any[])[];\n}\n\n\n/**\n * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\n * in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport function ɵɵdefineInjectable<T>(opts: {\n  token: unknown,\n  providedIn?: Type<any>|'root'|'platform'|'any'|null, factory: () => T,\n}): never {\n  return ({\n           token: opts.token,\n           providedIn: opts.providedIn as any || null,\n           factory: opts.factory,\n           value: undefined,\n         } as ɵɵInjectableDef<T>) as never;\n}\n\n/**\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\n * code should now use ɵɵdefineInjectable instead.\n * @publicApi\n */\nexport const defineInjectable = ɵɵdefineInjectable;\n\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\n *   create the type must be provided. If that factory function needs to inject arguments, it can\n *   use the `inject` function.\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `ɵprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @codeGenApi\n */\nexport function ɵɵdefineInjector(options: {factory: () => any, providers?: any[], imports?: any[]}):\n    never {\n  return ({\n           factory: options.factory,\n           providers: options.providers || [],\n           imports: options.imports || [],\n         } as ɵɵInjectorDef<any>) as never;\n}\n\n/**\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `ɵprov`.\n */\nexport function getInjectableDef<T>(type: any): ɵɵInjectableDef<T>|null {\n  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);\n}\n\n/**\n * Return definition only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n */\nfunction getOwnDefinition<T>(type: any, field: string): ɵɵInjectableDef<T>|null {\n  return type.hasOwnProperty(field) ? type[field] : null;\n}\n\n/**\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\n *\n * @param type A type which may have `ɵprov`, via inheritance.\n *\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\n *     scenario if we find the `ɵprov` on an ancestor only.\n */\nexport function getInheritedInjectableDef<T>(type: any): ɵɵInjectableDef<T>|null {\n  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n\n  if (def) {\n    const typeName = getTypeName(type);\n    // TODO(FW-1307): Re-add ngDevMode when closure can handle it\n    // ngDevMode &&\n    console.warn(\n        `DEPRECATED: DI is instantiating a token \"${\n            typeName}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n        `This will become an error in a future version of Angular. Please add @Injectable() to the \"${\n            typeName}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\n\n/** Gets the name of a type, accounting for some cross-browser differences. */\nfunction getTypeName(type: any): string {\n  // `Function.prototype.name` behaves differently between IE and other browsers. In most browsers\n  // it'll always return the name of the function itself, no matter how many other functions it\n  // inherits from. On IE the function doesn't have its own `name` property, but it takes it from\n  // the lowest level in the prototype chain. E.g. if we have `class Foo extends Parent` most\n  // browsers will evaluate `Foo.name` to `Foo` while IE will return `Parent`. We work around\n  // the issue by converting the function to a string and parsing its name out that way via a regex.\n  if (type.hasOwnProperty('name')) {\n    return type.name;\n  }\n\n  const match = ('' + type).match(/^function\\s*([^\\s(]+)/);\n  return match === null ? '' : match[1];\n}\n\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`ɵinj`)\n */\nexport function getInjectorDef<T>(type: any): ɵɵInjectorDef<T>|null {\n  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ?\n      (type as any)[NG_INJ_DEF] :\n      null;\n}\n\nexport const NG_PROV_DEF = getClosureSafeProperty({ɵprov: getClosureSafeProperty});\nexport const NG_INJ_DEF = getClosureSafeProperty({ɵinj: getClosureSafeProperty});\n\n// We need to keep these around so we can read off old defs if new defs are unavailable\nexport const NG_INJECTABLE_DEF = getClosureSafeProperty({ngInjectableDef: getClosureSafeProperty});\nexport const NG_INJECTOR_DEF = getClosureSafeProperty({ngInjectorDef: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nexport enum InjectFlags {\n  // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.\n\n  /** Check self and check parent injector if needed */\n  Default = 0b0000,\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n  /** Don't ascend to ancestors of the node requesting injection. */\n  Self = 0b0010,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractType, Type} from '../interface/type';\nimport {assertNotEqual} from '../util/assert';\nimport {stringify} from '../util/stringify';\nimport {InjectionToken} from './injection_token';\nimport {getInjectableDef, ɵɵInjectableDef} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\n\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation:\n    (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|\n    undefined;\nexport function getInjectImplementation() {\n  return _injectImplementation;\n}\n\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n    impl: (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|\n    undefined):\n    (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)|\n    undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * `InjectableDef`.\n */\nexport function injectRootLimpMode<T>(\n    token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue: T|undefined,\n    flags: InjectFlags): T|null {\n  const injectableDef: ɵɵInjectableDef<T>|null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                               injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n}\n\n\n/**\n * Assert that `_injectImplementation` is not `fn`.\n *\n * This is useful, to prevent infinite recursion.\n *\n * @param fn Function which it should not equal to\n */\nexport function assertInjectImplementationNotEqual(\n    fn: (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T | null)) {\n  ngDevMode &&\n      assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nexport function noSideEffects<T>(fn: () => T): T {\n  return {toString: fn}.toString() as unknown as T;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @see {@link ChangeDetectorRef#usage-notes Change detection usage}\n *\n * @publicApi\n */\nexport enum ChangeDetectionStrategy {\n  /**\n   * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n   * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n   * Change detection can still be explicitly invoked.\n   * This strategy applies to all child directives and cannot be overridden.\n   */\n  OnPush = 0,\n\n  /**\n   * Use the default `CheckAlways` strategy, in which change detection is automatic until\n   * explicitly deactivated.\n   */\n  Default = 1,\n}\n\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nexport enum ChangeDetectorStatus {\n  /**\n   * A state in which, after calling `detectChanges()`, the change detector\n   * state becomes `Checked`, and must be explicitly invoked or reactivated.\n   */\n  CheckOnce,\n\n  /**\n   * A state in which change detection is skipped until the change detector mode\n   * becomes `CheckOnce`.\n   */\n  Checked,\n\n  /**\n   * A state in which change detection continues automatically until explicitly\n   * deactivated.\n   */\n  CheckAlways,\n\n  /**\n   * A state in which a change detector sub tree is not a part of the main tree and\n   * should be skipped.\n   */\n  Detached,\n\n  /**\n   * Indicates that the change detector encountered an error checking a binding\n   * or calling a directive lifecycle method and is now in an inconsistent state. Change\n   * detectors in this state do not detect changes.\n   */\n  Errored,\n\n  /**\n   * Indicates that the change detector has been destroyed.\n   */\n  Destroyed,\n}\n\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nexport function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy):\n    boolean {\n  return changeDetectionStrategy == null ||\n      changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines template and style encapsulation options available for Component's {@link Component}.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nexport enum ViewEncapsulation {\n  /**\n   * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\n   * Element and pre-processing the style rules provided via {@link Component#styles styles} or\n   * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\n   * selectors.\n   *\n   * This is the default option.\n   */\n  Emulated = 0,\n\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n\n  /**\n   * Don't provide any template or style encapsulation.\n   */\n  None = 2,\n\n  /**\n   * Use Shadow DOM to encapsulate styles.\n   *\n   * For the DOM this means using modern [Shadow\n   * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   */\n  ShadowDom = 3\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// TODO(jteplitz602): Load WorkerGlobalScope from lib.webworker.d.ts file #3492\ndeclare var WorkerGlobalScope: any /** TODO #9100 */;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any /** TODO #9100 */;\n// Not yet available in TypeScript: https://github.com/Microsoft/TypeScript/pull/29332\ndeclare var globalThis: any /** TODO #9100 */;\n\nconst __globalThis = typeof globalThis !== 'undefined' && globalThis;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case.\nconst _global = __globalThis || __global || __window || __self;\n\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {initNgDevMode} from '../util/ng_dev_mode';\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\n\nexport const EMPTY_OBJ: {} = {};\nexport const EMPTY_ARRAY: any[] = [];\n\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ);\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_ARRAY);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getClosureSafeProperty} from '../util/property';\n\nexport const NG_COMP_DEF = getClosureSafeProperty({ɵcmp: getClosureSafeProperty});\nexport const NG_DIR_DEF = getClosureSafeProperty({ɵdir: getClosureSafeProperty});\nexport const NG_PIPE_DEF = getClosureSafeProperty({ɵpipe: getClosureSafeProperty});\nexport const NG_MOD_DEF = getClosureSafeProperty({ɵmod: getClosureSafeProperty});\nexport const NG_LOC_ID_DEF = getClosureSafeProperty({ɵloc: getClosureSafeProperty});\nexport const NG_FACTORY_DEF = getClosureSafeProperty({ɵfac: getClosureSafeProperty});\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nexport const NG_ELEMENT_ID = getClosureSafeProperty({__NG_ELEMENT_ID__: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Mutable, Type} from '../interface/type';\nimport {NgModuleDef, NgModuleType} from '../metadata/ng_module_def';\nimport {SchemaMetadata} from '../metadata/schema';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {noSideEffects} from '../util/closure';\nimport {initNgDevMode} from '../util/ng_dev_mode';\nimport {stringify} from '../util/stringify';\nimport {EMPTY_ARRAY, EMPTY_OBJ} from './empty';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_LOC_ID_DEF, NG_MOD_DEF, NG_PIPE_DEF} from './fields';\nimport {ComponentDef, ComponentDefFeature, ComponentTemplate, ComponentType, ContentQueriesFunction, DirectiveDef, DirectiveDefFeature, DirectiveTypesOrFactory, HostBindingsFunction, PipeDef, PipeTypesOrFactory, ViewQueriesFunction} from './interfaces/definition';\nimport {AttributeMarker, TAttributes, TConstantsOrFactory} from './interfaces/node';\nimport {CssSelectorList, SelectorFlags} from './interfaces/projection';\n\n\nlet _renderCompCount = 0;\n\n// While these types are unused here, they are required so that types don't\n// get resolved lazily. see: https://github.com/Microsoft/web-build-tools/issues/1050\ntype _web_build_tools_issue_1050_SelectorFlags = SelectorFlags;\ntype _web_build_tools_issue_1050_AttributeMarker = AttributeMarker;\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nexport function ɵɵdefineComponent<T>(componentDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this component. */\n  selectors?: CssSelectorList;\n\n  /**\n   * The number of nodes, local refs, and pipes in this component template.\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the binding start index.\n   */\n  // TODO(kara): remove queries from this count\n  decls: number;\n\n  /**\n   * The number of bindings in this component template (including pure fn bindings).\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  vars: number;\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['public', 'declared']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  hostVars?: number;\n\n  /**\n   * Assign static attribute values to a host element.\n   *\n   * This property will assign static attribute values as well as class and style\n   * values to a host element. Since attribute values can consist of different types of values, the\n   * `hostAttrs` array must include the values in the following format:\n   *\n   * attrs = [\n   *   // static attributes (like `title`, `name`, `id`...)\n   *   attr1, value1, attr2, value,\n   *\n   *   // a single namespace value (like `x:id`)\n   *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n   *\n   *   // another single namespace value (like `x:name`)\n   *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n   *\n   *   // a series of CSS classes that will be applied to the element (no spaces)\n   *   CLASSES_MARKER, class1, class2, class3,\n   *\n   *   // a series of CSS styles (property + value) that will be applied to the element\n   *   STYLES_MARKER, prop1, value1, prop2, value2\n   * ]\n   *\n   * All non-class and non-style attributes must be defined at the start of the list\n   * first before all class and style values are set. When there is a change in value\n   * type (like when classes and styles are introduced) a marker must be used to separate\n   * the entries. The marker values themselves are set via entries found in the\n   * [AttributeMarker] enum.\n   */\n  hostAttrs?: TAttributes;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ContentQueriesFunction<T>;\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string[];\n\n  /**\n   * Template function use for rendering DOM.\n   *\n   * This function has following structure.\n   *\n   * ```\n   * function Template<T>(ctx:T, creationMode: boolean) {\n   *   if (creationMode) {\n   *     // Contains creation mode instructions.\n   *   }\n   *   // Contains binding update instructions\n   * }\n   * ```\n   *\n   * Common instructions are:\n   * Creation mode instructions:\n   *  - `elementStart`, `elementEnd`\n   *  - `text`\n   *  - `container`\n   *  - `listener`\n   *\n   * Binding update instructions:\n   * - `bind`\n   * - `elementAttribute`\n   * - `elementProperty`\n   * - `elementClass`\n   * - `elementStyle`\n   *\n   */\n  template: ComponentTemplate<T>;\n\n  /**\n   * Constants for the nodes in the component's view.\n   * Includes attribute arrays, local definition arrays etc.\n   */\n  consts?: TConstantsOrFactory;\n\n  /**\n   * An array of `ngContent[selector]` values that were found in the template.\n   */\n  ngContentSelectors?: string[];\n\n  /**\n   * Additional set of instructions specific to view query processing. This could be seen as a\n   * set of instruction to be inserted into the template function.\n   *\n   * Query-related instructions need to be pulled out to a specific function as a timing of\n   * execution is different as compared to all other instructions (after change detection hooks but\n   * before view hooks).\n   */\n  viewQuery?: ViewQueriesFunction<T>| null;\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}\n   */\n  features?: ComponentDefFeature[];\n\n  /**\n   * Defines template and style encapsulation options available for Component's {@link Component}.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   *\n   * see: animation\n   */\n  data?: {[kind: string]: any};\n\n  /**\n   * A set of styles that the component needs to be present for component to render correctly.\n   */\n  styles?: string[];\n\n  /**\n   * The strategy that the default change detector uses to detect changes.\n   * When set, takes effect the next time change detection is triggered.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Registry of directives and components that may be found in this component's view.\n   *\n   * The property is either an array of `DirectiveDef`s or a function which returns the array of\n   * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n   */\n  directives?: DirectiveTypesOrFactory | null;\n\n  /**\n   * Registry of pipes that may be found in this component's view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   */\n  pipes?: PipeTypesOrFactory | null;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the component's template.\n   */\n  schemas?: SchemaMetadata[] | null;\n}): never {\n  return noSideEffects(() => {\n           // Initialize ngDevMode. This must be the first statement in ɵɵdefineComponent.\n           // See the `initNgDevMode` docstring for more information.\n           (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n\n           const type = componentDefinition.type;\n           const typePrototype = type.prototype;\n           const declaredInputs: {[key: string]: string} = {} as any;\n           const def: Mutable<ComponentDef<any>, keyof ComponentDef<any>> = {\n             type: type,\n             providersResolver: null,\n             decls: componentDefinition.decls,\n             vars: componentDefinition.vars,\n             factory: null,\n             template: componentDefinition.template || null!,\n             consts: componentDefinition.consts || null,\n             ngContentSelectors: componentDefinition.ngContentSelectors,\n             hostBindings: componentDefinition.hostBindings || null,\n             hostVars: componentDefinition.hostVars || 0,\n             hostAttrs: componentDefinition.hostAttrs || null,\n             contentQueries: componentDefinition.contentQueries || null,\n             declaredInputs: declaredInputs,\n             inputs: null!,   // assigned in noSideEffects\n             outputs: null!,  // assigned in noSideEffects\n             exportAs: componentDefinition.exportAs || null,\n             onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n             directiveDefs: null!,  // assigned in noSideEffects\n             pipeDefs: null!,       // assigned in noSideEffects\n             selectors: componentDefinition.selectors || EMPTY_ARRAY,\n             viewQuery: componentDefinition.viewQuery || null,\n             features: componentDefinition.features as DirectiveDefFeature[] || null,\n             data: componentDefinition.data || {},\n             // TODO(misko): convert ViewEncapsulation into const enum so that it can be used\n             // directly in the next line. Also `None` should be 0 not 2.\n             encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n             id: 'c',\n             styles: componentDefinition.styles || EMPTY_ARRAY,\n             _: null as never,\n             setInput: null,\n             schemas: componentDefinition.schemas || null,\n             tView: null,\n           };\n           const directiveTypes = componentDefinition.directives!;\n           const feature = componentDefinition.features;\n           const pipeTypes = componentDefinition.pipes!;\n           def.id += _renderCompCount++;\n           def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\n           def.outputs = invertObject(componentDefinition.outputs),\n           feature && feature.forEach((fn) => fn(def));\n           def.directiveDefs = directiveTypes ?\n               () => (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes)\n                         .map(extractDirectiveDef) :\n               null;\n           def.pipeDefs = pipeTypes ?\n               () =>\n                   (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef) :\n               null;\n\n           return def as never;\n         }) as never;\n}\n\n/**\n * Generated next to NgModules to monkey-patch directive and pipe references onto a component's\n * definition, when generating a direct reference in the component file would otherwise create an\n * import cycle.\n *\n * See [this explanation](https://hackmd.io/Odw80D0pR6yfsOjg_7XCJg?view) for more details.\n *\n * @codeGenApi\n */\nexport function ɵɵsetComponentScope(\n    type: ComponentType<any>, directives: Type<any>[], pipes: Type<any>[]): void {\n  const def = (type.ɵcmp as ComponentDef<any>);\n  def.directiveDefs = () => directives.map(extractDirectiveDef);\n  def.pipeDefs = () => pipes.map(extractPipeDef);\n}\n\nexport function extractDirectiveDef(type: Type<any>): DirectiveDef<any>|ComponentDef<any> {\n  const def = getComponentDef(type) || getDirectiveDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is neither 'ComponentType' or 'DirectiveType'.`);\n  }\n  return def!;\n}\n\nexport function extractPipeDef(type: Type<any>): PipeDef<any> {\n  const def = getPipeDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is not a 'PipeType'.`);\n  }\n  return def!;\n}\n\nexport const autoRegisterModuleById: {[id: string]: NgModuleType} = {};\n\n/**\n * @codeGenApi\n */\nexport function ɵɵdefineNgModule<T>(def: {\n  /** Token representing the module. Used by DI. */\n  type: T;\n\n  /** List of components to bootstrap. */\n  bootstrap?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n\n  /** The set of schemas that declare elements to be allowed in the NgModule. */\n  schemas?: SchemaMetadata[] | null;\n\n  /** Unique ID for the module that is used with `getModuleFactory`. */\n  id?: string | null;\n}): never {\n  const res: NgModuleDef<T> = {\n    type: def.type,\n    bootstrap: def.bootstrap || EMPTY_ARRAY,\n    declarations: def.declarations || EMPTY_ARRAY,\n    imports: def.imports || EMPTY_ARRAY,\n    exports: def.exports || EMPTY_ARRAY,\n    transitiveCompileScopes: null,\n    schemas: def.schemas || null,\n    id: def.id || null,\n  };\n  if (def.id != null) {\n    noSideEffects(() => {\n      autoRegisterModuleById[def.id!] = def.type as unknown as NgModuleType;\n    });\n  }\n  return res as never;\n}\n\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nexport function ɵɵsetNgModuleScope(type: any, scope: {\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[]|(() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n}): void {\n  return noSideEffects(() => {\n           const ngModuleDef = getNgModuleDef(type, true);\n           ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n           ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n           ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n         }) as never;\n}\n\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject<T>(\n    obj?: {[P in keyof T]?: string|[string, string]},\n    secondary?: {[key: string]: string}): {[P in keyof T]: string} {\n  if (obj == null) return EMPTY_OBJ as any;\n  const newLookup: any = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName: string|[string, string] = obj[minifiedKey]!;\n      let declaredName = publicName;\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n      newLookup[publicName] = minifiedKey;\n      if (secondary) {\n        (secondary[publicName] = declaredName as string);\n      }\n    }\n  }\n  return newLookup;\n}\n\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static ɵdir = ɵɵdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport const ɵɵdefineDirective =\n    ɵɵdefineComponent as any as<T>(directiveDefinition: {\n      /**\n       * Directive type, needed to configure the injector.\n       */\n      type: Type<T>;\n\n      /** The selectors that will be used to match nodes to this directive. */\n      selectors?: CssSelectorList;\n\n      /**\n       * A map of input names.\n       *\n       * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n       *\n       * Given:\n       * ```\n       * class MyComponent {\n       *   @Input()\n       *   publicInput1: string;\n       *\n       *   @Input('publicInput2')\n       *   declaredInput2: string;\n       * }\n       * ```\n       *\n       * is described as:\n       * ```\n       * {\n       *   publicInput1: 'publicInput1',\n       *   declaredInput2: ['declaredInput2', 'publicInput2'],\n       * }\n       * ```\n       *\n       * Which the minifier may translate to:\n       * ```\n       * {\n       *   minifiedPublicInput1: 'publicInput1',\n       *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n       * }\n       * ```\n       *\n       * This allows the render to re-construct the minified, public, and declared names\n       * of properties.\n       *\n       * NOTE:\n       *  - Because declared and public name are usually same we only generate the array\n       *    `['declared', 'public']` format when they differ.\n       *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n       *    inconsistent behavior in that it uses declared names rather than minified or public. For\n       *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n       *    API will be simplified to be consistent with `output`.\n       */\n      inputs?: {[P in keyof T]?: string | [string, string]};\n\n      /**\n       * A map of output names.\n       *\n       * The format is in: `{[actualPropertyName: string]:string}`.\n       *\n       * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n       *\n       * This allows the render to re-construct the minified and non-minified names\n       * of properties.\n       */\n      outputs?: {[P in keyof T]?: string};\n\n      /**\n       * A list of optional features to apply.\n       *\n       * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}\n       */\n      features?: DirectiveDefFeature[];\n\n      /**\n       * Function executed by the parent template to allow child directive to apply host bindings.\n       */\n      hostBindings?: HostBindingsFunction<T>;\n\n      /**\n       * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n       *\n       * Used to calculate the length of the component's LView array, so we\n       * can pre-fill the array and set the host binding start index.\n       */\n      hostVars?: number;\n\n      /**\n       * Assign static attribute values to a host element.\n       *\n       * This property will assign static attribute values as well as class and style\n       * values to a host element. Since attribute values can consist of different types of values,\n       * the `hostAttrs` array must include the values in the following format:\n       *\n       * attrs = [\n       *   // static attributes (like `title`, `name`, `id`...)\n       *   attr1, value1, attr2, value,\n       *\n       *   // a single namespace value (like `x:id`)\n       *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n       *\n       *   // another single namespace value (like `x:name`)\n       *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n       *\n       *   // a series of CSS classes that will be applied to the element (no spaces)\n       *   CLASSES_MARKER, class1, class2, class3,\n       *\n       *   // a series of CSS styles (property + value) that will be applied to the element\n       *   STYLES_MARKER, prop1, value1, prop2, value2\n       * ]\n       *\n       * All non-class and non-style attributes must be defined at the start of the list\n       * first before all class and style values are set. When there is a change in value\n       * type (like when classes and styles are introduced) a marker must be used to separate\n       * the entries. The marker values themselves are set via entries found in the\n       * [AttributeMarker] enum.\n       */\n      hostAttrs?: TAttributes;\n\n      /**\n       * Function to create instances of content queries associated with a given directive.\n       */\n      contentQueries?: ContentQueriesFunction<T>;\n\n      /**\n       * Additional set of instructions specific to view query processing. This could be seen as a\n       * set of instructions to be inserted into the template function.\n       */\n      viewQuery?: ViewQueriesFunction<T>| null;\n\n      /**\n       * Defines the name that can be used in the template to assign this directive to a variable.\n       *\n       * See: {@link Directive.exportAs}\n       */\n      exportAs?: string[];\n    }) => never;\n\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static ɵpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nexport function ɵɵdefinePipe<T>(pipeDef: {\n  /** Name of the pipe. Used for matching pipes in template to pipe defs. */\n  name: string,\n\n  /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\n  type: Type<T>,\n\n  /** Whether the pipe is pure. */\n  pure?: boolean\n}): never {\n  return (<PipeDef<T>>{\n           type: pipeDef.type,\n           name: pipeDef.name,\n           factory: null,\n           pure: pipeDef.pure !== false,\n           onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n         }) as never;\n}\n\n/**\n * The following getter methods retrieve the definition from the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\nexport function getComponentDef<T>(type: any): ComponentDef<T>|null {\n  return type[NG_COMP_DEF] || null;\n}\n\nexport function getDirectiveDef<T>(type: any): DirectiveDef<T>|null {\n  return type[NG_DIR_DEF] || null;\n}\n\nexport function getPipeDef<T>(type: any): PipeDef<T>|null {\n  return type[NG_PIPE_DEF] || null;\n}\n\nexport function getNgModuleDef<T>(type: any, throwNotFound: true): NgModuleDef<T>;\nexport function getNgModuleDef<T>(type: any): NgModuleDef<T>|null;\nexport function getNgModuleDef<T>(type: any, throwNotFound?: boolean): NgModuleDef<T>|null {\n  const ngModuleDef = type[NG_MOD_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);\n  }\n  return ngModuleDef;\n}\n\nexport function getNgLocaleIdDef(type: any): string|null {\n  return (type as any)[NG_LOC_ID_DEF] || null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {LContainer, TYPE} from './container';\nimport {ComponentDef, DirectiveDef} from './definition';\nimport {TNode, TNodeFlags} from './node';\nimport {RNode} from './renderer_dom';\nimport {FLAGS, LView, LViewFlags} from './view';\n\n\n/**\n * True if `value` is `LView`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLView(value: RNode|LView|LContainer|{}|null): value is LView {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLContainer(value: RNode|LView|LContainer|{}|null): value is LContainer {\n  return Array.isArray(value) && value[TYPE] === true;\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponentHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponentHost) === TNodeFlags.isComponentHost;\n}\n\nexport function isDirectiveHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isDirectiveHost) === TNodeFlags.isDirectiveHost;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return (def as ComponentDef<T>).template !== null;\n}\n\nexport function isRootView(target: LView): boolean {\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TNode} from './node';\nimport {RComment, RElement} from './renderer_dom';\nimport {HOST, LView, NEXT, PARENT, T_HOST, TRANSPLANTED_VIEWS_TO_REFRESH} from './view';\n\n\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nexport const TYPE = 1;\n\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\n\n/**\n * Flag to signify that this `LContainer` may have transplanted views which need to be change\n * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n *\n * This flag, once set, is never unset for the `LContainer`. This means that when unset we can skip\n * a lot of work in `refreshEmbeddedViews`. But when set we still need to verify\n * that the `MOVED_VIEWS` are transplanted and on-push.\n */\nexport const HAS_TRANSPLANTED_VIEWS = 2;\n\n// PARENT, NEXT, TRANSPLANTED_VIEWS_TO_REFRESH are indices 3, 4, and 5\n// As we already have these constants in LView, we don't need to re-create them.\n\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\n\nexport const NATIVE = 7;\nexport const VIEW_REFS = 8;\nexport const MOVED_VIEWS = 9;\n\n\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nexport const CONTAINER_HEADER_OFFSET = 10;\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   */\n  readonly[HOST]: RElement|RComment|LView;\n\n  /**\n   * This is a type field which allows us to differentiate `LContainer` from `StylingContext` in an\n   * efficient way. The value is always set to `true`\n   */\n  [TYPE]: true;\n\n  /**\n   * Flag to signify that this `LContainer` may have transplanted views which need to be change\n   * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n   *\n   * This flag, once set, is never unset for the `LContainer`.\n   */\n  [HAS_TRANSPLANTED_VIEWS]: boolean;\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /**\n   * The number of direct transplanted views which need a refresh or have descendants themselves\n   * that need a refresh but have not marked their ancestors as Dirty. This tells us that during\n   * change detection we should still descend to find those children to refresh, even if the parents\n   * are not `Dirty`/`CheckAlways`.\n   */\n  [TRANSPLANTED_VIEWS_TO_REFRESH]: number;\n\n  /**\n   * A collection of views created based on the underlying `<ng-template>` element but inserted into\n   * a different `LContainer`. We need to track views created from a given declaration point since\n   * queries collect matches from the embedded view declaration point and _not_ the insertion point.\n   */\n  [MOVED_VIEWS]: LView[]|null;\n\n  /**\n   * Pointer to the `TNode` which represents the host of the container.\n   */\n  [T_HOST]: TNode;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  readonly[NATIVE]:\n      RComment;  // TODO(misko): remove as this value can be gotten by unwrapping `[HOST]`\n\n  /**\n   * Array of `ViewRef`s used by any `ViewContainerRef`s that point to this container.\n   *\n   * This is lazily initialized by `ViewContainerRef` when the first view is inserted.\n   *\n   * NOTE: This is stored as `any[]` because render3 should really not be aware of `ViewRef` and\n   * doing so creates circular dependency.\n   */\n  [VIEW_REFS]: unknown[]|null;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\nimport {NG_FACTORY_DEF} from './fields';\n\n\n/**\n * Definition of what a factory function should look like.\n */\nexport type FactoryFn<T> = {\n  /**\n   * Subclasses without an explicit constructor call through to the factory of their base\n   * definition, providing it with their own constructor to instantiate.\n   */\n  <U extends T>(t: Type<U>): U;\n\n  /**\n   * If no constructor to instantiate is provided, an instance of type T itself is created.\n   */\n  (t?: undefined): T;\n};\n\n\nexport function getFactoryDef<T>(type: any, throwNotFound: true): FactoryFn<T>;\nexport function getFactoryDef<T>(type: any): FactoryFn<T>|null;\nexport function getFactoryDef<T>(type: any, throwNotFound?: boolean): FactoryFn<T>|null {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const enum RuntimeErrorCode {\n  // Internal Errors\n\n  // Change Detection Errors\n  EXPRESSION_CHANGED_AFTER_CHECKED = '100',\n\n  // Dependency Injection Errors\n  CYCLIC_DI_DEPENDENCY = '200',\n  PROVIDER_NOT_FOUND = '201',\n\n  // Template Errors\n  MULTIPLE_COMPONENTS_MATCH = '300',\n  EXPORT_NOT_FOUND = '301',\n  PIPE_NOT_FOUND = '302',\n  UNKNOWN_BINDING = '303',\n  UNKNOWN_ELEMENT = '304',\n\n  // Styling Errors\n\n  // Declarations Errors\n\n  // i18n Errors\n\n  // Compilation Errors\n}\n\nexport class RuntimeError extends Error {\n  constructor(public code: RuntimeErrorCode, message: string) {\n    super(formatRuntimeError(code, message));\n  }\n}\n\n/** Called to format a runtime error */\nexport function formatRuntimeError(code: RuntimeErrorCode, message: string): string {\n  const fullCode = code ? `NG0${code}: ` : '';\n  return `${fullCode}${message}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\n */\nexport function renderStringify(value: any): string {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  // Use `String` so that it invokes the `toString` method of the value. Note that this\n  // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\n  return String(value);\n}\n\n\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nexport function stringifyForError(value: any): string {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n\n  return renderStringify(value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectorType} from '../di/interface/defs';\nimport {stringify} from '../util/stringify';\nimport {RuntimeError, RuntimeErrorCode} from './error_code';\nimport {stringifyForError} from './util/stringify_utils';\n\n\n/** Called when directives inject each other (creating a circular dependency) */\nexport function throwCyclicDependencyError(token: string, path?: string[]): never {\n  const depPath = path ? `. Dependency path: ${path.join(' > ')} > ${token}` : '';\n  throw new RuntimeError(\n      RuntimeErrorCode.CYCLIC_DI_DEPENDENCY,\n      `Circular dependency in DI detected for ${token}${depPath}`);\n}\n\nexport function throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\n\nexport function throwInvalidProviderError(\n    ngModuleType?: InjectorType<any>, providers?: any[], provider?: any) {\n  let ngModuleDetail = '';\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    ngModuleDetail =\n        ` - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`;\n  }\n\n  throw new Error(\n      `Invalid provider for the NgModule '${stringify(ngModuleType)}'` + ngModuleDetail);\n}\n\n\n/** Throws an error when a token is not found in DI. */\nexport function throwProviderNotFoundError(token: any, injectorName?: string): never {\n  const injectorDetails = injectorName ? ` in ${injectorName}` : '';\n  throw new RuntimeError(\n      RuntimeErrorCode.PROVIDER_NOT_FOUND,\n      `No provider for ${stringifyForError(token)} found${injectorDetails}`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a basic change from a previous to a new value for a single\n * property on a directive instance. Passed as a value in a\n * {@link SimpleChanges} object to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport class SimpleChange {\n  constructor(public previousValue: any, public currentValue: any, public firstChange: boolean) {}\n  /**\n   * Check whether the new value is the first value assigned.\n   */\n  isFirstChange(): boolean {\n    return this.firstChange;\n  }\n}\n\n/**\n * A hashtable of changes represented by {@link SimpleChange} objects stored\n * at the declared property name they belong to on a Directive or Component. This is\n * the type passed to the `ngOnChanges` hook.\n *\n * @see `OnChanges`\n *\n * @publicApi\n */\nexport interface SimpleChanges {\n  [propName: string]: SimpleChange;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnChanges} from '../../interface/lifecycle_hooks';\nimport {SimpleChange, SimpleChanges} from '../../interface/simple_change';\nimport {EMPTY_OBJ} from '../empty';\nimport {DirectiveDef, DirectiveDefFeature} from '../interfaces/definition';\n\n/**\n * The NgOnChangesFeature decorates a component with support for the ngOnChanges\n * lifecycle hook, so it should be included in any component that implements\n * that hook.\n *\n * If the component or directive uses inheritance, the NgOnChangesFeature MUST\n * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise\n * inherited properties will not be propagated to the ngOnChanges lifecycle\n * hook.\n *\n * Example usage:\n *\n * ```\n * static ɵcmp = defineComponent({\n *   ...\n *   inputs: {name: 'publicName'},\n *   features: [NgOnChangesFeature]\n * });\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵNgOnChangesFeature<T>(): DirectiveDefFeature {\n  return NgOnChangesFeatureImpl;\n}\n\nexport function NgOnChangesFeatureImpl<T>(definition: DirectiveDef<T>) {\n  if (definition.type.prototype.ngOnChanges) {\n    definition.setInput = ngOnChangesSetInput;\n  }\n  return rememberChangeHistoryAndInvokeOnChangesHook;\n}\n\n// This option ensures that the ngOnChanges lifecycle hook will be inherited\n// from superclasses (in InheritDefinitionFeature).\n/** @nocollapse */\n// tslint:disable-next-line:no-toplevel-property-access\n(ɵɵNgOnChangesFeature as DirectiveDefFeature).ngInherit = true;\n\n/**\n * This is a synthetic lifecycle hook which gets inserted into `TView.preOrderHooks` to simulate\n * `ngOnChanges`.\n *\n * The hook reads the `NgSimpleChangesStore` data from the component instance and if changes are\n * found it invokes `ngOnChanges` on the component instance.\n *\n * @param this Component instance. Because this function gets inserted into `TView.preOrderHooks`,\n *     it is guaranteed to be called with component instance.\n */\nfunction rememberChangeHistoryAndInvokeOnChangesHook(this: OnChanges) {\n  const simpleChangesStore = getSimpleChangesStore(this);\n  const current = simpleChangesStore?.current;\n\n  if (current) {\n    const previous = simpleChangesStore!.previous;\n    if (previous === EMPTY_OBJ) {\n      simpleChangesStore!.previous = current;\n    } else {\n      // New changes are copied to the previous store, so that we don't lose history for inputs\n      // which were not changed this time\n      for (let key in current) {\n        previous[key] = current[key];\n      }\n    }\n    simpleChangesStore!.current = null;\n    this.ngOnChanges(current);\n  }\n}\n\n\nfunction ngOnChangesSetInput<T>(\n    this: DirectiveDef<T>, instance: T, value: any, publicName: string, privateName: string): void {\n  const simpleChangesStore = getSimpleChangesStore(instance) ||\n      setSimpleChangesStore(instance, {previous: EMPTY_OBJ, current: null});\n  const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n  const previous = simpleChangesStore.previous;\n\n  const declaredName = (this.declaredInputs as {[key: string]: string})[publicName];\n  const previousChange = previous[declaredName];\n  current[declaredName] = new SimpleChange(\n      previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n\n  (instance as any)[privateName] = value;\n}\n\nconst SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';\n\nfunction getSimpleChangesStore(instance: any): null|NgSimpleChangesStore {\n  return instance[SIMPLE_CHANGES_STORE] || null;\n}\n\nfunction setSimpleChangesStore(instance: any, store: NgSimpleChangesStore): NgSimpleChangesStore {\n  return instance[SIMPLE_CHANGES_STORE] = store;\n}\n\n/**\n * Data structure which is monkey-patched on the component instance and used by `ngOnChanges`\n * life-cycle hook to track previous input values.\n */\ninterface NgSimpleChangesStore {\n  previous: SimpleChanges;\n  current: SimpleChanges|null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser`, `Server`, and `WebWorker`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT: Document|undefined = undefined;\n\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nexport function setDocument(document: Document|undefined): void {\n  DOCUMENT = document;\n}\n\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nexport function getDocument(): Document {\n  if (DOCUMENT !== undefined) {\n    return DOCUMENT;\n  } else if (typeof document !== 'undefined') {\n    return document;\n  }\n  // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n  // the current platform is not a browser. Since this is not a supported scenario at the moment\n  // this should not happen in Angular apps.\n  // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n  // public API. Meanwhile we just return `undefined` and let the application fail.\n  return undefined!;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and then\n * use that at runtime for rendering.\n *\n * At runtime we can then use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\n\nimport {RendererStyleFlags2, RendererType2} from '../../render/api_flags';\nimport {TrustedHTML, TrustedScript, TrustedScriptURL} from '../../util/security/trusted_type_defs';\nimport {getDocument} from './document';\nimport {RComment, RElement, RNode, RText} from './renderer_dom';\n\n// TODO: cleanup once the code is merged in angular/angular\nexport enum RendererStyleFlags3 {\n  Important = 1 << 0,\n  DashCase = 1 << 1\n}\n\nexport type Renderer3 = ObjectOrientedRenderer3|ProceduralRenderer3;\n\nexport type GlobalTargetName = 'document'|'window'|'body';\n\nexport type GlobalTargetResolver = (element: any) => {\n  name: GlobalTargetName, target: EventTarget\n};\n\n/**\n * Object Oriented style of API needed to create elements and text nodes.\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade\n * (reducing payload size).\n * */\nexport interface ObjectOrientedRenderer3 {\n  createComment(data: string): RComment;\n  createElement(tagName: string): RElement;\n  createElementNS(namespace: string, tagName: string): RElement;\n  createTextNode(data: string): RText;\n\n  querySelector(selectors: string): RElement|null;\n}\n\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\nexport function isProceduralRenderer(renderer: ProceduralRenderer3|\n                                     ObjectOrientedRenderer3): renderer is ProceduralRenderer3 {\n  return !!((renderer as any).listen);\n}\n\n/**\n * Procedural style of API needed to create elements and text nodes.\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\n * facade that enables element manipulation. This also facilitates backwards compatibility\n * with Renderer2.\n */\nexport interface ProceduralRenderer3 {\n  destroy(): void;\n  createComment(value: string): RComment;\n  createElement(name: string, namespace?: string|null): RElement;\n  createText(value: string): RText;\n  /**\n   * This property is allowed to be null / undefined,\n   * in which case the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  destroyNode?: ((node: RNode) => void)|null;\n  appendChild(parent: RElement, newChild: RNode): void;\n  insertBefore(parent: RNode, newChild: RNode, refChild: RNode|null, isMove?: boolean): void;\n  removeChild(parent: RElement, oldChild: RNode, isHostElement?: boolean): void;\n  selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): RElement;\n\n  parentNode(node: RNode): RElement|null;\n  nextSibling(node: RNode): RNode|null;\n\n  setAttribute(\n      el: RElement, name: string, value: string|TrustedHTML|TrustedScript|TrustedScriptURL,\n      namespace?: string|null): void;\n  removeAttribute(el: RElement, name: string, namespace?: string|null): void;\n  addClass(el: RElement, name: string): void;\n  removeClass(el: RElement, name: string): void;\n  setStyle(\n      el: RElement, style: string, value: any,\n      flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  setProperty(el: RElement, name: string, value: any): void;\n  setValue(node: RText|RComment, value: string): void;\n\n  // TODO(misko): Deprecate in favor of addEventListener/removeEventListener\n  listen(\n      target: GlobalTargetName|RNode, eventName: string,\n      callback: (event: any) => boolean | void): () => void;\n}\n\nexport interface RendererFactory3 {\n  createRenderer(hostElement: RElement|null, rendererType: RendererType2|null): Renderer3;\n  begin?(): void;\n  end?(): void;\n}\n\nexport const domRendererFactory3: RendererFactory3 = {\n  createRenderer: (hostElement: RElement|null, rendererType: RendererType2|null): Renderer3 => {\n    return getDocument();\n  }\n};\n\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertDomNode, assertGreaterThan, assertGreaterThanOrEqual, assertIndexInRange, assertLessThan} from '../../util/assert';\nimport {assertTNode, assertTNodeForLView} from '../assert';\nimport {LContainer, TYPE} from '../interfaces/container';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from '../interfaces/context';\nimport {TConstants, TNode} from '../interfaces/node';\nimport {isProceduralRenderer} from '../interfaces/renderer';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {isLContainer, isLView} from '../interfaces/type_checks';\nimport {FLAGS, HEADER_OFFSET, HOST, LView, LViewFlags, PARENT, PREORDER_HOOK_FLAGS, RENDERER, TData, TRANSPLANTED_VIEWS_TO_REFRESH, TView} from '../interfaces/view';\n\n\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapRNode(value: RNode|LView|LContainer): RNode {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value as RNode;\n}\n\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLView(value: RNode|LView|LContainer): LView|null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLView()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (typeof value[TYPE] === 'object') return value as LView;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Returns `LContainer` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLContainer(value: RNode|LView|LContainer): LContainer|null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLContainer()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (value[TYPE] === true) return value as LContainer;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, lView: LView): RNode {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\n  return unwrapRNode(lView[index]);\n}\n\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNode(tNode: TNode, lView: LView): RNode {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node: RNode = unwrapRNode(lView[tNode.index]);\n  ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n  return node;\n}\n\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNodeOrNull(tNode: TNode|null, lView: LView): RNode|null {\n  const index = tNode === null ? -1 : tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode!, lView);\n    const node: RNode|null = unwrapRNode(lView[index]);\n    ngDevMode && node !== null && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n    return node;\n  }\n  return null;\n}\n\n\n// fixme(misko): The return Type should be `TNode|null`\nexport function getTNode(tView: TView, index: number): TNode {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  const tNode = tView.data[index] as TNode;\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\n\n/** Retrieves a value from any `LView` or `TData`. */\nexport function load<T>(view: LView|TData, index: number): T {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\n\nexport function getComponentLViewByIndex(nodeIndex: number, hostView: LView): LView {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\n\n\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nexport function readPatchedData(target: any): LView|LContext|null {\n  ngDevMode && assertDefined(target, 'Target expected');\n  return target[MONKEY_PATCH_KEY_NAME] || null;\n}\n\nexport function readPatchedLView(target: any): LView|null {\n  const value = readPatchedData(target);\n  if (value) {\n    return Array.isArray(value) ? value : (value as LContext).lView;\n  }\n  return null;\n}\n\n/** Checks whether a given view is in creation mode */\nexport function isCreationMode(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n}\n\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nexport function viewAttachedToChangeDetector(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/** Returns a boolean for whether the view is attached to a container. */\nexport function viewAttachedToContainer(view: LView): boolean {\n  return isLContainer(view[PARENT]);\n}\n\n/** Returns a constant from `TConstants` instance. */\nexport function getConstant<T>(consts: TConstants|null, index: null|undefined): null;\nexport function getConstant<T>(consts: TConstants, index: number): T|null;\nexport function getConstant<T>(consts: TConstants|null, index: number|null|undefined): T|null;\nexport function getConstant<T>(consts: TConstants|null, index: number|null|undefined): T|null {\n  if (index === null || index === undefined) return null;\n  ngDevMode && assertIndexInRange(consts!, index);\n  return consts![index] as unknown as T;\n}\n\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nexport function resetPreOrderHookFlags(lView: LView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\n\n/**\n * Updates the `TRANSPLANTED_VIEWS_TO_REFRESH` counter on the `LContainer` as well as the parents\n * whose\n *  1. counter goes from 0 to 1, indicating that there is a new child that has a view to refresh\n *  or\n *  2. counter goes from 1 to 0, indicating there are no more descendant views to refresh\n */\nexport function updateTransplantedViewCount(lContainer: LContainer, amount: 1|- 1) {\n  lContainer[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n  let viewOrContainer: LView|LContainer = lContainer;\n  let parent: LView|LContainer|null = lContainer[PARENT];\n  while (parent !== null &&\n         ((amount === 1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 1) ||\n          (amount === -1 && viewOrContainer[TRANSPLANTED_VIEWS_TO_REFRESH] === 0))) {\n    parent[TRANSPLANTED_VIEWS_TO_REFRESH] += amount;\n    viewOrContainer = parent;\n    parent = parent[PARENT];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {Injector} from '../../di/injector';\nimport {Type} from '../../interface/type';\nimport {SchemaMetadata} from '../../metadata/schema';\nimport {Sanitizer} from '../../sanitization/sanitizer';\nimport {LContainer} from './container';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList, ViewQueriesFunction} from './definition';\nimport {I18nUpdateOpCodes, TI18n, TIcu} from './i18n';\nimport {TConstants, TNode} from './node';\nimport {PlayerHandler} from './player';\nimport {LQueries, TQueries} from './query';\nimport {Renderer3, RendererFactory3} from './renderer';\nimport {RComment, RElement} from './renderer_dom';\nimport {TStylingKey, TStylingRange} from './styling';\n\n\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nexport const HOST = 0;\nexport const TVIEW = 1;\nexport const FLAGS = 2;\nexport const PARENT = 3;\nexport const NEXT = 4;\nexport const TRANSPLANTED_VIEWS_TO_REFRESH = 5;\nexport const T_HOST = 6;\nexport const CLEANUP = 7;\nexport const CONTEXT = 8;\nexport const INJECTOR = 9;\nexport const RENDERER_FACTORY = 10;\nexport const RENDERER = 11;\nexport const SANITIZER = 12;\nexport const CHILD_HEAD = 13;\nexport const CHILD_TAIL = 14;\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\nexport const DECLARATION_VIEW = 15;\nexport const DECLARATION_COMPONENT_VIEW = 16;\nexport const DECLARATION_LCONTAINER = 17;\nexport const PREORDER_HOOK_FLAGS = 18;\nexport const QUERIES = 19;\n/**\n * Size of LView's header. Necessary to adjust for it when setting slots.\n *\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\n */\nexport const HEADER_OFFSET = 20;\n\n\n// This interface replaces the real LView interface if it is an arg or a\n// return value of a public instruction. This ensures we don't need to expose\n// the actual interface, which should be kept private.\nexport interface OpaqueViewState {\n  '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `viewData` to that\n * `LView`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LView extends Array<any> {\n  /**\n   * Human readable representation of the `LView`.\n   *\n   * NOTE: This property only exists if `ngDevMode` is set to `true` and it is not present in\n   * production. Its presence is purely to help debug issue in development, and should not be relied\n   * on in production application.\n   */\n  debug?: LViewDebug;\n\n  /**\n   * The node into which this `LView` is inserted.\n   */\n  [HOST]: RElement|null;\n\n  /**\n   * The static data for this view. We need a reference to this so we can easily walk up the\n   * node tree in DI and get the TView.data array associated with a node (where the\n   * directive defs are stored).\n   */\n  readonly[TVIEW]: TView;\n\n  /** Flags for this view. See LViewFlags for more info. */\n  [FLAGS]: LViewFlags;\n\n  /**\n   * This may store an {@link LView} or {@link LContainer}.\n   *\n   * `LView` - The parent view. This is needed when we exit the view and must restore the previous\n   * LView. Without this, the render method would have to keep a stack of\n   * views as it is recursively rendering templates.\n   *\n   * `LContainer` - The current view is part of a container, and is an embedded view.\n   */\n  [PARENT]: LView|LContainer|null;\n\n  /**\n   *\n   * The next sibling LView or LContainer.\n   *\n   * Allows us to propagate between sibling view states that aren't in the same\n   * container. Embedded views already have a node.next, but it is only set for\n   * views in the same container. We need a way to link component views and views\n   * across containers as well.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /** Queries active for this view - nodes from a view are reported to those queries. */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * Store the `TNode` of the location where the current `LView` is inserted into.\n   *\n   * Given:\n   * ```\n   * <div>\n   *   <ng-template><span></span></ng-template>\n   * </div>\n   * ```\n   *\n   * We end up with two `TView`s.\n   * - `parent` `TView` which contains `<div><!-- anchor --></div>`\n   * - `child` `TView` which contains `<span></span>`\n   *\n   * Typically the `child` is inserted into the declaration location of the `parent`, but it can be\n   * inserted anywhere. Because it can be inserted anywhere it is not possible to store the\n   * insertion information in the `TView` and instead we must store it in the `LView[T_HOST]`.\n   *\n   * So to determine where is our insertion parent we would execute:\n   * ```\n   * const parentLView = lView[PARENT];\n   * const parentTNode = lView[T_HOST];\n   * const insertionParent = parentLView[parentTNode.index];\n   * ```\n   *\n   *\n   * If `null`, this is the root view of an application (root component is in this view) and it has\n   * no parents.\n   */\n  [T_HOST]: TNode|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This context array stores both listener functions wrapped with\n   * their context and output subscription instances for a particular view.\n   *\n   * These change per LView instance, so they cannot be stored on TView. Instead,\n   * TView.cleanup saves an index to the necessary context in this array.\n   *\n   * After `LView` is created it is possible to attach additional instance specific functions at the\n   * end of the `lView[CLENUP]` because we know that no more `T` level cleanup functions will be\n   * addeded here.\n   */\n  [CLEANUP]: any[]|null;\n\n  /**\n   * - For dynamic views, this is the context with which to render the template (e.g.\n   *   `NgForContext`), or `{}` if not defined explicitly.\n   * - For root view of the root component the context contains change detection data.\n   * - For non-root components, the context is the component instance,\n   * - For inline views, the context is null.\n   */\n  [CONTEXT]: {}|RootContext|null;\n\n  /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\n  readonly[INJECTOR]: Injector|null;\n\n  /** Factory to be used for creating Renderer. */\n  [RENDERER_FACTORY]: RendererFactory3;\n\n  /** Renderer to be used for this view. */\n  [RENDERER]: Renderer3;\n\n  /** An optional custom sanitizer. */\n  [SANITIZER]: Sanitizer|null;\n\n  /**\n   * Reference to the first LView or LContainer beneath this LView in\n   * the hierarchy.\n   *\n   * Necessary to store this so views can traverse through their nested views\n   * to remove listeners and call onDestroy callbacks.\n   */\n  [CHILD_HEAD]: LView|LContainer|null;\n\n  /**\n   * The last LView or LContainer beneath this LView in the hierarchy.\n   *\n   * The tail allows us to quickly add a new state to the end of the view list\n   * without having to propagate starting from the first child.\n   */\n  [CHILD_TAIL]: LView|LContainer|null;\n\n  /**\n   * View where this view's template was declared.\n   *\n   * The template for a dynamically created view may be declared in a different view than\n   * it is inserted. We already track the \"insertion view\" (view where the template was\n   * inserted) in LView[PARENT], but we also need access to the \"declaration view\"\n   * (view where the template was declared). Otherwise, we wouldn't be able to call the\n   * view's template function with the proper contexts. Context should be inherited from\n   * the declaration view tree, not the insertion view tree.\n   *\n   * Example (AppComponent template):\n   *\n   * <ng-template #foo></ng-template>       <-- declared here -->\n   * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n   *\n   * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n   * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n   * but the insertion view would be SomeComp. When we are removing views, we would want to\n   * traverse through the insertion view to clean up listeners. When we are calling the\n   * template function during change detection, we need the declaration view to get inherited\n   * context.\n   */\n  [DECLARATION_VIEW]: LView|null;\n\n\n  /**\n   * Points to the declaration component view, used to track transplanted `LView`s.\n   *\n   * See: `DECLARATION_VIEW` which points to the actual `LView` where it was declared, whereas\n   * `DECLARATION_COMPONENT_VIEW` points to the component which may not be same as\n   * `DECLARATION_VIEW`.\n   *\n   * Example:\n   * ```\n   * <#VIEW #myComp>\n   *  <div *ngIf=\"true\">\n   *   <ng-template #myTmpl>...</ng-template>\n   *  </div>\n   * </#VIEW>\n   * ```\n   * In the above case `DECLARATION_VIEW` for `myTmpl` points to the `LView` of `ngIf` whereas\n   * `DECLARATION_COMPONENT_VIEW` points to `LView` of the `myComp` which owns the template.\n   *\n   * The reason for this is that all embedded views are always check-always whereas the component\n   * view can be check-always or on-push. When we have a transplanted view it is important to\n   * determine if we have transplanted a view from check-always declaration to on-push insertion\n   * point. In such a case the transplanted view needs to be added to the `LContainer` in the\n   * declared `LView` and CD during the declared view CD (in addition to the CD at the insertion\n   * point.) (Any transplanted views which are intra Component are of no interest because the CD\n   * strategy of declaration and insertion will always be the same, because it is the same\n   * component.)\n   *\n   * Queries already track moved views in `LView[DECLARATION_LCONTAINER]` and\n   * `LContainer[MOVED_VIEWS]`. However the queries also track `LView`s which moved within the same\n   * component `LView`. Transplanted views are a subset of moved views, and we use\n   * `DECLARATION_COMPONENT_VIEW` to differentiate them. As in this example.\n   *\n   * Example showing intra component `LView` movement.\n   * ```\n   * <#VIEW #myComp>\n   *   <div *ngIf=\"condition; then thenBlock else elseBlock\"></div>\n   *   <ng-template #thenBlock>Content to render when condition is true.</ng-template>\n   *   <ng-template #elseBlock>Content to render when condition is false.</ng-template>\n   * </#VIEW>\n   * ```\n   * The `thenBlock` and `elseBlock` is moved but not transplanted.\n   *\n   * Example showing inter component `LView` movement (transplanted view).\n   * ```\n   * <#VIEW #myComp>\n   *   <ng-template #myTmpl>...</ng-template>\n   *   <insertion-component [template]=\"myTmpl\"></insertion-component>\n   * </#VIEW>\n   * ```\n   * In the above example `myTmpl` is passed into a different component. If `insertion-component`\n   * instantiates `myTmpl` and `insertion-component` is on-push then the `LContainer` needs to be\n   * marked as containing transplanted views and those views need to be CD as part of the\n   * declaration CD.\n   *\n   *\n   * When change detection runs, it iterates over `[MOVED_VIEWS]` and CDs any child `LView`s where\n   * the `DECLARATION_COMPONENT_VIEW` of the current component and the child `LView` does not match\n   * (it has been transplanted across components.)\n   *\n   * Note: `[DECLARATION_COMPONENT_VIEW]` points to itself if the LView is a component view (the\n   *       simplest / most common case).\n   *\n   * see also:\n   *   - https://hackmd.io/@mhevery/rJUJsvv9H write up of the problem\n   *   - `LContainer[HAS_TRANSPLANTED_VIEWS]` which marks which `LContainer` has transplanted views.\n   *   - `LContainer[TRANSPLANT_HEAD]` and `LContainer[TRANSPLANT_TAIL]` storage for transplanted\n   *   - `LView[DECLARATION_LCONTAINER]` similar problem for queries\n   *   - `LContainer[MOVED_VIEWS]` similar problem for queries\n   */\n  [DECLARATION_COMPONENT_VIEW]: LView;\n\n  /**\n   * A declaration point of embedded views (ones instantiated based on the content of a\n   * <ng-template>), null for other types of views.\n   *\n   * We need to track all embedded views created from a given declaration point so we can prepare\n   * query matches in a proper order (query matches are ordered based on their declaration point and\n   * _not_ the insertion point).\n   */\n  [DECLARATION_LCONTAINER]: LContainer|null;\n\n  /**\n   * More flags for this view. See PreOrderHookFlags for more info.\n   */\n  [PREORDER_HOOK_FLAGS]: PreOrderHookFlags;\n\n  /**\n   * The number of direct transplanted views which need a refresh or have descendants themselves\n   * that need a refresh but have not marked their ancestors as Dirty. This tells us that during\n   * change detection we should still descend to find those children to refresh, even if the parents\n   * are not `Dirty`/`CheckAlways`.\n   */\n  [TRANSPLANTED_VIEWS_TO_REFRESH]: number;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\nexport const enum LViewFlags {\n  /** The state of the init phase on the first 2 bits */\n  InitPhaseStateIncrementer = 0b00000000001,\n  InitPhaseStateMask = 0b00000000011,\n\n  /**\n   * Whether or not the view is in creationMode.\n   *\n   * This must be stored in the view rather than using `data` as a marker so that\n   * we can properly support embedded views. Otherwise, when exiting a child view\n   * back into the parent view, `data` will be defined and `creationMode` will be\n   * improperly reported as false.\n   */\n  CreationMode = 0b00000000100,\n\n  /**\n   * Whether or not this LView instance is on its first processing pass.\n   *\n   * An LView instance is considered to be on its \"first pass\" until it\n   * has completed one creation mode run and one update mode run. At this\n   * time, the flag is turned off.\n   */\n  FirstLViewPass = 0b00000001000,\n\n  /** Whether this view has default change detection strategy (checks always) or onPush */\n  CheckAlways = 0b00000010000,\n\n  /**\n   * Whether or not manual change detection is turned on for onPush components.\n   *\n   * This is a special mode that only marks components dirty in two cases:\n   * 1) There has been a change to an @Input property\n   * 2) `markDirty()` has been called manually by the user\n   *\n   * Note that in this mode, the firing of events does NOT mark components\n   * dirty automatically.\n   *\n   * Manual mode is turned off by default for backwards compatibility, as events\n   * automatically mark OnPush components dirty in View Engine.\n   *\n   * TODO: Add a public API to ChangeDetectionStrategy to turn this mode on\n   */\n  ManualOnPush = 0b00000100000,\n\n  /** Whether or not this view is currently dirty (needing check) */\n  Dirty = 0b000001000000,\n\n  /** Whether or not this view is currently attached to change detection tree. */\n  Attached = 0b000010000000,\n\n  /** Whether or not this view is destroyed. */\n  Destroyed = 0b000100000000,\n\n  /** Whether or not this view is the root view */\n  IsRoot = 0b001000000000,\n\n  /**\n   * Whether this moved LView was needs to be refreshed at the insertion location because the\n   * declaration was dirty.\n   */\n  RefreshTransplantedView = 0b0010000000000,\n\n  /**\n   * Index of the current init phase on last 21 bits\n   */\n  IndexWithinInitPhaseIncrementer = 0b0100000000000,\n  IndexWithinInitPhaseShift = 11,\n  IndexWithinInitPhaseReset = 0b0011111111111,\n}\n\n/**\n * Possible states of the init phase:\n * - 00: OnInit hooks to be run.\n * - 01: AfterContentInit hooks to be run\n * - 10: AfterViewInit hooks to be run\n * - 11: All init hooks have been run\n */\nexport const enum InitPhaseState {\n  OnInitHooksToBeRun = 0b00,\n  AfterContentInitHooksToBeRun = 0b01,\n  AfterViewInitHooksToBeRun = 0b10,\n  InitPhaseCompleted = 0b11,\n}\n\n/** More flags associated with an LView (saved in LView[PREORDER_HOOK_FLAGS]) */\nexport const enum PreOrderHookFlags {\n  /**\n     The index of the next pre-order hook to be called in the hooks array, on the first 16\n     bits\n   */\n  IndexOfTheNextPreOrderHookMaskMask = 0b01111111111111111,\n\n  /**\n   * The number of init hooks that have already been called, on the last 16 bits\n   */\n  NumberOfInitHooksCalledIncrementer = 0b010000000000000000,\n  NumberOfInitHooksCalledShift = 16,\n  NumberOfInitHooksCalledMask = 0b11111111111111110000000000000000,\n}\n\n/**\n * Stores a set of OpCodes to process `HostBindingsFunction` associated with a current view.\n *\n * In order to invoke `HostBindingsFunction` we need:\n * 1. 'elementIdx`: Index to the element associated with the `HostBindingsFunction`.\n * 2. 'directiveIdx`: Index to the directive associated with the `HostBindingsFunction`. (This will\n *    become the context for the `HostBindingsFunction` invocation.)\n * 3. `bindingRootIdx`: Location where the bindings for the `HostBindingsFunction` start. Internally\n *    `HostBindingsFunction` binding indexes start from `0` so we need to add `bindingRootIdx` to\n *    it.\n * 4. `HostBindingsFunction`: A host binding function to execute.\n *\n * The above information needs to be encoded into the `HostBindingOpCodes` in an efficient manner.\n *\n * 1. `elementIdx` is encoded into the `HostBindingOpCodes` as `~elementIdx` (so a negative number);\n * 2. `directiveIdx`\n * 3. `bindingRootIdx`\n * 4. `HostBindingsFunction` is passed in as is.\n *\n * The `HostBindingOpCodes` array contains:\n * - negative number to select the element index.\n * - followed by 1 or more of:\n *    - a number to select the directive index\n *    - a number to select the bindingRoot index\n *    - and a function to invoke.\n *\n * ## Example\n *\n * ```\n * const hostBindingOpCodes = [\n *   ~30,                               // Select element 30\n *   40, 45, MyDir.ɵdir.hostBindings    // Invoke host bindings on MyDir on element 30;\n *                                      // directiveIdx = 40; bindingRootIdx = 45;\n *   50, 55, OtherDir.ɵdir.hostBindings // Invoke host bindings on OtherDire on element 30\n *                                      // directiveIdx = 50; bindingRootIdx = 55;\n * ]\n * ```\n *\n * ## Pseudocode\n * ```\n * const hostBindingOpCodes = tView.hostBindingOpCodes;\n * if (hostBindingOpCodes === null) return;\n * for (let i = 0; i < hostBindingOpCodes.length; i++) {\n *   const opCode = hostBindingOpCodes[i] as number;\n *   if (opCode < 0) {\n *     // Negative numbers are element indexes.\n *     setSelectedIndex(~opCode);\n *   } else {\n *     // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n *     const directiveIdx = opCode;\n *     const bindingRootIndx = hostBindingOpCodes[++i] as number;\n *     const hostBindingFn = hostBindingOpCodes[++i] as HostBindingsFunction<any>;\n *     setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n *     const context = lView[directiveIdx];\n *     hostBindingFn(RenderFlags.Update, context);\n *   }\n * }\n * ```\n *\n */\nexport interface HostBindingOpCodes extends Array<number|HostBindingsFunction<any>> {\n  __brand__: 'HostBindingOpCodes';\n  debug?: string[];\n}\n\n/**\n * Explicitly marks `TView` as a specific type in `ngDevMode`\n *\n * It is useful to know conceptually what time of `TView` we are dealing with when\n * debugging an application (even if the runtime does not need it.) For this reason\n * we store this information in the `ngDevMode` `TView` and than use it for\n * better debugging experience.\n */\nexport const enum TViewType {\n  /**\n   * Root `TView` is the used to bootstrap components into. It is used in conjunction with\n   * `LView` which takes an existing DOM node not owned by Angular and wraps it in `TView`/`LView`\n   * so that other components can be loaded into it.\n   */\n  Root = 0,\n\n  /**\n   * `TView` associated with a Component. This would be the `TView` directly associated with the\n   * component view (as opposed an `Embedded` `TView` which would be a child of `Component` `TView`)\n   */\n  Component = 1,\n\n  /**\n   * `TView` associated with a template. Such as `*ngIf`, `<ng-template>` etc... A `Component`\n   * can have zero or more `Embedede` `TView`s.\n   */\n  Embedded = 2,\n}\n\n/**\n * Converts `TViewType` into human readable text.\n * Make sure this matches with `TViewType`\n */\nexport const TViewTypeAsString = [\n  'Root',       // 0\n  'Component',  // 1\n  'Embedded',   // 2\n] as const;\n\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the `ComponentDef.tView`.\n */\nexport interface TView {\n  /**\n   * Type of `TView` (`Root`|`Component`|`Embedded`).\n   */\n  type: TViewType;\n\n  /**\n   * This is a blueprint used to generate LView instances for this TView. Copying this\n   * blueprint is faster than creating a new LView from scratch.\n   */\n  blueprint: LView;\n\n  /**\n   * The template function used to refresh the view of dynamically created views\n   * and components. Will be null for inline views.\n   */\n  template: ComponentTemplate<{}>|null;\n\n  /**\n   * A function containing query-related instructions.\n   */\n  viewQuery: ViewQueriesFunction<{}>|null;\n\n  /**\n   * A `TNode` representing the declaration location of this `TView` (not part of this TView).\n   */\n  declTNode: TNode|null;\n\n  // FIXME(misko): Why does `TView` not have `declarationTView` property?\n\n  /** Whether or not this template has been processed in creation mode. */\n  firstCreatePass: boolean;\n\n  /**\n   *  Whether or not this template has been processed in update mode (e.g. change detected)\n   *\n   * `firstUpdatePass` is used by styling to set up `TData` to contain metadata about the styling\n   * instructions. (Mainly to build up a linked list of styling priority order.)\n   *\n   * Typically this function gets cleared after first execution. If exception is thrown then this\n   * flag can remain turned un until there is first successful (no exception) pass. This means that\n   * individual styling instructions keep track of if they have already been added to the linked\n   * list to prevent double adding.\n   */\n  firstUpdatePass: boolean;\n\n  /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n  data: TData;\n\n  /**\n   * The binding start index is the index at which the data array\n   * starts to store bindings only. Saving this value ensures that we\n   * will begin reading bindings at the correct point in the array when\n   * we are in update mode.\n   *\n   * -1 means that it has not been initialized.\n   */\n  bindingStartIndex: number;\n\n  /**\n   * The index where the \"expando\" section of `LView` begins. The expando\n   * section contains injectors, directive instances, and host binding values.\n   * Unlike the \"decls\" and \"vars\" sections of `LView`, the length of this\n   * section cannot be calculated at compile-time because directives are matched\n   * at runtime to preserve locality.\n   *\n   * We store this start index so we know where to start checking host bindings\n   * in `setHostBindings`.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * Whether or not there are any static view queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a view query\n   * refresh after creation mode to collect static query results.\n   */\n  staticViewQueries: boolean;\n\n  /**\n   * Whether or not there are any static content queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a content query\n   * refresh after creation mode to collect static query results.\n   */\n  staticContentQueries: boolean;\n\n  /**\n   * A reference to the first child node located in the view.\n   */\n  firstChild: TNode|null;\n\n  /**\n   * Stores the OpCodes to be replayed during change-detection to process the `HostBindings`\n   *\n   * See `HostBindingOpCodes` for encoding details.\n   */\n  hostBindingOpCodes: HostBindingOpCodes|null;\n\n  /**\n   * Full registry of directives and components that may be found in this view.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  directiveRegistry: DirectiveDefList|null;\n\n  /**\n   * Full registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  pipeRegistry: PipeDefList|null;\n\n  /**\n   * Array of ngOnInit, ngOnChanges and ngDoCheck hooks that should be executed for this view in\n   * creation mode.\n   *\n   * This array has a flat structure and contains TNode indices, directive indices (where an\n   * instance can be found in `LView`) and hook functions. TNode index is followed by the directive\n   * index and a hook function. If there are multiple hooks for a given TNode, the TNode index is\n   * not repeated and the next lifecycle hook information is stored right after the previous hook\n   * function. This is done so that at runtime the system can efficiently iterate over all of the\n   * functions to invoke without having to make any decisions/lookups.\n   */\n  preOrderHooks: HookData|null;\n\n  /**\n   * Array of ngOnChanges and ngDoCheck hooks that should be executed for this view in update mode.\n   *\n   * This array has the same structure as the `preOrderHooks` one.\n   */\n  preOrderCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n   * for this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentChecked hooks that should be executed for this view in update\n   * mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n   * this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewChecked hooks that should be executed for this view in\n   * update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewCheckHooks: HookData|null;\n\n  /**\n   * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  destroyHooks: DestroyHookData|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n   * and output data (in chunks of 2) for a particular view. Combining the arrays\n   * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n   * separate for loops).\n   *\n   * If it's a native DOM listener or output subscription being stored:\n   * 1st index is: event name  `name = tView.cleanup[i+0]`\n   * 2nd index is: index of native element or a function that retrieves global target (window,\n   *               document or body) reference based on the native element:\n   *    `typeof idxOrTargetGetter === 'function'`: global target getter function\n   *    `typeof idxOrTargetGetter === 'number'`: index of native element\n   *\n   * 3rd index is: index of listener function `listener = lView[CLEANUP][tView.cleanup[i+2]]`\n   * 4th index is: `useCaptureOrIndx = tView.cleanup[i+3]`\n   *    `typeof useCaptureOrIndx == 'boolean' : useCapture boolean\n   *    `typeof useCaptureOrIndx == 'number':\n   *         `useCaptureOrIndx >= 0` `removeListener = LView[CLEANUP][useCaptureOrIndx]`\n   *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n   *\n   * If it's an output subscription or query list destroy hook:\n   * 1st index is: output unsubscribe function / query list destroy function\n   * 2nd index is: index of function context in LView.cleanupInstances[]\n   *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n   */\n  cleanup: any[]|null;\n\n  /**\n   * A list of element indices for child components that will need to be\n   * refreshed when the current view has finished its check. These indices have\n   * already been adjusted for the HEADER_OFFSET.\n   *\n   */\n  components: number[]|null;\n\n  /**\n   * A collection of queries tracked in a given view.\n   */\n  queries: TQueries|null;\n\n  /**\n   * An array of indices pointing to directives with content queries alongside with the\n   * corresponding query index. Each entry in this array is a tuple of:\n   * - index of the first content query index declared by a given directive;\n   * - index of a directive.\n   *\n   * We are storing those indexes so we can refresh content queries as part of a view refresh\n   * process.\n   */\n  contentQueries: number[]|null;\n\n  /**\n   * Set of schemas that declare elements to be allowed inside the view.\n   */\n  schemas: SchemaMetadata[]|null;\n\n  /**\n   * Array of constants for the view. Includes attribute arrays, local definition arrays etc.\n   * Used for directive matching, attribute bindings, local definitions and more.\n   */\n  consts: TConstants|null;\n\n  /**\n   * Indicates that there was an error before we managed to complete the first create pass of the\n   * view. This means that the view is likely corrupted and we should try to recover it.\n   */\n  incompleteFirstPass: boolean;\n}\n\nexport const enum RootContextFlags {\n  Empty = 0b00,\n  DetectChanges = 0b01,\n  FlushPlayers = 0b10\n}\n\n\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext {\n  /**\n   * A function used for scheduling change detection in the future. Usually\n   * this is `requestAnimationFrame`.\n   */\n  scheduler: (workFn: () => void) => void;\n\n  /**\n   * A promise which is resolved when all components are considered clean (not dirty).\n   *\n   * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n   */\n  clean: Promise<null>;\n\n  /**\n   * RootComponents - The components that were instantiated by the call to\n   * {@link renderComponent}.\n   */\n  components: {}[];\n\n  /**\n   * The player flushing handler to kick off all animations\n   */\n  playerHandler: PlayerHandler|null;\n\n  /**\n   * What render-related operations to run once a scheduler has been set\n   */\n  flags: RootContextFlags;\n}\n\n/** Single hook callback function. */\nexport type HookFn = () => void;\n\n/**\n * Information necessary to call a hook. E.g. the callback that\n * needs to invoked and the index at which to find its context.\n */\nexport type HookEntry = number|HookFn;\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * For each node of the view, the following data is stored:\n * 1) Node index (optional)\n * 2) A series of number/function pairs where:\n *  - even indices are directive indices\n *  - odd indices are hook functions\n *\n * Special cases:\n *  - a negative directive index flags an init hook (ngOnInit, ngAfterContentInit, ngAfterViewInit)\n */\nexport type HookData = HookEntry[];\n\n/**\n * Array of destroy hooks that should be executed for a view and their directive indices.\n *\n * The array is set up as a series of number/function or number/(number|function)[]:\n * - Even indices represent the context with which hooks should be called.\n * - Odd indices are the hook functions themselves. If a value at an odd index is an array,\n *   it represents the destroy hooks of a `multi` provider where:\n *     - Even indices represent the index of the provider for which we've registered a destroy hook,\n *       inside of the `multi` provider array.\n *     - Odd indices are the destroy hook functions.\n * For example:\n * LView: `[0, 1, 2, AService, 4, [BService, CService, DService]]`\n * destroyHooks: `[3, AService.ngOnDestroy, 5, [0, BService.ngOnDestroy, 2, DService.ngOnDestroy]]`\n *\n * In the example above `AService` is a type provider with an `ngOnDestroy`, whereas `BService`,\n * `CService` and `DService` are part of a `multi` provider where only `BService` and `DService`\n * have an `ngOnDestroy` hook.\n */\nexport type DestroyHookData = (HookEntry|HookData)[];\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Each host property's name is stored here at the same index as its value in the\n * data array.\n *\n * Each property binding name is stored here at the same index as its value in\n * the data array. If the binding is an interpolation, the static string values\n * are stored parallel to the dynamic values. Example:\n *\n * id=\"prefix {{ v0 }} a {{ v1 }} b {{ v2 }} suffix\"\n *\n * LView       |   TView.data\n *------------------------\n *  v0 value   |   'a'\n *  v1 value   |   'b'\n *  v2 value   |   id � prefix � suffix\n *\n * Injector bloom filters are also stored here.\n */\nexport type TData =\n    (TNode|PipeDef<any>|DirectiveDef<any>|ComponentDef<any>|number|TStylingRange|TStylingKey|\n     Type<any>|InjectionToken<any>|TI18n|I18nUpdateOpCodes|TIcu|null|string)[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Human readable version of the `LView`.\n *\n * `LView` is a data structure used internally to keep track of views. The `LView` is designed for\n * efficiency and so at times it is difficult to read or write tests which assert on its values. For\n * this reason when `ngDevMode` is true we patch a `LView.debug` property which points to\n * `LViewDebug` for easier debugging and test writing. It is the intent of `LViewDebug` to be used\n * in tests.\n */\nexport interface LViewDebug {\n  /**\n   * Flags associated with the `LView` unpacked into a more readable state.\n   *\n   * See `LViewFlags` for the flag meanings.\n   */\n  readonly flags: {\n    initPhaseState: number,\n    creationMode: boolean,\n    firstViewPass: boolean,\n    checkAlways: boolean,\n    dirty: boolean,\n    attached: boolean,\n    destroyed: boolean,\n    isRoot: boolean,\n    indexWithinInitPhase: number,\n  };\n\n  /**\n   * Associated TView\n   */\n  readonly tView: TView;\n\n  /**\n   * Parent view (or container)\n   */\n  readonly parent: LViewDebug|LContainerDebug|null;\n\n  /**\n   * Next sibling to the `LView`.\n   */\n  readonly next: LViewDebug|LContainerDebug|null;\n\n  /**\n   * The context used for evaluation of the `LView`\n   *\n   * (Usually the component)\n   */\n  readonly context: {}|null;\n\n  /**\n   * Hierarchical tree of nodes.\n   */\n  readonly nodes: DebugNode[];\n\n  /**\n   * Template structure (no instance data).\n   * (Shows how TNodes are connected)\n   */\n  readonly template: string;\n\n  /**\n   * HTML representation of the `LView`.\n   *\n   * This is only approximate to actual HTML as child `LView`s are removed.\n   */\n  readonly html: string;\n\n  /**\n   * The host element to which this `LView` is attached.\n   */\n  readonly hostHTML: string|null;\n\n  /**\n   * Child `LView`s\n   */\n  readonly childViews: Array<LViewDebug|LContainerDebug>;\n\n  /**\n   * Sub range of `LView` containing decls (DOM elements).\n   */\n  readonly decls: LViewDebugRange;\n\n  /**\n   * Sub range of `LView` containing vars (bindings).\n   */\n  readonly vars: LViewDebugRange;\n\n  /**\n   * Sub range of `LView` containing expando (used by DI).\n   */\n  readonly expando: LViewDebugRange;\n}\n\n/**\n * Human readable version of the `LContainer`\n *\n * `LContainer` is a data structure used internally to keep track of child views. The `LContainer`\n * is designed for efficiency and so at times it is difficult to read or write tests which assert on\n * its values. For this reason when `ngDevMode` is true we patch a `LContainer.debug` property which\n * points to `LContainerDebug` for easier debugging and test writing. It is the intent of\n * `LContainerDebug` to be used in tests.\n */\nexport interface LContainerDebug {\n  readonly native: RComment;\n  /**\n   * Child `LView`s.\n   */\n  readonly views: LViewDebug[];\n  readonly parent: LViewDebug|null;\n  readonly movedViews: LView[]|null;\n  readonly host: RElement|RComment|LView;\n  readonly next: LViewDebug|LContainerDebug|null;\n  readonly hasTransplantedViews: boolean;\n}\n\n\n\n/**\n * `LView` is subdivided to ranges where the actual data is stored. Some of these ranges such as\n * `decls` and `vars` are known at compile time. Other such as `i18n` and `expando` are runtime only\n * concepts.\n */\nexport interface LViewDebugRange {\n  /**\n   * The starting index in `LView` where the range begins. (Inclusive)\n   */\n  start: number;\n\n  /**\n   * The ending index in `LView` where the range ends. (Exclusive)\n   */\n  end: number;\n\n  /**\n   * The length of the range\n   */\n  length: number;\n\n  /**\n   * The merged content of the range. `t` contains data from `TView.data` and `l` contains `LView`\n   * data at an index.\n   */\n  content: LViewDebugRangeContent[];\n}\n\n/**\n * For convenience the static and instance portions of `TView` and `LView` are merged into a single\n * object in `LViewRange`.\n */\nexport interface LViewDebugRangeContent {\n  /**\n   * Index into original `LView` or `TView.data`.\n   */\n  index: number;\n\n  /**\n   * Value from the `TView.data[index]` location.\n   */\n  t: any;\n\n  /**\n   * Value from the `LView[index]` location.\n   */\n  l: any;\n}\n\n\n/**\n * A logical node which comprise into `LView`s.\n *\n */\nexport interface DebugNode {\n  /**\n   * HTML representation of the node.\n   */\n  html: string|null;\n\n  /**\n   * Human readable node type.\n   */\n  type: string;\n\n  /**\n   * DOM native node.\n   */\n  native: Node;\n\n  /**\n   * Child nodes\n   */\n  children: DebugNode[];\n\n  /**\n   * A list of Component/Directive types which need to be instantiated an this location.\n   */\n  factories: Type<unknown>[];\n\n  /**\n   * A list of Component/Directive instances which were instantiated an this location.\n   */\n  instances: unknown[];\n\n  /**\n   * NodeInjector information.\n   */\n  injector: NodeInjectorDebug;\n}\n\nexport interface NodeInjectorDebug {\n  /**\n   * Instance bloom. Does the current injector have a provider with a given bloom mask.\n   */\n  bloom: string;\n\n\n  /**\n   * Cumulative bloom. Do any of the above injectors have a provider with a given bloom mask.\n   */\n  cumulativeBloom: string;\n\n  /**\n   * A list of providers associated with this injector.\n   */\n  providers: (Type<unknown>|DirectiveDef<unknown>|ComponentDef<unknown>)[];\n\n  /**\n   * A list of providers associated with this injector visible to the view of the component only.\n   */\n  viewProviders: Type<unknown>[];\n\n\n  /**\n   * Location of the parent `TNode`.\n   */\n  parentInjectorIndex: number;\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectFlags} from '../di/interface/injector';\nimport {assertDefined, assertEqual, assertGreaterThanOrEqual, assertLessThan, assertNotEqual} from '../util/assert';\nimport {assertLViewOrUndefined, assertTNodeForLView, assertTNodeForTView} from './assert';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode, TNodeType} from './interfaces/node';\nimport {CONTEXT, DECLARATION_VIEW, HEADER_OFFSET, LView, OpaqueViewState, T_HOST, TData, TVIEW, TView, TViewType} from './interfaces/view';\nimport {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\nimport {getTNode} from './util/view_utils';\n\n\n/**\n *\n */\ninterface LFrame {\n  /**\n   * Parent LFrame.\n   *\n   * This is needed when `leaveView` is called to restore the previous state.\n   */\n  parent: LFrame;\n\n  /**\n   * Child LFrame.\n   *\n   * This is used to cache existing LFrames to relieve the memory pressure.\n   */\n  child: LFrame|null;\n\n  /**\n   * State of the current view being processed.\n   *\n   * An array of nodes (text, element, container, etc), pipes, their bindings, and\n   * any local variables that need to be stored between invocations.\n   */\n  lView: LView;\n\n  /**\n   * Current `TView` associated with the `LFrame.lView`.\n   *\n   * One can get `TView` from `lFrame[TVIEW]` however because it is so common it makes sense to\n   * store it in `LFrame` for perf reasons.\n   */\n  tView: TView;\n\n  /**\n   * Used to set the parent property when nodes are created and track query results.\n   *\n   * This is used in conjunction with `isParent`.\n   */\n  currentTNode: TNode|null;\n\n  /**\n   * If `isParent` is:\n   *  - `true`: then `currentTNode` points to a parent node.\n   *  - `false`: then `currentTNode` points to previous node (sibling).\n   */\n  isParent: boolean;\n\n  /**\n   * Index of currently selected element in LView.\n   *\n   * Used by binding instructions. Updated as part of advance instruction.\n   */\n  selectedIndex: number;\n\n  /**\n   * Current pointer to the binding index.\n   */\n  bindingIndex: number;\n\n  /**\n   * The last viewData retrieved by nextContext().\n   * Allows building nextContext() and reference() calls.\n   *\n   * e.g. const inner = x().$implicit; const outer = x().$implicit;\n   */\n  contextLView: LView;\n\n  /**\n   * Store the element depth count. This is used to identify the root elements of the template\n   * so that we can then attach patch data `LView` to only those elements. We know that those\n   * are the only places where the patch data could change, this way we will save on number\n   * of places where tha patching occurs.\n   */\n  elementDepthCount: number;\n\n  /**\n   * Current namespace to be used when creating elements\n   */\n  currentNamespace: string|null;\n\n\n  /**\n   * The root index from which pure function instructions should calculate their binding\n   * indices. In component views, this is TView.bindingStartIndex. In a host binding\n   * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n   */\n  bindingRootIndex: number;\n\n  /**\n   * Current index of a View or Content Query which needs to be processed next.\n   * We iterate over the list of Queries and increment current query index at every step.\n   */\n  currentQueryIndex: number;\n\n  /**\n   * When host binding is executing this points to the directive index.\n   * `TView.data[currentDirectiveIndex]` is `DirectiveDef`\n   * `LView[currentDirectiveIndex]` is directive instance.\n   */\n  currentDirectiveIndex: number;\n\n  /**\n   * Are we currently in i18n block as denoted by `ɵɵelementStart` and `ɵɵelementEnd`.\n   *\n   * This information is needed because while we are in i18n block all elements must be pre-declared\n   * in the translation. (i.e. `Hello �#2�World�/#2�!` pre-declares element at `�#2�` location.)\n   * This allocates `TNodeType.Placeholder` element at location `2`. If translator removes `�#2�`\n   * from translation than the runtime must also ensure tha element at `2` does not get inserted\n   * into the DOM. The translation does not carry information about deleted elements. Therefor the\n   * only way to know that an element is deleted is that it was not pre-declared in the translation.\n   *\n   * This flag works by ensuring that elements which are created without pre-declaration\n   * (`TNodeType.Placeholder`) are not inserted into the DOM render tree. (It does mean that the\n   * element still gets instantiated along with all of its behavior [directives])\n   */\n  inI18n: boolean;\n}\n\n/**\n * All implicit instruction state is stored here.\n *\n * It is useful to have a single object where all of the state is stored as a mental model\n * (rather it being spread across many different variables.)\n *\n * PERF NOTE: Turns out that writing to a true global variable is slower than\n * having an intermediate object with properties.\n */\ninterface InstructionState {\n  /**\n   * Current `LFrame`\n   *\n   * `null` if we have not called `enterView`\n   */\n  lFrame: LFrame;\n\n  /**\n   * Stores whether directives should be matched to elements.\n   *\n   * When template contains `ngNonBindable` then we need to prevent the runtime from matching\n   * directives on children of that element.\n   *\n   * Example:\n   * ```\n   * <my-comp my-directive>\n   *   Should match component / directive.\n   * </my-comp>\n   * <div ngNonBindable>\n   *   <my-comp my-directive>\n   *     Should not match component / directive because we are in ngNonBindable.\n   *   </my-comp>\n   * </div>\n   * ```\n   */\n  bindingsEnabled: boolean;\n\n  /**\n   * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n   *\n   * Necessary to support ChangeDetectorRef.checkNoChanges().\n   *\n   * checkNoChanges Runs only in devmode=true and verifies that no unintended changes exist in\n   * the change detector or its children.\n   */\n  isInCheckNoChangesMode: boolean;\n}\n\nconst instructionState: InstructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  isInCheckNoChangesMode: false,\n};\n\n/**\n * Returns true if the instruction state stack is empty.\n *\n * Intended to be called from tests only (tree shaken otherwise).\n */\nexport function specOnlyIsInstructionStateEmpty(): boolean {\n  return instructionState.lFrame.parent === null;\n}\n\n\nexport function getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\n\nexport function increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\n\nexport function decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\n\nexport function getBindingsEnabled(): boolean {\n  return instructionState.bindingsEnabled;\n}\n\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵenableBindings(): void {\n  instructionState.bindingsEnabled = true;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ɵɵdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ɵɵenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ɵɵdisableBindings(): void {\n  instructionState.bindingsEnabled = false;\n}\n\n/**\n * Return the current `LView`.\n */\nexport function getLView(): LView {\n  return instructionState.lFrame.lView;\n}\n\n/**\n * Return the current `TView`.\n */\nexport function getTView(): TView {\n  return instructionState.lFrame.tView;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n *\n * @codeGenApi\n */\nexport function ɵɵrestoreView(viewToRestore: OpaqueViewState) {\n  instructionState.lFrame.contextLView = viewToRestore as any as LView;\n}\n\n\nexport function getCurrentTNode(): TNode|null {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n  while (currentTNode !== null && currentTNode.type === TNodeType.Placeholder) {\n    currentTNode = currentTNode.parent;\n  }\n  return currentTNode;\n}\n\nexport function getCurrentTNodePlaceholderOk(): TNode|null {\n  return instructionState.lFrame.currentTNode;\n}\n\nexport function getCurrentParentTNode(): TNode|null {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode!.parent;\n}\n\nexport function setCurrentTNode(tNode: TNode|null, isParent: boolean) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\n\nexport function isCurrentTNodeParent(): boolean {\n  return instructionState.lFrame.isParent;\n}\n\nexport function setCurrentTNodeAsNotParent(): void {\n  instructionState.lFrame.isParent = false;\n}\nexport function setCurrentTNodeAsParent(): void {\n  instructionState.lFrame.isParent = true;\n}\n\nexport function getContextLView(): LView {\n  return instructionState.lFrame.contextLView;\n}\n\nexport function isInCheckNoChangesMode(): boolean {\n  // TODO(misko): remove this from the LView since it is ngDevMode=true mode only.\n  return instructionState.isInCheckNoChangesMode;\n}\n\nexport function setIsInCheckNoChangesMode(mode: boolean): void {\n  instructionState.isInCheckNoChangesMode = mode;\n}\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\n\nexport function getBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex;\n}\n\nexport function setBindingIndex(value: number): number {\n  return instructionState.lFrame.bindingIndex = value;\n}\n\nexport function nextBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex++;\n}\n\nexport function incrementBindingIndex(count: number): number {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\n\nexport function isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\n\nexport function setInI18nBlock(isInI18nBlock: boolean): void {\n  instructionState.lFrame.inI18n = isInI18nBlock;\n}\n\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nexport function setBindingRootForHostBindings(\n    bindingRootIndex: number, currentDirectiveIndex: number) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\n\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nexport function getCurrentDirectiveIndex(): number {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\n\n/**\n * Sets an index of a directive whose `hostBindings` are being processed.\n *\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\n */\nexport function setCurrentDirectiveIndex(currentDirectiveIndex: number): void {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n\n/**\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\n * executed.\n *\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\n */\nexport function getCurrentDirectiveDef(tData: TData): DirectiveDef<any>|null {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex] as DirectiveDef<any>;\n}\n\nexport function getCurrentQueryIndex(): number {\n  return instructionState.lFrame.currentQueryIndex;\n}\n\nexport function setCurrentQueryIndex(value: number): void {\n  instructionState.lFrame.currentQueryIndex = value;\n}\n\n/**\n * Returns a `TNode` of the location where the current `LView` is declared at.\n *\n * @param lView an `LView` that we want to find parent `TNode` for.\n */\nfunction getDeclarationTNode(lView: LView): TNode|null {\n  const tView = lView[TVIEW];\n\n  // Return the declaration parent for embedded views\n  if (tView.type === TViewType.Embedded) {\n    ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n    return tView.declTNode;\n  }\n\n  // Components don't have `TView.declTNode` because each instance of component could be\n  // inserted in different location, hence `TView.declTNode` is meaningless.\n  // Falling back to `T_HOST` in case we cross component boundary.\n  if (tView.type === TViewType.Component) {\n    return lView[T_HOST];\n  }\n\n  // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\n  return null;\n}\n\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n *\n * @param lView `LView` location of the DI context.\n * @param tNode `TNode` for DI context\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\n *     tree from `tNode`  until we find parent declared `TElementNode`.\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\n *     - If `true` than this call must be fallowed by `leaveDI`\n *     - If `false` than this call failed and we should NOT call `leaveDI`\n */\nexport function enterDI(lView: LView, tNode: TNode, flags: InjectFlags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n\n  if (flags & InjectFlags.SkipSelf) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n\n    let parentTNode = tNode as TNode | null;\n    let parentLView = lView;\n\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\n      parentTNode = parentTNode!.parent as TNode | null;\n      if (parentTNode === null && !(flags & InjectFlags.Host)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break;\n\n        // In this case, a parent exists and is definitely an element. So it will definitely\n        // have an existing lView as the declaration view, which is why we can assume it's defined.\n        ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\n        parentLView = parentLView[DECLARATION_VIEW]!;\n\n        // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\n        // We want to skip those and look only at Elements and ElementContainers to ensure\n        // we're looking at true parent nodes, and not content or other types.\n        if (parentTNode.type & (TNodeType.Element | TNodeType.ElementContainer)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (parentTNode === null) {\n      // If we failed to find a parent TNode this means that we should use module injector.\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = instructionState.lFrame = allocLFrame();\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n\n  return true;\n}\n\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @returns the previously active lView;\n */\nexport function enterView(newView: LView): void {\n  ngDevMode && assertNotEqual(newView[0], newView[1] as any, '????');\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\n    assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\n    assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\n    assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\n  }\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild!;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView!;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\n\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\n\nfunction createLFrame(parent: LFrame|null): LFrame {\n  const lFrame: LFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null!,\n    tView: null!,\n    selectedIndex: -1,\n    contextLView: null!,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent: parent!,\n    child: null,\n    inI18n: false,\n  };\n  parent !== null && (parent.child = lFrame);  // link the new LFrame for reuse.\n  return lFrame;\n}\n\n/**\n * A lightweight version of leave which is used with DI.\n *\n * This function only resets `currentTNode` and `LView` as those are the only properties\n * used with DI (`enterDI()`).\n *\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\n */\nfunction leaveViewLight(): LFrame {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null!;\n  oldLFrame.lView = null!;\n  return oldLFrame;\n}\n\n/**\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\n *\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\n * return type.\n */\nexport const leaveDI: () => void = leaveViewLight;\n\n/**\n * Leave the current `LView`\n *\n * This pops the `LFrame` with the associated `LView` from the stack.\n *\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\n */\nexport function leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null!;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null!;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\n\nexport function nextContextImpl<T = any>(level: number): T {\n  const contextLView = instructionState.lFrame.contextLView =\n      walkUpViews(level, instructionState.lFrame.contextLView!);\n  return contextLView[CONTEXT] as T;\n}\n\nfunction walkUpViews(nestingLevel: number, currentView: LView): LView {\n  while (nestingLevel > 0) {\n    ngDevMode &&\n        assertDefined(\n            currentView[DECLARATION_VIEW],\n            'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW]!;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nexport function getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\n\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nexport function setSelectedIndex(index: number) {\n  ngDevMode && index !== -1 &&\n      assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\n  ngDevMode &&\n      assertLessThan(\n          index, instructionState.lFrame.lView.length, 'Can\\'t set index passed end of LView');\n  instructionState.lFrame.selectedIndex = index;\n}\n\n/**\n * Gets the `tNode` that represents currently selected element.\n */\nexport function getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nexport function ɵɵnamespaceHTML() {\n  namespaceHTMLInternal();\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nexport function namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\n\nexport function getNamespace(): string|null {\n  return instructionState.lFrame.currentNamespace;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, DoCheck, OnChanges, OnDestroy, OnInit} from '../interface/lifecycle_hooks';\nimport {assertDefined, assertEqual, assertNotEqual} from '../util/assert';\nimport {assertFirstCreatePass} from './assert';\nimport {NgOnChangesFeatureImpl} from './features/ng_onchanges_feature';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode} from './interfaces/node';\nimport {FLAGS, HookData, InitPhaseState, LView, LViewFlags, PREORDER_HOOK_FLAGS, PreOrderHookFlags, TView} from './interfaces/view';\nimport {isInCheckNoChangesMode} from './state';\n\n\n\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nexport function registerPreOrderHooks(\n    directiveIndex: number, directiveDef: DirectiveDef<any>, tView: TView): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  const {ngOnChanges, ngOnInit, ngDoCheck} =\n      directiveDef.type.prototype as OnChanges & OnInit & DoCheck;\n\n  if (ngOnChanges as Function | undefined) {\n    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges);\n    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = []))\n        .push(directiveIndex, wrappedOnChanges);\n  }\n\n  if (ngOnInit) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit);\n  }\n\n  if (ngDoCheck) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck);\n    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck);\n  }\n}\n\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nexport function registerPostOrderHooks(tView: TView, tNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  // It's necessary to loop through the directives at elementEnd() (rather than processing in\n  // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n  // hooks for projected components and directives must be called *before* their hosts.\n  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n    const directiveDef = tView.data[i] as DirectiveDef<any>;\n    ngDevMode && assertDefined(directiveDef, 'Expecting DirectiveDef');\n    const lifecycleHooks: AfterContentInit&AfterContentChecked&AfterViewInit&AfterViewChecked&\n        OnDestroy = directiveDef.type.prototype;\n    const {\n      ngAfterContentInit,\n      ngAfterContentChecked,\n      ngAfterViewInit,\n      ngAfterViewChecked,\n      ngOnDestroy\n    } = lifecycleHooks;\n\n    if (ngAfterContentInit) {\n      (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit);\n    }\n\n    if (ngAfterContentChecked) {\n      (tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked);\n      (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked);\n    }\n\n    if (ngAfterViewInit) {\n      (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit);\n    }\n\n    if (ngAfterViewChecked) {\n      (tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked);\n      (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked);\n    }\n\n    if (ngOnDestroy != null) {\n      (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy);\n    }\n  }\n}\n\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n\n\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nexport function executeCheckHooks(lView: LView, hooks: HookData, nodeIndex?: number|null) {\n  callHooks(lView, hooks, InitPhaseState.InitPhaseCompleted, nodeIndex);\n}\n\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nexport function executeInitAndCheckHooks(\n    lView: LView, hooks: HookData, initPhase: InitPhaseState, nodeIndex?: number|null) {\n  ngDevMode &&\n      assertNotEqual(\n          initPhase, InitPhaseState.InitPhaseCompleted,\n          'Init pre-order hooks should not be called more than once');\n  if ((lView[FLAGS] & LViewFlags.InitPhaseStateMask) === initPhase) {\n    callHooks(lView, hooks, initPhase, nodeIndex);\n  }\n}\n\nexport function incrementInitPhaseFlags(lView: LView, initPhase: InitPhaseState): void {\n  ngDevMode &&\n      assertNotEqual(\n          initPhase, InitPhaseState.InitPhaseCompleted,\n          'Init hooks phase should not be incremented after all init hooks have been run.');\n  let flags = lView[FLAGS];\n  if ((flags & LViewFlags.InitPhaseStateMask) === initPhase) {\n    flags &= LViewFlags.IndexWithinInitPhaseReset;\n    flags += LViewFlags.InitPhaseStateIncrementer;\n    lView[FLAGS] = flags;\n  }\n}\n\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(\n    currentView: LView, arr: HookData, initPhase: InitPhaseState,\n    currentNodeIndex: number|null|undefined): void {\n  ngDevMode &&\n      assertEqual(\n          isInCheckNoChangesMode(), false,\n          'Hooks should never be run when in check no changes mode.');\n  const startIndex = currentNodeIndex !== undefined ?\n      (currentView[PREORDER_HOOK_FLAGS] & PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask) :\n      0;\n  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n  let lastNodeIndexFound = 0;\n  for (let i = startIndex; i < arr.length; i++) {\n    const hook = arr[i + 1] as () => void;\n    if (typeof hook === 'number') {\n      lastNodeIndexFound = arr[i] as number;\n      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n        break;\n      }\n    } else {\n      const isInitHook = arr[i] < 0;\n      if (isInitHook)\n        currentView[PREORDER_HOOK_FLAGS] += PreOrderHookFlags.NumberOfInitHooksCalledIncrementer;\n      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n        callHook(currentView, initPhase, arr, i);\n        currentView[PREORDER_HOOK_FLAGS] =\n            (currentView[PREORDER_HOOK_FLAGS] & PreOrderHookFlags.NumberOfInitHooksCalledMask) + i +\n            2;\n      }\n      i++;\n    }\n  }\n}\n\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView: LView, initPhase: InitPhaseState, arr: HookData, i: number) {\n  const isInitHook = arr[i] < 0;\n  const hook = arr[i + 1] as () => void;\n  const directiveIndex = isInitHook ? -arr[i] : arr[i] as number;\n  const directive = currentView[directiveIndex];\n  if (isInitHook) {\n    const indexWithintInitPhase = currentView[FLAGS] >> LViewFlags.IndexWithinInitPhaseShift;\n    // The init phase state must be always checked here as it may have been recursively\n    // updated\n    if (indexWithintInitPhase <\n            (currentView[PREORDER_HOOK_FLAGS] >> PreOrderHookFlags.NumberOfInitHooksCalledShift) &&\n        (currentView[FLAGS] & LViewFlags.InitPhaseStateMask) === initPhase) {\n      currentView[FLAGS] += LViewFlags.IndexWithinInitPhaseIncrementer;\n      hook.call(directive);\n    }\n  } else {\n    hook.call(directive);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {InjectFlags} from '../../di/interface/injector';\nimport {AbstractType, Type} from '../../interface/type';\nimport {assertDefined, assertEqual} from '../../util/assert';\n\nimport {TDirectiveHostNode} from './node';\nimport {LView, TData} from './view';\n\n/**\n * Offsets of the `NodeInjector` data structure in the expando.\n *\n * `NodeInjector` is stored in both `LView` as well as `TView.data`. All storage requires 9 words.\n * First 8 are reserved for bloom filter and the 9th is reserved for the associated `TNode` as well\n * as parent `NodeInjector` pointer. All indexes are starting with `index` and have an offset as\n * shown.\n *\n * `LView` layout:\n * ```\n * index + 0: cumulative bloom filter\n * index + 1: cumulative bloom filter\n * index + 2: cumulative bloom filter\n * index + 3: cumulative bloom filter\n * index + 4: cumulative bloom filter\n * index + 5: cumulative bloom filter\n * index + 6: cumulative bloom filter\n * index + 7: cumulative bloom filter\n * index + 8: cumulative bloom filter\n * index + PARENT: Index to the parent injector. See `RelativeInjectorLocation`\n *                 `const parent = lView[index + NodeInjectorOffset.PARENT]`\n * ```\n *\n * `TViewData` layout:\n * ```\n * index + 0: cumulative bloom filter\n * index + 1: cumulative bloom filter\n * index + 2: cumulative bloom filter\n * index + 3: cumulative bloom filter\n * index + 4: cumulative bloom filter\n * index + 5: cumulative bloom filter\n * index + 6: cumulative bloom filter\n * index + 7: cumulative bloom filter\n * index + 8: cumulative bloom filter\n * index + TNODE: TNode associated with this `NodeInjector`\n *                `canst tNode = tView.data[index + NodeInjectorOffset.TNODE]`\n * ```\n */\nexport const enum NodeInjectorOffset {\n  TNODE = 8,\n  PARENT = 8,\n  BLOOM_SIZE = 8,\n  SIZE = 9,\n}\n\n/**\n * Represents a relative location of parent injector.\n *\n * The interfaces encodes number of parents `LView`s to traverse and index in the `LView`\n * pointing to the parent injector.\n */\nexport interface RelativeInjectorLocation {\n  __brand__: 'RelativeInjectorLocationFlags';\n}\n\nexport const enum RelativeInjectorLocationFlags {\n  InjectorIndexMask = 0b111111111111111,\n  ViewOffsetShift = 16,\n  NO_PARENT = -1,\n}\n\nexport const NO_PARENT_INJECTOR: RelativeInjectorLocation = -1 as any;\n\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n\n/**\n * Factory for creating instances of injectors in the NodeInjector.\n *\n * This factory is complicated by the fact that it can resolve `multi` factories as well.\n *\n * NOTE: Some of the fields are optional which means that this class has two hidden classes.\n * - One without `multi` support (most common)\n * - One with `multi` values, (rare).\n *\n * Since VMs can cache up to 4 inline hidden classes this is OK.\n *\n * - Single factory: Only `resolving` and `factory` is defined.\n * - `providers` factory: `componentProviders` is a number and `index = -1`.\n * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n */\nexport class NodeInjectorFactory {\n  /**\n   * The inject implementation to be activated when using the factory.\n   */\n  injectImpl: null|\n      (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T);\n\n  /**\n   * Marker set to true during factory invocation to see if we get into recursive loop.\n   * Recursive loop causes an error to be displayed.\n   */\n  resolving = false;\n\n  /**\n   * Marks that the token can see other Tokens declared in `viewProviders` on the same node.\n   */\n  canSeeViewProviders: boolean;\n\n  /**\n   * An array of factories to use in case of `multi` provider.\n   */\n  multi?: Array<() => any>;\n\n  /**\n   * Number of `multi`-providers which belong to the component.\n   *\n   * This is needed because when multiple components and directives declare the `multi` provider\n   * they have to be concatenated in the correct order.\n   *\n   * Example:\n   *\n   * If we have a component and directive active an a single element as declared here\n   * ```\n   * component:\n   *   provides: [ {provide: String, useValue: 'component', multi: true} ],\n   *   viewProvides: [ {provide: String, useValue: 'componentView', multi: true} ],\n   *\n   * directive:\n   *   provides: [ {provide: String, useValue: 'directive', multi: true} ],\n   * ```\n   *\n   * Then the expected results are:\n   *\n   * ```\n   * providers: ['component', 'directive']\n   * viewProviders: ['component', 'componentView', 'directive']\n   * ```\n   *\n   * The way to think about it is that the `viewProviders` have been inserted after the component\n   * but before the directives, which is why we need to know how many `multi`s have been declared by\n   * the component.\n   */\n  componentProviders?: number;\n\n  /**\n   * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.\n   * See `providerFactory`.\n   */\n  index?: number;\n\n  /**\n   * Because the same `multi` provider can be declared in `provides` and `viewProvides` it is\n   * possible for `viewProvides` to shadow the `provides`. For this reason we store the\n   * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.\n   *\n   * Example:\n   *\n   * Given:\n   * ```\n   * provides: [ {provide: String, useValue: 'all', multi: true} ],\n   * viewProvides: [ {provide: String, useValue: 'viewOnly', multi: true} ],\n   * ```\n   *\n   * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case\n   * of view injection. We further have to make sure that the shared instances (in our case\n   * `all`) are the exact same instance in both the content as well as the view injection. (We\n   * have to make sure that we don't double instantiate.) For this reason the `viewProvides`\n   * `Factory` has a pointer to the shadowed `provides` factory so that it can instantiate the\n   * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =\n   * ['all', 'viewOnly']`).\n   */\n  providerFactory?: NodeInjectorFactory|null;\n\n\n  constructor(\n      /**\n       * Factory to invoke in order to create a new instance.\n       */\n      public factory:\n          (this: NodeInjectorFactory, _: undefined,\n           /**\n            * array where injectables tokens are stored. This is used in\n            * case of an error reporting to produce friendlier errors.\n            */\n           tData: TData,\n           /**\n            * array where existing instances of injectables are stored. This is used in case\n            * of multi shadow is needed. See `multi` field documentation.\n            */\n           lView: LView,\n           /**\n            * The TNode of the same element injector.\n            */\n           tNode: TDirectiveHostNode) => any,\n      /**\n       * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n       */\n      isViewProvider: boolean,\n      injectImplementation: null|\n      (<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags) => T)) {\n    ngDevMode && assertDefined(factory, 'Factory not specified');\n    ngDevMode && assertEqual(typeof factory, 'function', 'Expected factory function.');\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n}\n\nexport function isFactory(obj: any): obj is NodeInjectorFactory {\n  return obj instanceof NodeInjectorFactory;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {CharCode} from '../../util/char_code';\nimport {AttributeMarker, TAttributes} from '../interfaces/node';\nimport {CssSelector} from '../interfaces/projection';\nimport {isProceduralRenderer, ProceduralRenderer3, Renderer3} from '../interfaces/renderer';\nimport {RElement} from '../interfaces/renderer_dom';\n\n\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nexport function setUpAttributes(renderer: Renderer3, native: RElement, attrs: TAttributes): number {\n  const isProc = isProceduralRenderer(renderer);\n\n  let i = 0;\n  while (i < attrs.length) {\n    const value = attrs[i];\n    if (typeof value === 'number') {\n      // only namespaces are supported. Other value types (such as style/class\n      // entries) are not supported in this function.\n      if (value !== AttributeMarker.NamespaceURI) {\n        break;\n      }\n\n      // we just landed on the marker value ... therefore\n      // we should skip to the next entry\n      i++;\n\n      const namespaceURI = attrs[i++] as string;\n      const attrName = attrs[i++] as string;\n      const attrVal = attrs[i++] as string;\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      isProc ?\n          (renderer as ProceduralRenderer3).setAttribute(native, attrName, attrVal, namespaceURI) :\n          native.setAttributeNS(namespaceURI, attrName, attrVal);\n    } else {\n      // attrName is string;\n      const attrName = value as string;\n      const attrVal = attrs[++i];\n      // Standard attributes\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (isAnimationProp(attrName)) {\n        if (isProc) {\n          (renderer as ProceduralRenderer3).setProperty(native, attrName, attrVal);\n        }\n      } else {\n        isProc ?\n            (renderer as ProceduralRenderer3).setAttribute(native, attrName, attrVal as string) :\n            native.setAttribute(attrName, attrVal as string);\n      }\n      i++;\n    }\n  }\n\n  // another piece of code may iterate over the same attributes array. Therefore\n  // it may be helpful to return the exact spot where the attributes array exited\n  // whether by running into an unsupported marker or if all the static values were\n  // iterated over.\n  return i;\n}\n\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nexport function isNameOnlyAttributeMarker(marker: string|AttributeMarker|CssSelector) {\n  return marker === AttributeMarker.Bindings || marker === AttributeMarker.Template ||\n      marker === AttributeMarker.I18n;\n}\n\nexport function isAnimationProp(name: string): boolean {\n  // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n  // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n  // charCodeAt doesn't allocate memory to return a substring.\n  return name.charCodeAt(0) === CharCode.AT_SIGN;\n}\n\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nexport function mergeHostAttrs(dst: TAttributes|null, src: TAttributes|null): TAttributes|null {\n  if (src === null || src.length === 0) {\n    // do nothing\n  } else if (dst === null || dst.length === 0) {\n    // We have source, but dst is empty, just make a copy.\n    dst = src.slice();\n  } else {\n    let srcMarker: AttributeMarker = AttributeMarker.ImplicitAttributes;\n    for (let i = 0; i < src.length; i++) {\n      const item = src[i];\n      if (typeof item === 'number') {\n        srcMarker = item;\n      } else {\n        if (srcMarker === AttributeMarker.NamespaceURI) {\n          // Case where we need to consume `key1`, `key2`, `value` items.\n        } else if (\n            srcMarker === AttributeMarker.ImplicitAttributes ||\n            srcMarker === AttributeMarker.Styles) {\n          // Case where we have to consume `key1` and `value` only.\n          mergeHostAttribute(dst, srcMarker, item as string, null, src[++i] as string);\n        } else {\n          // Case where we have to consume `key1` only.\n          mergeHostAttribute(dst, srcMarker, item as string, null, null);\n        }\n      }\n    }\n  }\n  return dst;\n}\n\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nexport function mergeHostAttribute(\n    dst: TAttributes, marker: AttributeMarker, key1: string, key2: string|null,\n    value: string|null): void {\n  let i = 0;\n  // Assume that new markers will be inserted at the end.\n  let markerInsertPosition = dst.length;\n  // scan until correct type.\n  if (marker === AttributeMarker.ImplicitAttributes) {\n    markerInsertPosition = -1;\n  } else {\n    while (i < dst.length) {\n      const dstValue = dst[i++];\n      if (typeof dstValue === 'number') {\n        if (dstValue === marker) {\n          markerInsertPosition = -1;\n          break;\n        } else if (dstValue > marker) {\n          // We need to save this as we want the markers to be inserted in specific order.\n          markerInsertPosition = i - 1;\n          break;\n        }\n      }\n    }\n  }\n\n  // search until you find place of insertion\n  while (i < dst.length) {\n    const item = dst[i];\n    if (typeof item === 'number') {\n      // since `i` started as the index after the marker, we did not find it if we are at the next\n      // marker\n      break;\n    } else if (item === key1) {\n      // We already have same token\n      if (key2 === null) {\n        if (value !== null) {\n          dst[i + 1] = value;\n        }\n        return;\n      } else if (key2 === dst[i + 1]) {\n        dst[i + 2] = value!;\n        return;\n      }\n    }\n    // Increment counter.\n    i++;\n    if (key2 !== null) i++;\n    if (value !== null) i++;\n  }\n\n  // insert at location.\n  if (markerInsertPosition !== -1) {\n    dst.splice(markerInsertPosition, 0, marker);\n    i = markerInsertPosition + 1;\n  }\n  dst.splice(i++, 0, key1);\n  if (key2 !== null) {\n    dst.splice(i++, 0, key2);\n  }\n  if (value !== null) {\n    dst.splice(i++, 0, value);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertGreaterThan, assertNotEqual, assertNumber} from '../../util/assert';\nimport {NO_PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags} from '../interfaces/injector';\nimport {DECLARATION_VIEW, HEADER_OFFSET, LView} from '../interfaces/view';\n\n\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nexport function hasParentInjector(parentLocation: RelativeInjectorLocation): boolean {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\n\nexport function getParentInjectorIndex(parentLocation: RelativeInjectorLocation): number {\n  ngDevMode && assertNumber(parentLocation, 'Number expected');\n  ngDevMode && assertNotEqual(parentLocation as any, -1, 'Not a valid state.');\n  const parentInjectorIndex =\n      (parentLocation as any as number) & RelativeInjectorLocationFlags.InjectorIndexMask;\n  ngDevMode &&\n      assertGreaterThan(\n          parentInjectorIndex, HEADER_OFFSET,\n          'Parent injector must be pointing past HEADER_OFFSET.');\n  return (parentLocation as any as number) & RelativeInjectorLocationFlags.InjectorIndexMask;\n}\n\nexport function getParentInjectorViewOffset(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) >> RelativeInjectorLocationFlags.ViewOffsetShift;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nexport function getParentInjectorView(location: RelativeInjectorLocation, startView: LView): LView {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW]!;\n    viewOffset--;\n  }\n  return parentView;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isForwardRef, resolveForwardRef} from '../di/forward_ref';\nimport {injectRootLimpMode, setInjectImplementation} from '../di/inject_switch';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {InjectorMarkers} from '../di/injector_marker';\nimport {getInjectorDef} from '../di/interface/defs';\nimport {InjectFlags} from '../di/interface/injector';\nimport {AbstractType, Type} from '../interface/type';\nimport {assertDefined, assertEqual, assertIndexInRange} from '../util/assert';\nimport {noSideEffects} from '../util/closure';\n\nimport {assertDirectiveDef, assertNodeInjector, assertTNodeForLView} from './assert';\nimport {FactoryFn, getFactoryDef} from './definition_factory';\nimport {throwCyclicDependencyError, throwProviderNotFoundError} from './errors_di';\nimport {NG_ELEMENT_ID, NG_FACTORY_DEF} from './fields';\nimport {registerPreOrderHooks} from './hooks';\nimport {DirectiveDef} from './interfaces/definition';\nimport {isFactory, NO_PARENT_INJECTOR, NodeInjectorFactory, NodeInjectorOffset, RelativeInjectorLocation, RelativeInjectorLocationFlags} from './interfaces/injector';\nimport {AttributeMarker, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNode, TNodeProviderIndexes, TNodeType} from './interfaces/node';\nimport {isComponentDef, isComponentHost} from './interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, INJECTOR, LView, T_HOST, TData, TVIEW, TView, TViewType} from './interfaces/view';\nimport {assertTNodeType} from './node_assert';\nimport {enterDI, getCurrentTNode, getLView, leaveDI} from './state';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\nimport {getParentInjectorIndex, getParentInjectorView, hasParentInjector} from './util/injector_utils';\nimport {stringifyForError} from './util/stringify_utils';\n\n\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\n\nexport function setIncludeViewProviders(v: boolean): boolean {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport function bloomAdd(\n    injectorIndex: number, tView: TView, type: Type<any>|InjectionToken<any>|string): void {\n  ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n  let id: number|undefined;\n  if (typeof type === 'string') {\n    id = type.charCodeAt(0) || 0;\n  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n    id = (type as any)[NG_ELEMENT_ID];\n  }\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomBit = id & BLOOM_MASK;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  const b7 = bloomBit & 0x80;\n  const b6 = bloomBit & 0x40;\n  const b5 = bloomBit & 0x20;\n  const tData = tView.data as number[];\n\n  if (b7) {\n    b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\n         (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\n  } else {\n    b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\n         (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\n  }\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param lView View where the node is stored\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n    tNode: TElementNode|TContainerNode|TElementContainerNode, lView: LView): number {\n  const existingInjectorIndex = getInjectorIndex(tNode, lView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = lView[TVIEW];\n  if (tView.firstCreatePass) {\n    tNode.injectorIndex = lView.length;\n    insertBloom(tView.data, tNode);  // foundation for node bloom\n    insertBloom(lView, null);        // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, lView);\n  const injectorIndex = tNode.injectorIndex;\n\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentIndex = getParentInjectorIndex(parentLoc);\n    const parentLView = getParentInjectorView(parentLoc, lView);\n    const parentData = parentLView[TVIEW].data as any;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < NodeInjectorOffset.BLOOM_SIZE; i++) {\n      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n\n  lView[injectorIndex + NodeInjectorOffset.PARENT] = parentLoc;\n  return injectorIndex;\n}\n\nfunction insertBloom(arr: any[], footer: TNode|null): void {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\n\nexport function getInjectorIndex(tNode: TNode, lView: LView): number {\n  if (tNode.injectorIndex === -1 ||\n      // If the injector index is the same as its parent's injector index, then the index has been\n      // copied down from the parent node. No injector has been created yet on this node.\n      (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n      // After the first template pass, the injector index might exist but the parent values\n      // might not have been calculated yet for this instance\n      lView[tNode.injectorIndex + NodeInjectorOffset.PARENT] === null) {\n    return -1;\n  } else {\n    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n    return tNode.injectorIndex;\n  }\n}\n\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * @returns Returns a number that is the combination of the number of LViews that we have to go up\n * to find the LView containing the parent inject AND the index of the injector within that LView.\n */\nexport function getParentInjectorLocation(tNode: TNode, lView: LView): RelativeInjectorLocation {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    // If we have a parent `TNode` and there is an injector associated with it we are done, because\n    // the parent injector is within the current `LView`.\n    return tNode.parent.injectorIndex as any;  // ViewOffset is 0\n  }\n\n  // When parent injector location is computed it may be outside of the current view. (ie it could\n  // be pointing to a declared parent location). This variable stores number of declaration parents\n  // we need to walk up in order to find the parent injector location.\n  let declarationViewOffset = 0;\n  let parentTNode: TNode|null = null;\n  let lViewCursor: LView|null = lView;\n\n  // The parent injector is not in the current `LView`. We will have to walk the declared parent\n  // `LView` hierarchy and look for it. If we walk of the top, that means that there is no parent\n  // `NodeInjector`.\n  while (lViewCursor !== null) {\n    // First determine the `parentTNode` location. The parent pointer differs based on `TView.type`.\n    const tView = lViewCursor[TVIEW];\n    const tViewType = tView.type;\n    if (tViewType === TViewType.Embedded) {\n      ngDevMode &&\n          assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\n      parentTNode = tView.declTNode;\n    } else if (tViewType === TViewType.Component) {\n      // Components don't have `TView.declTNode` because each instance of component could be\n      // inserted in different location, hence `TView.declTNode` is meaningless.\n      parentTNode = lViewCursor[T_HOST];\n    } else {\n      ngDevMode && assertEqual(tView.type, TViewType.Root, 'Root type expected');\n      parentTNode = null;\n    }\n    if (parentTNode === null) {\n      // If we have no parent, than we are done.\n      return NO_PARENT_INJECTOR;\n    }\n\n    ngDevMode && parentTNode && assertTNodeForLView(parentTNode!, lViewCursor[DECLARATION_VIEW]!);\n    // Every iteration of the loop requires that we go to the declared parent.\n    declarationViewOffset++;\n    lViewCursor = lViewCursor[DECLARATION_VIEW];\n\n    if (parentTNode.injectorIndex !== -1) {\n      // We found a NodeInjector which points to something.\n      return (parentTNode.injectorIndex |\n              (declarationViewOffset << RelativeInjectorLocationFlags.ViewOffsetShift)) as any;\n    }\n  }\n  return NO_PARENT_INJECTOR;\n}\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nexport function diPublicInInjector(\n    injectorIndex: number, tView: TView, token: InjectionToken<any>|Type<any>): void {\n  bloomAdd(injectorIndex, tView, token);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ɵcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nexport function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string|null {\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyContainer | TNodeType.AnyRNode);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  if (attrNameToInject === 'class') {\n    return tNode.classes;\n  }\n  if (attrNameToInject === 'style') {\n    return tNode.styles;\n  }\n\n  const attrs = tNode.attrs;\n  if (attrs) {\n    const attrsLength = attrs.length;\n    let i = 0;\n    while (i < attrsLength) {\n      const value = attrs[i];\n\n      // If we hit a `Bindings` or `Template` marker then we are done.\n      if (isNameOnlyAttributeMarker(value)) break;\n\n      // Skip namespaced attributes\n      if (value === AttributeMarker.NamespaceURI) {\n        // we skip the next two values\n        // as namespaced attributes looks like\n        // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n        // 'existValue', ...]\n        i = i + 2;\n      } else if (typeof value === 'number') {\n        // Skip to the first value of the marked attribute.\n        i++;\n        while (i < attrsLength && typeof attrs[i] === 'string') {\n          i++;\n        }\n      } else if (value === attrNameToInject) {\n        return attrs[i + 1] as string;\n      } else {\n        i = i + 2;\n      }\n    }\n  }\n  return null;\n}\n\n\nfunction notFoundValueOrThrow<T>(\n    notFoundValue: T|null, token: Type<T>|AbstractType<T>|InjectionToken<T>, flags: InjectFlags): T|\n    null {\n  if (flags & InjectFlags.Optional) {\n    return notFoundValue;\n  } else {\n    throwProviderNotFoundError(token, 'NodeInjector');\n  }\n}\n\n/**\n * Returns the value associated to the given token from the ModuleInjector or throws exception\n *\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector or throws an exception\n */\nfunction lookupTokenUsingModuleInjector<T>(\n    lView: LView, token: Type<T>|AbstractType<T>|InjectionToken<T>, flags: InjectFlags,\n    notFoundValue?: any): T|null {\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR];\n    // switch to `injectInjectorOnly` implementation for module injector, since module injector\n    // should not have access to Component/Directive DI scope (that may happen through\n    // `directiveInject` implementation)\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      if (moduleInjector) {\n        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n      } else {\n        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  return notFoundValueOrThrow<T>(notFoundValue, token, flags);\n}\n\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nexport function getOrCreateInjectable<T>(\n    tNode: TDirectiveHostNode|null, lView: LView, token: Type<T>|AbstractType<T>|InjectionToken<T>,\n    flags: InjectFlags = InjectFlags.Default, notFoundValue?: any): T|null {\n  if (tNode !== null) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n      if (!enterDI(lView, tNode, flags)) {\n        // Failed to enter DI, try module injector instead. If a token is injected with the @Host\n        // flag, the module injector is not searched for that token in Ivy.\n        return (flags & InjectFlags.Host) ?\n            notFoundValueOrThrow<T>(notFoundValue, token, flags) :\n            lookupTokenUsingModuleInjector<T>(lView, token, flags, notFoundValue);\n      }\n      try {\n        const value = bloomHash();\n        if (value == null && !(flags & InjectFlags.Optional)) {\n          throwProviderNotFoundError(token);\n        } else {\n          return value;\n        }\n      } finally {\n        leaveDI();\n      }\n    } else if (typeof bloomHash === 'number') {\n      // A reference to the previous injector TView that was found while climbing the element\n      // injector tree. This is used to know if viewProviders can be accessed on the current\n      // injector.\n      let previousTView: TView|null = null;\n      let injectorIndex = getInjectorIndex(tNode, lView);\n      let parentLocation: RelativeInjectorLocation = NO_PARENT_INJECTOR;\n      let hostTElementNode: TNode|null =\n          flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n\n      // If we should skip this injector, or if there is no injector on this node, start by\n      // searching the parent injector.\n      if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n        parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                                                lView[injectorIndex + NodeInjectorOffset.PARENT];\n\n        if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n          injectorIndex = -1;\n        } else {\n          previousTView = lView[TVIEW];\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        }\n      }\n\n      // Traverse up the injector tree until we find a potential match or until we know there\n      // *isn't* a match.\n      while (injectorIndex !== -1) {\n        ngDevMode && assertNodeInjector(lView, injectorIndex);\n\n        // Check the current injector. If it matches, see if it contains token.\n        const tView = lView[TVIEW];\n        ngDevMode &&\n            assertTNodeForLView(\n                tView.data[injectorIndex + NodeInjectorOffset.TNODE] as TNode, lView);\n        if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n          // At this point, we have an injector which *may* contain the token, so we step through\n          // the providers and directives associated with the injector's corresponding node to get\n          // the instance.\n          const instance: T|null = searchTokensOnInjector<T>(\n              injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n          if (instance !== NOT_FOUND) {\n            return instance;\n          }\n        }\n        parentLocation = lView[injectorIndex + NodeInjectorOffset.PARENT];\n        if (parentLocation !== NO_PARENT_INJECTOR &&\n            shouldSearchParent(\n                flags,\n                lView[TVIEW].data[injectorIndex + NodeInjectorOffset.TNODE] === hostTElementNode) &&\n            bloomHasToken(bloomHash, injectorIndex, lView)) {\n          // The def wasn't found anywhere on this node, so it was a false positive.\n          // Traverse up the tree and continue searching.\n          previousTView = tView;\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        } else {\n          // If we should not search parent OR If the ancestor bloom filter value does not have the\n          // bit corresponding to the directive we can give up on traversing up to find the specific\n          // injector.\n          injectorIndex = -1;\n        }\n      }\n    }\n  }\n\n  return lookupTokenUsingModuleInjector<T>(lView, token, flags, notFoundValue);\n}\n\nconst NOT_FOUND = {};\n\nexport function createNodeInjector(): Injector {\n  return new NodeInjector(getCurrentTNode()! as TDirectiveHostNode, getLView()) as any;\n}\n\nfunction searchTokensOnInjector<T>(\n    injectorIndex: number, lView: LView, token: Type<T>|AbstractType<T>|InjectionToken<T>,\n    previousTView: TView|null, flags: InjectFlags, hostTElementNode: TNode|null) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + NodeInjectorOffset.TNODE] as TNode;\n  // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibilities\n  const canAccessViewProviders = previousTView == null ?\n      // 1) This is the first invocation `previousTView == null` which means that we are at the\n      // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n      // to look into the ViewProviders is if:\n      // - we are on a component\n      // - AND the injector set `includeViewProviders` to true (implying that the token can see\n      // ViewProviders because it is the Component or a Service which itself was declared in\n      // ViewProviders)\n      (isComponentHost(tNode) && includeViewProviders) :\n      // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n      // In such a case we are only allowed to look into the ViewProviders if:\n      // - We just crossed from child View to Parent View `previousTView != currentTView`\n      // - AND the parent TNode is an Element.\n      // This means that we just came from the Component's View and therefore are allowed to see\n      // into the ViewProviders.\n      (previousTView != currentTView && ((tNode.type & TNodeType.AnyRNode) !== 0));\n\n  // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n  const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;\n\n  const injectableIdx = locateDirectiveOrProvider(\n      tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(lView, currentTView, injectableIdx, tNode as TElementNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nexport function locateDirectiveOrProvider<T>(\n    tNode: TNode, tView: TView, token: Type<T>|AbstractType<T>|InjectionToken<T>|string,\n    canAccessViewProviders: boolean, isHostSpecialCase: boolean|number): number|null {\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n\n  const injectablesStart = nodeProviderIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount =\n      nodeProviderIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n  const startingIndex =\n      canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n  // When the host special case applies, only the viewProviders and the component are visible\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef =\n        tInjectables[i] as InjectionToken<any>| Type<any>| DirectiveDef<any>| string;\n    if (i < directivesStart && token === providerTokenOrDef ||\n        i >= directivesStart && (providerTokenOrDef as DirectiveDef<any>).type === token) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart] as DirectiveDef<any>;\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\n\n/**\n * Retrieve or instantiate the injectable from the `LView` at particular `index`.\n *\n * This function checks to see if the value has already been instantiated and if so returns the\n * cached `injectable`. Otherwise if it detects that the value is still a factory it\n * instantiates the `injectable` and caches the value.\n */\nexport function getNodeInjectable(\n    lView: LView, tView: TView, index: number, tNode: TDirectiveHostNode): any {\n  let value = lView[index];\n  const tData = tView.data;\n  if (isFactory(value)) {\n    const factory: NodeInjectorFactory = value;\n    if (factory.resolving) {\n      throwCyclicDependencyError(stringifyForError(tData[index]));\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    const previousInjectImplementation =\n        factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n    const success = enterDI(lView, tNode, InjectFlags.Default);\n    ngDevMode &&\n        assertEqual(\n            success, true,\n            'Because flags do not contain \\`SkipSelf\\' we expect this to always succeed.');\n    try {\n      value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n      // This code path is hit for both directives and providers.\n      // For perf reasons, we want to avoid searching for hooks on providers.\n      // It does no harm to try (the hooks just won't exist), but the extra\n      // checks are unnecessary and this is a hot path. So we check to see\n      // if the index of the dependency is in the directive range for this\n      // tNode. If it's not, we know it's a provider and skip hook registration.\n      if (tView.firstCreatePass && index >= tNode.directiveStart) {\n        ngDevMode && assertDirectiveDef(tData[index]);\n        registerPreOrderHooks(index, tData[index] as DirectiveDef<any>, tView);\n      }\n    } finally {\n      previousInjectImplementation !== null &&\n          setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      leaveDI();\n    }\n  }\n  return value;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nexport function bloomHashBitOrFactory(token: Type<any>|AbstractType<any>|InjectionToken<any>|\n                                      string): number|Function|undefined {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId: number|undefined =\n      // First check with `hasOwnProperty` so we don't get an inherited ID.\n      token.hasOwnProperty(NG_ELEMENT_ID) ? (token as any)[NG_ELEMENT_ID] : undefined;\n  // Negative token IDs are used for special objects such as `Injector`\n  if (typeof tokenId === 'number') {\n    if (tokenId >= 0) {\n      return tokenId & BLOOM_MASK;\n    } else {\n      ngDevMode &&\n          assertEqual(tokenId, InjectorMarkers.Injector, 'Expecting to get Special Injector Id');\n      return createNodeInjector;\n    }\n  } else {\n    return tokenId;\n  }\n}\n\nexport function bloomHasToken(bloomHash: number, injectorIndex: number, injectorView: LView|TData) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  const b7 = bloomHash & 0x80;\n  const b6 = bloomHash & 0x40;\n  const b5 = bloomHash & 0x20;\n\n  // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n  // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n  // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n  let value: number;\n\n  if (b7) {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\n                 (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\n  } else {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\n                 (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\n  }\n\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags: InjectFlags, isFirstHostTNode: boolean): boolean|number {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\n\nexport class NodeInjector implements Injector {\n  constructor(\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode|null,\n      private _lView: LView) {}\n\n  get(token: any, notFoundValue?: any): any {\n    return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);\n  }\n}\n\n/**\n * @codeGenApi\n */\nexport function ɵɵgetFactoryOf<T>(type: Type<any>): FactoryFn<T>|null {\n  const typeAny = type as any;\n\n  if (isForwardRef(type)) {\n    return (() => {\n             const factory = ɵɵgetFactoryOf<T>(resolveForwardRef(typeAny));\n             return factory ? factory() : null;\n           }) as any;\n  }\n\n  let factory = getFactoryDef<T>(typeAny);\n  if (factory === null) {\n    const injectorDef = getInjectorDef<T>(typeAny);\n    factory = injectorDef && injectorDef.factory;\n  }\n  return factory || null;\n}\n\n/**\n * @codeGenApi\n */\nexport function ɵɵgetInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  return noSideEffects(() => {\n    const ownConstructor = type.prototype.constructor;\n    const ownFactory = ownConstructor[NG_FACTORY_DEF] || ɵɵgetFactoryOf(ownConstructor);\n    const objectPrototype = Object.prototype;\n    let parent = Object.getPrototypeOf(type.prototype).constructor;\n\n    // Go up the prototype until we hit `Object`.\n    while (parent && parent !== objectPrototype) {\n      const factory = parent[NG_FACTORY_DEF] || ɵɵgetFactoryOf(parent);\n\n      // If we hit something that has a factory and the factory isn't the same as the type,\n      // we've found the inherited factory. Note the check that the factory isn't the type's\n      // own factory is redundant in most cases, but if the user has custom decorators on the\n      // class, this lookup will start one level down in the prototype chain, causing us to\n      // find the own factory first and potentially triggering an infinite loop downstream.\n      if (factory && factory !== ownFactory) {\n        return factory;\n      }\n\n      parent = Object.getPrototypeOf(parent);\n    }\n\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return t => new t();\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\n\nimport {noSideEffects} from './closure';\n\n\n\n/**\n * An interface implemented by all Angular type decorators, which allows them to be used as\n * decorators as well as Angular syntax.\n *\n * ```\n * @ng.Component({...})\n * class MyClass {...}\n * ```\n *\n * @publicApi\n */\nexport interface TypeDecorator {\n  /**\n   * Invoke as decorator.\n   */\n  <T extends Type<any>>(type: T): T;\n\n  // Make TypeDecorator assignable to built-in ParameterDecorator type.\n  // ParameterDecorator is declared in lib.d.ts as a `declare type`\n  // so we cannot declare this interface as a subtype.\n  // see https://github.com/angular/angular/issues/3379#issuecomment-126169417\n  (target: Object, propertyKey?: string|symbol, parameterIndex?: number): void;\n}\n\nexport const ANNOTATIONS = '__annotations__';\nexport const PARAMETERS = '__parameters__';\nexport const PROP_METADATA = '__prop__metadata__';\n\n/**\n * @suppress {globalThis}\n */\nexport function makeDecorator<T>(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (type: Type<T>) => void,\n    typeFn?: (type: Type<T>, ...args: any[]) => void):\n    {new (...args: any[]): any; (...args: any[]): any; (...args: any[]): (cls: any) => any;} {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n\n    function DecoratorFactory(\n        this: unknown|typeof DecoratorFactory, ...args: any[]): (cls: Type<T>) => any {\n      if (this instanceof DecoratorFactory) {\n        metaCtor.call(this, ...args);\n        return this as typeof DecoratorFactory;\n      }\n\n      const annotationInstance = new (DecoratorFactory as any)(...args);\n      return function TypeDecorator(cls: Type<T>) {\n        if (typeFn) typeFn(cls, ...args);\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n            (cls as any)[ANNOTATIONS] :\n            Object.defineProperty(cls, ANNOTATIONS, {value: []})[ANNOTATIONS];\n        annotations.push(annotationInstance);\n\n\n        if (additionalProcessing) additionalProcessing(cls);\n\n        return cls;\n      };\n    }\n\n    if (parentClass) {\n      DecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n\n    DecoratorFactory.prototype.ngMetadataName = name;\n    (DecoratorFactory as any).annotationCls = DecoratorFactory;\n    return DecoratorFactory as any;\n  });\n}\n\nfunction makeMetadataCtor(props?: (...args: any[]) => any): any {\n  return function ctor(this: any, ...args: any[]) {\n    if (props) {\n      const values = props(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\n\nexport function makeParamDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any): any {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n    function ParamDecoratorFactory(\n        this: unknown|typeof ParamDecoratorFactory, ...args: any[]): any {\n      if (this instanceof ParamDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n      const annotationInstance = new (<any>ParamDecoratorFactory)(...args);\n\n      (<any>ParamDecorator).annotation = annotationInstance;\n      return ParamDecorator;\n\n      function ParamDecorator(cls: any, unusedKey: any, index: number): any {\n        // Use of Object.defineProperty is important since it creates non-enumerable property which\n        // prevents the property is copied during subclassing.\n        const parameters = cls.hasOwnProperty(PARAMETERS) ?\n            (cls as any)[PARAMETERS] :\n            Object.defineProperty(cls, PARAMETERS, {value: []})[PARAMETERS];\n\n        // there might be gaps if some in between parameters do not have annotations.\n        // we pad with nulls.\n        while (parameters.length <= index) {\n          parameters.push(null);\n        }\n\n        (parameters[index] = parameters[index] || []).push(annotationInstance);\n        return cls;\n      }\n    }\n    if (parentClass) {\n      ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    ParamDecoratorFactory.prototype.ngMetadataName = name;\n    (<any>ParamDecoratorFactory).annotationCls = ParamDecoratorFactory;\n    return ParamDecoratorFactory;\n  });\n}\n\nexport function makePropDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props);\n\n    function PropDecoratorFactory(this: unknown|typeof PropDecoratorFactory, ...args: any[]): any {\n      if (this instanceof PropDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n\n      const decoratorInstance = new (<any>PropDecoratorFactory)(...args);\n\n      function PropDecorator(target: any, name: string) {\n        const constructor = target.constructor;\n        // Use of Object.defineProperty is important because it creates a non-enumerable property\n        // which prevents the property from being copied during subclassing.\n        const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n            (constructor as any)[PROP_METADATA] :\n            Object.defineProperty(constructor, PROP_METADATA, {value: {}})[PROP_METADATA];\n        meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n        meta[name].unshift(decoratorInstance);\n\n        if (additionalProcessing) additionalProcessing(target, name, ...args);\n      }\n\n      return PropDecorator;\n    }\n\n    if (parentClass) {\n      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n\n    PropDecoratorFactory.prototype.ngMetadataName = name;\n    (<any>PropDecoratorFactory).annotationCls = PropDecoratorFactory;\n    return PropDecoratorFactory;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {assertLessThan} from '../util/assert';\n\nimport {ɵɵdefineInjectable} from './interface/defs';\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function. See below for an example.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Example\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nexport class InjectionToken<T> {\n  /** @internal */\n  readonly ngMetadataName = 'InjectionToken';\n\n  readonly ɵprov: never|undefined;\n\n  constructor(protected _desc: string, options?: {\n    providedIn?: Type<any>|'root'|'platform'|'any'|null, factory: () => T\n  }) {\n    this.ɵprov = undefined;\n    if (typeof options == 'number') {\n      (typeof ngDevMode === 'undefined' || ngDevMode) &&\n          assertLessThan(options, 0, 'Only negative numbers are supported here');\n      // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n      // See `InjectorMarkers`\n      (this as any).__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.ɵprov = ɵɵdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory,\n      });\n    }\n  }\n\n  toString(): string {\n    return `InjectionToken ${this._desc}`;\n  }\n}\n\nexport interface InjectableDefToken<T> extends InjectionToken<T> {\n  ɵprov: never;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertLessThanOrEqual} from './assert';\n\n/**\n * Equivalent to ES6 spread, add each item to an array.\n *\n * @param items The items to add\n * @param arr The array to which you want to add the items\n */\nexport function addAllToArray(items: any[], arr: any[]) {\n  for (let i = 0; i < items.length; i++) {\n    arr.push(items[i]);\n  }\n}\n\n/**\n * Flattens an array.\n */\nexport function flatten(list: any[], dst?: any[]): any[] {\n  if (dst === undefined) dst = list;\n  for (let i = 0; i < list.length; i++) {\n    let item = list[i];\n    if (Array.isArray(item)) {\n      // we need to inline it.\n      if (dst === list) {\n        // Our assumption that the list was already flat was wrong and\n        // we need to clone flat since we need to write to it.\n        dst = list.slice(0, i);\n      }\n      flatten(item, dst);\n    } else if (dst !== list) {\n      dst.push(item);\n    }\n  }\n  return dst;\n}\n\nexport function deepForEach<T>(input: (T|any[])[], fn: (value: T) => void): void {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nexport function addToArray(arr: any[], index: number, value: any): void {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n\nexport function removeFromArray(arr: any[], index: number): any {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value!);\n  }\n  return list;\n}\n\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nexport function arraySplice(array: any[], index: number, count: number): void {\n  const length = array.length - count;\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n  while (count--) {\n    array.pop();  // shrink the array\n  }\n}\n\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\nexport function arrayInsert(array: any[], index: number, value: any): void {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n  while (end > index) {\n    const previousEnd = end - 1;\n    array[end] = array[previousEnd];\n    end = previousEnd;\n  }\n  array[index] = value;\n}\n\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nexport function arrayInsert2(array: any[], index: number, value1: any, value2: any): void {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n  if (end == index) {\n    // inserting at the end.\n    array.push(value1, value2);\n  } else if (end === 1) {\n    // corner case when we have less items in array than we have items to insert.\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\n\n/**\n * Insert a `value` into an `array` so that the array remains sorted.\n *\n * NOTE:\n * - Duplicates are not allowed, and are ignored.\n * - This uses binary search algorithm for fast inserts.\n *\n * @param array A sorted array to insert into.\n * @param value The value to insert.\n * @returns index of the inserted value.\n */\nexport function arrayInsertSorted(array: string[], value: string): number {\n  let index = arrayIndexOfSorted(array, value);\n  if (index < 0) {\n    // if we did not find it insert it.\n    index = ~index;\n    arrayInsert(array, index, value);\n  }\n  return index;\n}\n\n/**\n * Remove `value` from a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to remove from.\n * @param value The value to remove.\n * @returns index of the removed value.\n *   - positive index if value found and removed.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     inserted)\n */\nexport function arrayRemoveSorted(array: string[], value: string): number {\n  const index = arrayIndexOfSorted(array, value);\n  if (index >= 0) {\n    arraySplice(array, index, 1);\n  }\n  return index;\n}\n\n\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\nexport function arrayIndexOfSorted(array: string[], value: string): number {\n  return _arrayIndexOfSorted(array, value, 0);\n}\n\n\n/**\n * `KeyValueArray` is an array where even positions contain keys and odd positions contain values.\n *\n * `KeyValueArray` provides a very efficient way of iterating over its contents. For small\n * sets (~10) the cost of binary searching an `KeyValueArray` has about the same performance\n * characteristics that of a `Map` with significantly better memory footprint.\n *\n * If used as a `Map` the keys are stored in alphabetical order so that they can be binary searched\n * for retrieval.\n *\n * See: `keyValueArraySet`, `keyValueArrayGet`, `keyValueArrayIndexOf`, `keyValueArrayDelete`.\n */\nexport interface KeyValueArray<VALUE> extends Array<VALUE|string> {\n  __brand__: 'array-map';\n}\n\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nexport function keyValueArraySet<V>(\n    keyValueArray: KeyValueArray<V>, key: string, value: V): number {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it set it.\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n  return index;\n}\n\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nexport function keyValueArrayGet<V>(keyValueArray: KeyValueArray<V>, key: string): V|undefined {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it retrieve it.\n    return keyValueArray[index | 1] as V;\n  }\n  return undefined;\n}\n\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nexport function keyValueArrayIndexOf<V>(keyValueArray: KeyValueArray<V>, key: string): number {\n  return _arrayIndexOfSorted(keyValueArray as string[], key, 1);\n}\n\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\nexport function keyValueArrayDelete<V>(keyValueArray: KeyValueArray<V>, key: string): number {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it remove it.\n    arraySplice(keyValueArray, index, 2);\n  }\n  return index;\n}\n\n\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array: string[], value: string, shift: number): number {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + ((end - start) >> 1);  // find the middle.\n    const current = array[middle << shift];\n    if (value === current) {\n      return (middle << shift);\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1;  // We already searched middle so make it non-inclusive by adding 1\n    }\n  }\n  return ~(end << shift);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {makeParamDecorator} from '../util/decorators';\n\n\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectDecorator {\n  /**\n   * Parameter decorator on a dependency parameter of a class constructor\n   * that specifies a custom provider of the dependency.\n   *\n   * @usageNotes\n   * The following example shows a class constructor that specifies a\n   * custom provider of a dependency using the parameter decorator.\n   *\n   * When `@Inject()` is not present, the injector uses the type annotation of the\n   * parameter as the provider.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"InjectWithoutDecorator\">\n   * </code-example>\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection)\n   *\n   */\n  (token: any): any;\n  new(token: any): Inject;\n}\n\n/**\n * Type of the Inject metadata.\n *\n * @publicApi\n */\nexport interface Inject {\n  /**\n   * A [DI token](guide/glossary#di-token) that maps to the dependency to be injected.\n   */\n  token: any;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Inject: InjectDecorator = makeParamDecorator('Inject', (token: any) => ({token}));\n\n\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OptionalDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which marks the parameter as being an optional dependency.\n   * The DI framework provides null if the dependency is not found.\n   *\n   * Can be used together with other parameter decorators\n   * that modify how dependency injection operates.\n   *\n   * @usageNotes\n   *\n   * The following code allows the possibility of a null result:\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Optional\">\n   * </code-example>\n   *\n   * @see [\"Dependency Injection Guide\"](guide/dependency-injection).\n   */\n  (): any;\n  new(): Optional;\n}\n\n/**\n * Type of the Optional metadata.\n *\n * @publicApi\n */\nexport interface Optional {}\n\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Optional: OptionalDecorator = makeParamDecorator('Optional');\n\n/**\n * Type of the Self decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the local injector.\n   *\n   * Resolution works upward through the injector hierarchy, so the children\n   * of this class must configure their own providers or be prepared for a null result.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved\n   * by the local injector when instantiating the class itself, but not\n   * when instantiating a child.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Self\">\n   * </code-example>\n   *\n   * @see `SkipSelf`\n   * @see `Optional`\n   *\n   */\n  (): any;\n  new(): Self;\n}\n\n/**\n * Type of the Self metadata.\n *\n * @publicApi\n */\nexport interface Self {}\n\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Self: SelfDecorator = makeParamDecorator('Self');\n\n\n/**\n * Type of the `SkipSelf` decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SkipSelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the parent injector.\n   * Resolution works upward through the injector hierarchy, so the local injector\n   * is not checked for a provider.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved when\n   * instantiating a child, but not when instantiating the class itself.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"SkipSelf\">\n   * </code-example>\n   *\n   * @see [Dependency Injection guide](guide/dependency-injection-in-action#skip).\n   * @see `Self`\n   * @see `Optional`\n   *\n   */\n  (): any;\n  new(): SkipSelf;\n}\n\n/**\n * Type of the `SkipSelf` metadata.\n *\n * @publicApi\n */\nexport interface SkipSelf {}\n\n/**\n * `SkipSelf` decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const SkipSelf: SkipSelfDecorator = makeParamDecorator('SkipSelf');\n\n/**\n * Type of the `Host` decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostDecorator {\n  /**\n   * Parameter decorator on a view-provider parameter of a class constructor\n   * that tells the DI framework to resolve the view by checking injectors of child\n   * elements, and stop when reaching the host element of the current component.\n   *\n   * @usageNotes\n   *\n   * The following shows use with the `@Optional` decorator, and allows for a null result.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Host\">\n   * </code-example>\n   *\n   * For an extended example, see [\"Dependency Injection\n   * Guide\"](guide/dependency-injection-in-action#optional).\n   */\n  (): any;\n  new(): Host;\n}\n\n/**\n * Type of the Host metadata.\n *\n * @publicApi\n */\nexport interface Host {}\n\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Host: HostDecorator = makeParamDecorator('Host');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {AbstractType, Type} from '../interface/type';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\nimport {resolveForwardRef} from './forward_ref';\nimport {getInjectImplementation, injectRootLimpMode} from './inject_switch';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {InjectFlags} from './interface/injector';\nimport {ValueProvider} from './interface/provider';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\n\n\nconst _THROW_IF_NOT_FOUND = {};\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\nexport const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'ɵ';\nexport const SOURCE = '__source';\n\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector|null|undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\nexport function injectInjectorOnly<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>): T;\nexport function injectInjectorOnly<T>(\n    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function injectInjectorOnly<T>(\n    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\n/**\n * Generated instruction: Injects a token from the currently active injector.\n *\n * Must be used in the context of a factory function such as one defined for an\n * `InjectionToken`. Throws an error if not called from such a context.\n *\n * (Additional documentation moved to `inject`, as it is the public API, and an alias for this\n * instruction)\n *\n * @see inject\n * @codeGenApi\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\n */\nexport function ɵɵinject<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>): T;\nexport function ɵɵinject<T>(\n    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function ɵɵinject<T>(\n    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport function ɵɵinvalidFactoryDep(index: number): never {\n  const msg = ngDevMode ?\n      `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${\n          index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${\n          index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.` :\n      'invalid';\n  throw new Error(msg);\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * Must be used in the context of a factory function such as one defined for an\n * `InjectionToken`. Throws an error if not called from such a context.\n *\n * Within such a factory function, using this function to request injection of a dependency\n * is faster and more type-safe than providing an additional array of dependencies\n * (as has been common with `useFactory` providers).\n *\n * @param token The injection token for the dependency to be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSef`, and `@Optional`.\n * @returns True if injection is successful, null otherwise.\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n * @publicApi\n */\nexport const inject = ɵɵinject;\n\nexport function injectArgs(types: (Type<any>|InjectionToken<any>|any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional' || meta === Optional) {\n          flags |= InjectFlags.Optional;\n        } else if (\n            meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf' || meta === SkipSelf) {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self' || meta === Self) {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject || meta === Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(ɵɵinject(type!, flags));\n    } else {\n      args.push(ɵɵinject(arg));\n    }\n  }\n  return args;\n}\n\n\nexport function catchInjectorError(\n    e: any, token: any, injectorErrorName: string, source: string|null): never {\n  const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n  if (token[SOURCE]) {\n    tokenPath.unshift(token[SOURCE]);\n  }\n  e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n  e[NG_TOKEN_PATH] = tokenPath;\n  e[NG_TEMP_TOKEN_PATH] = null;\n  throw e;\n}\n\nexport function formatError(\n    text: string, obj: any, injectorErrorName: string, source: string|null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${\n      text.replace(NEW_LINE, '\\n  ')}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ERROR_DEBUG_CONTEXT, ERROR_LOGGER, ERROR_ORIGINAL_ERROR, ERROR_TYPE} from './util/errors';\nimport {DebugContext} from './view/types';\n\nexport function getType(error: Error): Function {\n  return (error as any)[ERROR_TYPE];\n}\n\nexport function getDebugContext(error: Error): DebugContext {\n  return (error as any)[ERROR_DEBUG_CONTEXT];\n}\n\nexport function getOriginalError(error: Error): Error {\n  return (error as any)[ERROR_ORIGINAL_ERROR];\n}\n\nexport function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void {\n  return (error as any)[ERROR_LOGGER] || defaultErrorLogger;\n}\n\n\nfunction defaultErrorLogger(console: Console, ...values: any[]) {\n  (<any>console.error)(...values);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getDebugContext, getErrorLogger, getOriginalError} from './errors';\n\n\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nexport class ErrorHandler {\n  /**\n   * @internal\n   */\n  _console: Console = console;\n\n  handleError(error: any): void {\n    const originalError = this._findOriginalError(error);\n    const context = this._findContext(error);\n    // Note: Browser consoles show the place from where console.error was called.\n    // We can use this to give users additional information about the error.\n    const errorLogger = getErrorLogger(error);\n\n    errorLogger(this._console, `ERROR`, error);\n    if (originalError) {\n      errorLogger(this._console, `ORIGINAL ERROR`, originalError);\n    }\n    if (context) {\n      errorLogger(this._console, 'ERROR CONTEXT', context);\n    }\n  }\n\n  /** @internal */\n  _findContext(error: any): any {\n    if (error) {\n      return getDebugContext(error) ? getDebugContext(error) :\n                                      this._findContext(getOriginalError(error));\n    }\n\n    return null;\n  }\n\n  /** @internal */\n  _findOriginalError(error: Error): any {\n    let e = getOriginalError(error);\n    while (e && getOriginalError(e)) {\n      e = getOriginalError(e);\n    }\n\n    return e;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../util/ng_dev_mode';\n\nimport {assertDomNode} from '../util/assert';\n\nimport {EMPTY_ARRAY} from './empty';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {TNode, TNodeFlags} from './interfaces/node';\nimport {RElement, RNode} from './interfaces/renderer_dom';\nimport {CONTEXT, HEADER_OFFSET, HOST, LView, TVIEW} from './interfaces/view';\nimport {getComponentLViewByIndex, readPatchedData, unwrapRNode} from './util/view_utils';\n\n\n\n/**\n * Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nexport function getLContext(target: any): LContext|null {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (Array.isArray(mpValue)) {\n      const lView: LView = mpValue!;\n      let nodeIndex: number;\n      let component: any = undefined;\n      let directives: any[]|null|undefined = undefined;\n\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target as RElement);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, component, container, ICU\n      // expression or directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = unwrapRNode(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context: LContext = (existingCtx && !Array.isArray(existingCtx)) ?\n          existingCtx :\n          createLContext(lView, nodeIndex, native);\n\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target as RElement;\n    ngDevMode && assertDomNode(rElement);\n\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement as any;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        let lView: LView|null;\n        if (Array.isArray(parentContext)) {\n          lView = parentContext as LView;\n        } else {\n          lView = parentContext.lView;\n        }\n\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lView) {\n          return null;\n        }\n\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = unwrapRNode(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return (mpValue as LContext) || null;\n}\n\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView: LView, nodeIndex: number, native: RNode): LContext {\n  return {\n    lView,\n    nodeIndex,\n    native,\n    component: undefined,\n    directives: undefined,\n    localRefs: undefined,\n  };\n}\n\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nexport function getComponentViewByInstance(componentInstance: {}): LView {\n  let lView = readPatchedData(componentInstance);\n  let view: LView;\n\n  if (Array.isArray(lView)) {\n    const nodeIndex = findViaComponent(lView, componentInstance);\n    view = getComponentLViewByIndex(nodeIndex, lView);\n    const context = createLContext(lView, nodeIndex, view[HOST] as RElement);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = lView as any as LContext;\n    view = getComponentLViewByIndex(context.nodeIndex, context.lView);\n  }\n  return view;\n}\n\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nexport function attachPatchData(target: any, data: LView|LContext) {\n  target[MONKEY_PATCH_KEY_NAME] = data;\n}\n\nexport function isComponentInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ɵcmp;\n}\n\nexport function isDirectiveInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.ɵdir;\n}\n\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView: LView, target: RElement): number {\n  const tView = lView[TVIEW];\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (unwrapRNode(lView[i]) === target) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode: TNode): TNode|null {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    // Let's take the following template: <div><span>text</span></div><component/>\n    // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n    // in this case the parent `div`, so that we can find the component.\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n    return tNode.parent && tNode.parent.next;\n  }\n}\n\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView: LView, componentInstance: {}): number {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView: LView, directiveInstance: {}): number {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nexport function getDirectivesAtNodeIndex(\n    nodeIndex: number, lView: LView, includeComponents: boolean): any[]|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  if (directiveStartIndex == 0) return EMPTY_ARRAY;\n  const directiveEndIndex = tNode.directiveEnd;\n  if (!includeComponents && tNode.flags & TNodeFlags.isComponentHost) directiveStartIndex++;\n  return lView.slice(directiveStartIndex, directiveEndIndex);\n}\n\nexport function getComponentAtNodeIndex(nodeIndex: number, lView: LView): {}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  return tNode.flags & TNodeFlags.isComponentHost ? lView[directiveStartIndex] : null;\n}\n\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nexport function discoverLocalRefs(lView: LView, nodeIndex: number): {[key: string]: any}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  if (tNode && tNode.localNames) {\n    const result: {[key: string]: any} = {};\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      result[tNode.localNames[i]] = lView[localIndex];\n      localIndex++;\n    }\n    return result;\n  }\n\n  return null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from '../../util/global';\nimport {RElement} from '../interfaces/renderer_dom';\n\n\nexport const defaultScheduler =\n    (() => (\n               typeof requestAnimationFrame !== 'undefined' &&\n                   requestAnimationFrame ||  // browser only\n               setTimeout                    // everything else\n               )\n               .bind(global))();\n\n/**\n *\n * @codeGenApi\n */\nexport function ɵɵresolveWindow(element: RElement&{ownerDocument: Document}) {\n  return {name: 'window', target: element.ownerDocument.defaultView};\n}\n\n/**\n *\n * @codeGenApi\n */\nexport function ɵɵresolveDocument(element: RElement&{ownerDocument: Document}) {\n  return {name: 'document', target: element.ownerDocument};\n}\n\n/**\n *\n * @codeGenApi\n */\nexport function ɵɵresolveBody(element: RElement&{ownerDocument: Document}) {\n  return {name: 'body', target: element.ownerDocument.body};\n}\n\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\nexport const INTERPOLATION_DELIMITER = `�`;\n\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\nexport function maybeUnwrapFn<T>(value: T|(() => T)): T {\n  if (value instanceof Function) {\n    return value();\n  } else {\n    return value;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewEncapsulation} from '../metadata/view';\n\n\n/**\n * Used by `RendererFactory2` to associate custom rendering data and styles\n * with a rendering implementation.\n *  @publicApi\n */\nexport interface RendererType2 {\n  /**\n   * A unique identifying string for the new renderer, used when creating\n   * unique styles for encapsulation.\n   */\n  id: string;\n  /**\n   * The view encapsulation type, which determines how styles are applied to\n   * DOM elements. One of\n   * - `Emulated` (default): Emulate native scoping of styles.\n   * - `Native`: Use the native encapsulation mechanism of the renderer.\n   * - `ShadowDom`: Use modern [Shadow\n   * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * create a ShadowRoot for component's host element.\n   * - `None`: Do not provide any template or style encapsulation.\n   */\n  encapsulation: ViewEncapsulation;\n  /**\n   * Defines CSS styles to be stored on a renderer instance.\n   */\n  styles: (string|any[])[];\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   */\n  data: {[kind: string]: any};\n}\n\n\n/**\n * Flags for renderer-specific style modifiers.\n * @publicApi\n */\nexport enum RendererStyleFlags2 {\n  // TODO(misko): This needs to be refactored into a separate file so that it can be imported from\n  // `node_manipulation.ts` Currently doing the import cause resolution order to change and fails\n  // the tests. The work around is to have hard coded value in `node_manipulation.ts` for now.\n  /**\n   * Marks a style as important.\n   */\n  Important = 1 << 0,\n  /**\n   * Marks a style as using dash case naming (this-is-dash-case).\n   */\n  DashCase = 1 << 1\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n *\n * This file provides mechanism by which code relevant to the `TIcuContainerNode` is only loaded if\n * ICU is present in the template.\n */\n\nimport {TIcuContainerNode} from '../interfaces/node';\nimport {RNode} from '../interfaces/renderer_dom';\nimport {LView} from '../interfaces/view';\n\n\nlet _icuContainerIterate: (tIcuContainerNode: TIcuContainerNode, lView: LView) =>\n    (() => RNode | null);\n\n/**\n * Iterator which provides ability to visit all of the `TIcuContainerNode` root `RNode`s.\n */\nexport function icuContainerIterate(tIcuContainerNode: TIcuContainerNode, lView: LView): () =>\n    RNode | null {\n  return _icuContainerIterate(tIcuContainerNode, lView);\n}\n\n/**\n * Ensures that `IcuContainerVisitor`'s implementation is present.\n *\n * This function is invoked when i18n instruction comes across an ICU. The purpose is to allow the\n * bundler to tree shake ICU logic and only load it if ICU instruction is executed.\n */\nexport function ensureIcuContainerVisitorLoaded(\n    loader: () => ((tIcuContainerNode: TIcuContainerNode, lView: LView) => (() => RNode | null))) {\n  if (_icuContainerIterate === undefined) {\n    // Do not inline this function. We want to keep `ensureIcuContainerVisitorLoaded` light, so it\n    // can be inlined into call-site.\n    _icuContainerIterate = loader();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from '../../util/assert';\nimport {assertLView} from '../assert';\nimport {LContainer} from '../interfaces/container';\nimport {isLContainer, isLView} from '../interfaces/type_checks';\nimport {CHILD_HEAD, CONTEXT, FLAGS, LView, LViewFlags, NEXT, PARENT, RootContext} from '../interfaces/view';\n\nimport {readPatchedLView} from './view_utils';\n\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nexport function getLViewParent(lView: LView): LView|null {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT]! : parent;\n}\n\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nexport function getRootView(componentOrLView: LView|{}): LView {\n  ngDevMode && assertDefined(componentOrLView, 'component');\n  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView)!;\n  while (lView && !(lView[FLAGS] & LViewFlags.IsRoot)) {\n    lView = getLViewParent(lView)!;\n  }\n  ngDevMode && assertLView(lView);\n  return lView;\n}\n\n/**\n * Returns the `RootContext` instance that is associated with\n * the application where the target is situated. It does this by walking the parent views until it\n * gets to the root view, then getting the context off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nexport function getRootContext(viewOrComponent: LView|{}): RootContext {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode &&\n      assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT] as RootContext;\n}\n\n\n/**\n * Gets the first `LContainer` in the LView or `null` if none exists.\n */\nexport function getFirstLContainer(lView: LView): LContainer|null {\n  return getNearestLContainer(lView[CHILD_HEAD]);\n}\n\n/**\n * Gets the next `LContainer` that is a sibling of the given container.\n */\nexport function getNextLContainer(container: LContainer): LContainer|null {\n  return getNearestLContainer(container[NEXT]);\n}\n\nfunction getNearestLContainer(viewOrContainer: LContainer|LView|null) {\n  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n    viewOrContainer = viewOrContainer[NEXT];\n  }\n  return viewOrContainer;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewEncapsulation} from '../metadata/view';\nimport {Renderer2} from '../render/api';\nimport {RendererStyleFlags2} from '../render/api_flags';\nimport {addToArray, removeFromArray} from '../util/array_utils';\nimport {assertDefined, assertDomNode, assertEqual, assertFunction, assertString} from '../util/assert';\nimport {assertLContainer, assertLView, assertTNodeForLView} from './assert';\nimport {attachPatchData} from './context_discovery';\nimport {icuContainerIterate} from './i18n/i18n_tree_shaking';\nimport {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS, NATIVE, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {ComponentDef} from './interfaces/definition';\nimport {NodeInjectorFactory} from './interfaces/injector';\nimport {TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeType, TProjectionNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {isProceduralRenderer, ProceduralRenderer3, Renderer3, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {RComment, RElement, RNode, RText} from './interfaces/renderer_dom';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {CHILD_HEAD, CLEANUP, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, DestroyHookData, FLAGS, HookData, HookFn, HOST, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, T_HOST, TVIEW, TView, TViewType, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertTNodeType} from './node_assert';\nimport {getLViewParent} from './util/view_traversal_utils';\nimport {getNativeByTNode, unwrapRNode, updateTransplantedViewCount} from './util/view_utils';\n\n\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\nconst enum WalkTNodeTreeAction {\n  /** node create in the native environment. Run on initial creation. */\n  Create = 0,\n\n  /**\n   * node insert in the native environment.\n   * Run when existing node has been detached and needs to be re-attached.\n   */\n  Insert = 1,\n\n  /** node detach from the native environment */\n  Detach = 2,\n\n  /** node destruction using the renderer's API */\n  Destroy = 3,\n}\n\n\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(\n    action: WalkTNodeTreeAction, renderer: Renderer3, parent: RElement|null,\n    lNodeToHandle: RNode|LContainer|LView, beforeNode?: RNode|null) {\n  // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n  // won't be created until i18nApply() in the update block, so this node should be skipped.\n  // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n  // in `i18n_spec.ts`.\n  if (lNodeToHandle != null) {\n    let lContainer: LContainer|undefined;\n    let isComponent = false;\n    // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n    // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n    // it has LContainer so that we can process all of those cases appropriately.\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n      lNodeToHandle = lNodeToHandle[HOST]!;\n    }\n    const rNode: RNode = unwrapRNode(lNodeToHandle);\n    ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);\n\n    if (action === WalkTNodeTreeAction.Create && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n      }\n    } else if (action === WalkTNodeTreeAction.Insert && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n    } else if (action === WalkTNodeTreeAction.Detach) {\n      nativeRemoveNode(renderer, rNode, isComponent);\n    } else if (action === WalkTNodeTreeAction.Destroy) {\n      ngDevMode && ngDevMode.rendererDestroyNode++;\n      (renderer as ProceduralRenderer3).destroyNode!(rNode);\n    }\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\n\nexport function createTextNode(renderer: Renderer3, value: string): RText {\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  ngDevMode && ngDevMode.rendererSetText++;\n  return isProceduralRenderer(renderer) ? renderer.createText(value) :\n                                          renderer.createTextNode(value);\n}\n\nexport function updateTextNode(renderer: Renderer3, rNode: RText, value: string): void {\n  ngDevMode && ngDevMode.rendererSetText++;\n  isProceduralRenderer(renderer) ? renderer.setValue(rNode, value) : rNode.textContent = value;\n}\n\nexport function createCommentNode(renderer: Renderer3, value: string): RComment {\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  // isProceduralRenderer check is not needed because both `Renderer2` and `Renderer3` have the same\n  // method name.\n  return renderer.createComment(value);\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param renderer A renderer to use\n * @param name the tag name\n * @param namespace Optional namespace for element.\n * @returns the element created\n */\nexport function createElementNode(\n    renderer: Renderer3, name: string, namespace: string|null): RElement {\n  ngDevMode && ngDevMode.rendererCreateElement++;\n  if (isProceduralRenderer(renderer)) {\n    return renderer.createElement(name, namespace);\n  } else {\n    return namespace === null ? renderer.createElement(name) :\n                                renderer.createElementNS(namespace, name);\n  }\n}\n\n\n/**\n * Removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n */\nexport function removeViewFromContainer(tView: TView, lView: LView): void {\n  const renderer = lView[RENDERER];\n  applyView(tView, lView, renderer, WalkTNodeTreeAction.Detach, null, null);\n  lView[HOST] = null;\n  lView[T_HOST] = null;\n}\n\n/**\n * Adds all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to add all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param parentTNode The `TNode` where the `LView` should be attached to.\n * @param renderer Current renderer to use for DOM manipulations.\n * @param lView The view from which elements should be added or removed\n * @param parentNativeNode The parent `RElement` where it should be inserted into.\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addViewToContainer(\n    tView: TView, parentTNode: TNode, renderer: Renderer3, lView: LView, parentNativeNode: RElement,\n    beforeNode: RNode|null): void {\n  lView[HOST] = parentNativeNode;\n  lView[T_HOST] = parentTNode;\n  applyView(tView, lView, renderer, WalkTNodeTreeAction.Insert, parentNativeNode, beforeNode);\n}\n\n\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nexport function renderDetachView(tView: TView, lView: LView) {\n  applyView(tView, lView, lView[RENDERER], WalkTNodeTreeAction.Detach, null, null);\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  // If the view has no children, we can clean it up and return early.\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView[TVIEW], rootView);\n  }\n\n  while (lViewOrLContainer) {\n    let next: LView|LContainer|null = null;\n\n    if (isLView(lViewOrLContainer)) {\n      // If LView, traverse down to child.\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer);\n      // If container, traverse down to its first LView.\n      const firstView: LView|undefined = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n\n    if (!next) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (lViewOrLContainer && !lViewOrLContainer![NEXT] && lViewOrLContainer !== rootView) {\n        if (isLView(lViewOrLContainer)) {\n          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n        }\n        lViewOrLContainer = lViewOrLContainer[PARENT];\n      }\n      if (lViewOrLContainer === null) lViewOrLContainer = rootView;\n      if (isLView(lViewOrLContainer)) {\n        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n      }\n      next = lViewOrLContainer && lViewOrLContainer![NEXT];\n    }\n    lViewOrLContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nexport function insertView(tView: TView, lView: LView, lContainer: LContainer, index: number) {\n  ngDevMode && assertLView(lView);\n  ngDevMode && assertLContainer(lContainer);\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const containerLength = lContainer.length;\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    lContainer[indexInContainer - 1][NEXT] = lView;\n  }\n  if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n    lView[NEXT] = lContainer[indexInContainer];\n    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n  } else {\n    lContainer.push(lView);\n    lView[NEXT] = null;\n  }\n\n  lView[PARENT] = lContainer;\n\n  // track views where declaration and insertion points are different\n  const declarationLContainer = lView[DECLARATION_LCONTAINER];\n  if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n    trackMovedView(declarationLContainer, lView);\n  }\n\n  // notify query that a new view has been added\n  const lQueries = lView[QUERIES];\n  if (lQueries !== null) {\n    lQueries.insertView(tView);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n}\n\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertDefined(lView, 'LView required');\n  ngDevMode && assertLContainer(declarationContainer);\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const insertedLContainer = lView[PARENT] as LContainer;\n  ngDevMode && assertLContainer(insertedLContainer);\n  const insertedComponentLView = insertedLContainer[PARENT]![DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n  const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n  if (declaredComponentLView !== insertedComponentLView) {\n    // At this point the declaration-component is not same as insertion-component; this means that\n    // this is a transplanted view. Mark the declared lView as having transplanted views so that\n    // those views can participate in CD.\n    declarationContainer[HAS_TRANSPLANTED_VIEWS] = true;\n  }\n  if (movedViews === null) {\n    declarationContainer[MOVED_VIEWS] = [lView];\n  } else {\n    movedViews.push(lView);\n  }\n}\n\nfunction detachMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode &&\n      assertDefined(\n          declarationContainer[MOVED_VIEWS],\n          'A projected view should belong to a non-empty projected views collection');\n  const movedViews = declarationContainer[MOVED_VIEWS]!;\n  const declarationViewIndex = movedViews.indexOf(lView);\n  const insertionLContainer = lView[PARENT] as LContainer;\n  ngDevMode && assertLContainer(insertionLContainer);\n\n  // If the view was marked for refresh but then detached before it was checked (where the flag\n  // would be cleared and the counter decremented), we need to decrement the view counter here\n  // instead.\n  if (lView[FLAGS] & LViewFlags.RefreshTransplantedView) {\n    lView[FLAGS] &= ~LViewFlags.RefreshTransplantedView;\n    updateTransplantedViewCount(insertionLContainer, -1);\n  }\n\n  movedViews.splice(declarationViewIndex, 1);\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nexport function detachView(lContainer: LContainer, removeIndex: number): LView|undefined {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n\n  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n  const viewToDetach = lContainer[indexInContainer];\n\n  if (viewToDetach) {\n    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n      detachMovedView(declarationLContainer, viewToDetach);\n    }\n\n\n    if (removeIndex > 0) {\n      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT] as LView;\n    }\n    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n    removeViewFromContainer(viewToDetach[TVIEW], viewToDetach);\n\n    // notify query that a view has been removed\n    const lQueries = removedLView[QUERIES];\n    if (lQueries !== null) {\n      lQueries.detachView(removedLView[TVIEW]);\n    }\n\n    viewToDetach[PARENT] = null;\n    viewToDetach[NEXT] = null;\n    // Unsets the attached flag\n    viewToDetach[FLAGS] &= ~LViewFlags.Attached;\n  }\n  return viewToDetach;\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nexport function destroyLView(tView: TView, lView: LView) {\n  if (!(lView[FLAGS] & LViewFlags.Destroyed)) {\n    const renderer = lView[RENDERER];\n    if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n      applyView(tView, lView, renderer, WalkTNodeTreeAction.Destroy, null, null);\n    }\n\n    destroyViewTree(lView);\n  }\n}\n\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView: TView, lView: LView): void {\n  if (!(lView[FLAGS] & LViewFlags.Destroyed)) {\n    // Usually the Attached flag is removed when the view is detached from its parent, however\n    // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n    lView[FLAGS] &= ~LViewFlags.Attached;\n\n    // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n    // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n    // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n    // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n    // really more of an \"afterDestroy\" hook if you think about it.\n    lView[FLAGS] |= LViewFlags.Destroyed;\n\n    executeOnDestroys(tView, lView);\n    processCleanups(tView, lView);\n    // For component views only, the local renderer is destroyed at clean up time.\n    if (lView[TVIEW].type === TViewType.Component && isProceduralRenderer(lView[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      (lView[RENDERER] as ProceduralRenderer3).destroy();\n    }\n\n    const declarationContainer = lView[DECLARATION_LCONTAINER];\n    // we are dealing with an embedded view that is still inserted into a container\n    if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n      // and this is a projected view\n      if (declarationContainer !== lView[PARENT]) {\n        detachMovedView(declarationContainer, lView);\n      }\n\n      // For embedded views still attached to a container: remove query result from this view.\n      const lQueries = lView[QUERIES];\n      if (lQueries !== null) {\n        lQueries.detachView(tView);\n      }\n    }\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction processCleanups(tView: TView, lView: LView): void {\n  const tCleanup = tView.cleanup;\n  const lCleanup = lView[CLEANUP]!;\n  // `LCleanup` contains both share information with `TCleanup` as well as instance specific\n  // information appended at the end. We need to know where the end of the `TCleanup` information\n  // is, and we track this with `lastLCleanupIndex`.\n  let lastLCleanupIndex = -1;\n  if (tCleanup !== null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a native DOM listener\n        const idxOrTargetGetter = tCleanup[i + 1];\n        const target = typeof idxOrTargetGetter === 'function' ?\n            idxOrTargetGetter(lView) :\n            unwrapRNode(lView[idxOrTargetGetter]);\n        const listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]];\n        const useCaptureOrSubIdx = tCleanup[i + 3];\n        if (typeof useCaptureOrSubIdx === 'boolean') {\n          // native DOM listener registered with Renderer3\n          target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n        } else {\n          if (useCaptureOrSubIdx >= 0) {\n            // unregister\n            lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]();\n          } else {\n            // Subscription\n            lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe();\n          }\n        }\n        i += 2;\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n    if (lCleanup !== null) {\n      for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {\n        const instanceCleanupFn = lCleanup[i];\n        ngDevMode && assertFunction(instanceCleanupFn, 'Expecting instance cleanup function.');\n        instanceCleanupFn();\n      }\n    }\n    lView[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView: TView, lView: LView): void {\n  let destroyHooks: DestroyHookData|null;\n\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context = lView[destroyHooks[i] as number];\n\n      // Only call the destroy hook if the context has been requested.\n      if (!(context instanceof NodeInjectorFactory)) {\n        const toCall = destroyHooks[i + 1] as HookFn | HookData;\n\n        if (Array.isArray(toCall)) {\n          for (let j = 0; j < toCall.length; j += 2) {\n            (toCall[j + 1] as HookFn).call(context[toCall[j] as number]);\n          }\n        } else {\n          toCall.call(context);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve render parent.\n * @param lView: Current `LView`.\n */\nexport function getParentRElement(tView: TView, tNode: TNode, lView: LView): RElement|null {\n  return getClosestRElement(tView, tNode.parent, lView);\n}\n\n/**\n * Get closest `RElement` or `null` if it can't be found.\n *\n * If `TNode` is `TNodeType.Element` => return `RElement` at `LView[tNode.index]` location.\n * If `TNode` is `TNodeType.ElementContainer|IcuContain` => return the parent (recursively).\n * If `TNode` is `null` then return host `RElement`:\n *   - return `null` if projection\n *   - return `null` if parent container is disconnected (we have no parent.)\n *\n * @param tView: Current `TView`.\n * @param tNode: `TNode` for which we wish to retrieve `RElement` (or `null` if host element is\n *     needed).\n * @param lView: Current `LView`.\n * @returns `null` if the `RElement` can't be determined at this time (no parent / projection)\n */\nexport function getClosestRElement(tView: TView, tNode: TNode|null, lView: LView): RElement|null {\n  let parentTNode: TNode|null = tNode;\n  // Skip over element and ICU containers as those are represented by a comment node and\n  // can't be used as a render parent.\n  while (parentTNode !== null &&\n         (parentTNode.type & (TNodeType.ElementContainer | TNodeType.Icu))) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  }\n\n  // If the parent tNode is null, then we are inserting across views: either into an embedded view\n  // or a component view.\n  if (parentTNode === null) {\n    // We are inserting a root element of the component view into the component host element and\n    // it should always be eager.\n    return lView[HOST];\n  } else {\n    ngDevMode && assertTNodeType(parentTNode, TNodeType.AnyRNode | TNodeType.Container);\n    if (parentTNode.flags & TNodeFlags.isComponentHost) {\n      ngDevMode && assertTNodeForLView(parentTNode, lView);\n      const encapsulation =\n          (tView.data[parentTNode.directiveStart] as ComponentDef<unknown>).encapsulation;\n      // We've got a parent which is an element in the current view. We just need to verify if the\n      // parent element is not a component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since the projection would then move it to its final destination. Note that we can't\n      // make this assumption when using the Shadow DOM, because the native projection placeholders\n      // (<content> or <slot>) have to be in place as elements are being inserted.\n      if (encapsulation === ViewEncapsulation.None ||\n          encapsulation === ViewEncapsulation.Emulated) {\n        return null;\n      }\n    }\n\n    return getNativeByTNode(parentTNode, lView) as RElement;\n  }\n}\n\n/**\n * Inserts a native node before another native node for a given parent using {@link Renderer3}.\n * This is a utility function that can be used when native nodes were determined - it abstracts an\n * actual renderer being used.\n */\nexport function nativeInsertBefore(\n    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode|null,\n    isMove: boolean): void {\n  ngDevMode && ngDevMode.rendererInsertBefore++;\n  if (isProceduralRenderer(renderer)) {\n    renderer.insertBefore(parent, child, beforeNode, isMove);\n  } else {\n    parent.insertBefore(child, beforeNode, isMove);\n  }\n}\n\nfunction nativeAppendChild(renderer: Renderer3, parent: RElement, child: RNode): void {\n  ngDevMode && ngDevMode.rendererAppendChild++;\n  ngDevMode && assertDefined(parent, 'parent node must be defined');\n  if (isProceduralRenderer(renderer)) {\n    renderer.appendChild(parent, child);\n  } else {\n    parent.appendChild(child);\n  }\n}\n\nfunction nativeAppendOrInsertBefore(\n    renderer: Renderer3, parent: RElement, child: RNode, beforeNode: RNode|null, isMove: boolean) {\n  if (beforeNode !== null) {\n    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n  } else {\n    nativeAppendChild(renderer, parent, child);\n  }\n}\n\n/** Removes a node from the DOM given its native parent. */\nfunction nativeRemoveChild(\n    renderer: Renderer3, parent: RElement, child: RNode, isHostElement?: boolean): void {\n  if (isProceduralRenderer(renderer)) {\n    renderer.removeChild(parent, child, isHostElement);\n  } else {\n    parent.removeChild(child);\n  }\n}\n\n/**\n * Returns a native parent of a given native node.\n */\nexport function nativeParentNode(renderer: Renderer3, node: RNode): RElement|null {\n  return (isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode) as RElement;\n}\n\n/**\n * Returns a native sibling of a given native node.\n */\nexport function nativeNextSibling(renderer: Renderer3, node: RNode): RNode|null {\n  return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;\n}\n\n/**\n * Find a node in front of which `currentTNode` should be inserted.\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * takes `TNode.insertBeforeIndex` into account if i18n code has been invoked.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nfunction getInsertInFrontOfRNode(parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|\n    null {\n  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\n\n\n/**\n * Find a node in front of which `currentTNode` should be inserted. (Does not take i18n into\n * account)\n *\n * This method determines the `RNode` in front of which we should insert the `currentRNode`. This\n * does not take `TNode.insertBeforeIndex` into account.\n *\n * @param parentTNode parent `TNode`\n * @param currentTNode current `TNode` (The node which we would like to insert into the DOM)\n * @param lView current `LView`\n */\nexport function getInsertInFrontOfRNodeWithNoI18n(\n    parentTNode: TNode, currentTNode: TNode, lView: LView): RNode|null {\n  if (parentTNode.type & (TNodeType.ElementContainer | TNodeType.Icu)) {\n    return getNativeByTNode(parentTNode, lView);\n  }\n  return null;\n}\n\n/**\n * Tree shakable boundary for `getInsertInFrontOfRNodeWithI18n` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _getInsertInFrontOfRNodeWithI18n: (parentTNode: TNode, currentTNode: TNode, lView: LView) =>\n    RNode | null = getInsertInFrontOfRNodeWithNoI18n;\n\n/**\n * Tree shakable boundary for `processI18nInsertBefore` function.\n *\n * This function will only be set if i18n code runs.\n */\nlet _processI18nInsertBefore: (\n    renderer: Renderer3, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n    parentRElement: RElement|null) => void;\n\nexport function setI18nHandling(\n    getInsertInFrontOfRNodeWithI18n: (parentTNode: TNode, currentTNode: TNode, lView: LView) =>\n        RNode | null,\n    processI18nInsertBefore: (\n        renderer: Renderer3, childTNode: TNode, lView: LView, childRNode: RNode|RNode[],\n        parentRElement: RElement|null) => void) {\n  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n;\n  _processI18nInsertBefore = processI18nInsertBefore;\n}\n\n/**\n * Appends the `child` native node (or a collection of nodes) to the `parent`.\n *\n * @param tView The `TView' to be appended\n * @param lView The current LView\n * @param childRNode The native child (or children) that should be appended\n * @param childTNode The TNode of the child element\n */\nexport function appendChild(\n    tView: TView, lView: LView, childRNode: RNode|RNode[], childTNode: TNode): void {\n  const parentRNode = getParentRElement(tView, childTNode, lView);\n  const renderer = lView[RENDERER];\n  const parentTNode: TNode = childTNode.parent || lView[T_HOST]!;\n  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n  if (parentRNode != null) {\n    if (Array.isArray(childRNode)) {\n      for (let i = 0; i < childRNode.length; i++) {\n        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n      }\n    } else {\n      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n    }\n  }\n\n  _processI18nInsertBefore !== undefined &&\n      _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\n\n/**\n * Returns the first native node for a given LView, starting from the provided TNode.\n *\n * Native nodes are returned in the order in which those appear in the native tree (DOM).\n */\nfunction getFirstNativeNode(lView: LView, tNode: TNode|null): RNode|null {\n  if (tNode !== null) {\n    ngDevMode &&\n        assertTNodeType(\n            tNode,\n            TNodeType.AnyRNode | TNodeType.AnyContainer | TNodeType.Icu | TNodeType.Projection);\n\n    const tNodeType = tNode.type;\n    if (tNodeType & TNodeType.AnyRNode) {\n      return getNativeByTNode(tNode, lView);\n    } else if (tNodeType & TNodeType.Container) {\n      return getBeforeNodeForView(-1, lView[tNode.index]);\n    } else if (tNodeType & TNodeType.ElementContainer) {\n      const elIcuContainerChild = tNode.child;\n      if (elIcuContainerChild !== null) {\n        return getFirstNativeNode(lView, elIcuContainerChild);\n      } else {\n        const rNodeOrLContainer = lView[tNode.index];\n        if (isLContainer(rNodeOrLContainer)) {\n          return getBeforeNodeForView(-1, rNodeOrLContainer);\n        } else {\n          return unwrapRNode(rNodeOrLContainer);\n        }\n      }\n    } else if (tNodeType & TNodeType.Icu) {\n      let nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n      let rNode: RNode|null = nextRNode();\n      // If the ICU container has no nodes, than we use the ICU anchor as the node.\n      return rNode || unwrapRNode(lView[tNode.index]);\n    } else {\n      const componentView = lView[DECLARATION_COMPONENT_VIEW];\n      const componentHost = componentView[T_HOST] as TElementNode;\n      const parentView = getLViewParent(componentView);\n      const firstProjectedTNode: TNode|null =\n          (componentHost.projection as (TNode | null)[])[tNode.projection as number];\n\n      if (firstProjectedTNode != null) {\n        return getFirstNativeNode(parentView!, firstProjectedTNode);\n      } else {\n        return getFirstNativeNode(lView, tNode.next);\n      }\n    }\n  }\n\n  return null;\n}\n\nexport function getBeforeNodeForView(viewIndexInContainer: number, lContainer: LContainer): RNode|\n    null {\n  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n  if (nextViewIndex < lContainer.length) {\n    const lView = lContainer[nextViewIndex] as LView;\n    const firstTNodeOfView = lView[TVIEW].firstChild;\n    if (firstTNodeOfView !== null) {\n      return getFirstNativeNode(lView, firstTNodeOfView);\n    }\n  }\n\n  return lContainer[NATIVE];\n}\n\n/**\n * Removes a native node itself using a given renderer. To remove the node we are looking up its\n * parent from the native tree as not all platforms / browsers support the equivalent of\n * node.remove().\n *\n * @param renderer A renderer to be used\n * @param rNode The native node that should be removed\n * @param isHostElement A flag indicating if a node to be removed is a host of a component.\n */\nexport function nativeRemoveNode(renderer: Renderer3, rNode: RNode, isHostElement?: boolean): void {\n  ngDevMode && ngDevMode.rendererRemoveNode++;\n  const nativeParent = nativeParentNode(renderer, rNode);\n  if (nativeParent) {\n    nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);\n  }\n}\n\n\n/**\n * Performs the operation of `action` on the node. Typically this involves inserting or removing\n * nodes on the LView or projection boundary.\n */\nfunction applyNodes(\n    renderer: Renderer3, action: WalkTNodeTreeAction, tNode: TNode|null, lView: LView,\n    parentRElement: RElement|null, beforeNode: RNode|null, isProjection: boolean) {\n  while (tNode != null) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    ngDevMode &&\n        assertTNodeType(\n            tNode,\n            TNodeType.AnyRNode | TNodeType.AnyContainer | TNodeType.Projection | TNodeType.Icu);\n    const rawSlotValue = lView[tNode.index];\n    const tNodeType = tNode.type;\n    if (isProjection) {\n      if (action === WalkTNodeTreeAction.Create) {\n        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n        tNode.flags |= TNodeFlags.isProjected;\n      }\n    }\n    if ((tNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n      if (tNodeType & TNodeType.ElementContainer) {\n        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & TNodeType.Icu) {\n        const nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n        let rNode: RNode|null;\n        while (rNode = nextRNode()) {\n          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & TNodeType.Projection) {\n        applyProjectionRecursive(\n            renderer, action, lView, tNode as TProjectionNode, parentRElement, beforeNode);\n      } else {\n        ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode | TNodeType.Container);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n}\n\n\n/**\n * `applyView` performs operation on the view as specified in `action` (insert, detach, destroy)\n *\n * Inserting a view without projection or containers at top level is simple. Just iterate over the\n * root nodes of the View, and for each node perform the `action`.\n *\n * Things get more complicated with containers and projections. That is because coming across:\n * - Container: implies that we have to insert/remove/destroy the views of that container as well\n *              which in turn can have their own Containers at the View roots.\n * - Projection: implies that we have to insert/remove/destroy the nodes of the projection. The\n *               complication is that the nodes we are projecting can themselves have Containers\n *               or other Projections.\n *\n * As you can see this is a very recursive problem. Yes recursion is not most efficient but the\n * code is complicated enough that trying to implemented with recursion becomes unmaintainable.\n *\n * @param tView The `TView' which needs to be inserted, detached, destroyed\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param parentRElement parent DOM element for insertion (Removal does not need it).\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyView(\n    tView: TView, lView: LView, renderer: Renderer3, action: WalkTNodeTreeAction.Destroy,\n    parentRElement: null, beforeNode: null): void;\nfunction applyView(\n    tView: TView, lView: LView, renderer: Renderer3, action: WalkTNodeTreeAction,\n    parentRElement: RElement|null, beforeNode: RNode|null): void;\nfunction applyView(\n    tView: TView, lView: LView, renderer: Renderer3, action: WalkTNodeTreeAction,\n    parentRElement: RElement|null, beforeNode: RNode|null): void {\n  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\n\n/**\n * `applyProjection` performs operation on the projection.\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param tView The `TView` of `LView` which needs to be inserted, detached, destroyed\n * @param lView The `LView` which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n */\nexport function applyProjection(tView: TView, lView: LView, tProjectionNode: TProjectionNode) {\n  const renderer = lView[RENDERER];\n  const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n  const parentTNode = tProjectionNode.parent || lView[T_HOST]!;\n  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n  applyProjectionRecursive(\n      renderer, WalkTNodeTreeAction.Create, lView, tProjectionNode, parentRNode, beforeNode);\n}\n\n/**\n * `applyProjectionRecursive` performs operation on the projection specified by `action` (insert,\n * detach, destroy)\n *\n * Inserting a projection requires us to locate the projected nodes from the parent component. The\n * complication is that those nodes themselves could be re-projected from their parent component.\n *\n * @param renderer Render to use\n * @param action action to perform (insert, detach, destroy)\n * @param lView The LView which needs to be inserted, detached, destroyed.\n * @param tProjectionNode node to project\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyProjectionRecursive(\n    renderer: Renderer3, action: WalkTNodeTreeAction, lView: LView,\n    tProjectionNode: TProjectionNode, parentRElement: RElement|null, beforeNode: RNode|null) {\n  const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n  const componentNode = componentLView[T_HOST] as TElementNode;\n  ngDevMode &&\n      assertEqual(typeof tProjectionNode.projection, 'number', 'expecting projection index');\n  const nodeToProjectOrRNodes = componentNode.projection![tProjectionNode.projection]!;\n  if (Array.isArray(nodeToProjectOrRNodes)) {\n    // This should not exist, it is a bit of a hack. When we bootstrap a top level node and we\n    // need to support passing projectable nodes, so we cheat and put them in the TNode\n    // of the Host TView. (Yes we put instance info at the T Level). We can get away with it\n    // because we know that that TView is not shared and therefore it will not be a problem.\n    // This should be refactored and cleaned up.\n    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n      const rNode = nodeToProjectOrRNodes[i];\n      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n    }\n  } else {\n    let nodeToProject: TNode|null = nodeToProjectOrRNodes;\n    const projectedComponentLView = componentLView[PARENT] as LView;\n    applyNodes(\n        renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n  }\n}\n\n\n/**\n * `applyContainer` performs an operation on the container and its views as specified by\n * `action` (insert, detach, destroy)\n *\n * Inserting a Container is complicated by the fact that the container may have Views which\n * themselves have containers or projections.\n *\n * @param renderer Renderer to use\n * @param action action to perform (insert, detach, destroy)\n * @param lContainer The LContainer which needs to be inserted, detached, destroyed.\n * @param parentRElement parent DOM element for insertion/removal.\n * @param beforeNode Before which node the insertions should happen.\n */\nfunction applyContainer(\n    renderer: Renderer3, action: WalkTNodeTreeAction, lContainer: LContainer,\n    parentRElement: RElement|null, beforeNode: RNode|null|undefined) {\n  ngDevMode && assertLContainer(lContainer);\n  const anchor = lContainer[NATIVE];  // LContainer has its own before node.\n  const native = unwrapRNode(lContainer);\n  // An LContainer can be created dynamically on any node by injecting ViewContainerRef.\n  // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor\n  // node (comment in the DOM) that will be different from the LContainer's host node. In this\n  // particular case we need to execute action on 2 nodes:\n  // - container's host node (this is done in the executeActionOnElementOrContainer)\n  // - container's host node (this is done here)\n  if (anchor !== native) {\n    // This is very strange to me (Misko). I would expect that the native is same as anchor. I\n    // don't see a reason why they should be different, but they are.\n    //\n    // If they are we need to process the second anchor as well.\n    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n  }\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lView = lContainer[i] as LView;\n    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n  }\n}\n\n/**\n * Writes class/style to element.\n *\n * @param renderer Renderer to use.\n * @param isClassBased `true` if it should be written to `class` (`false` to write to `style`)\n * @param rNode The Node to write to.\n * @param prop Property to write to. This would be the class/style name.\n * @param value Value to write. If `null`/`undefined`/`false` this is considered a remove (set/add\n *        otherwise).\n */\nexport function applyStyling(\n    renderer: Renderer3, isClassBased: boolean, rNode: RElement, prop: string, value: any) {\n  const isProcedural = isProceduralRenderer(renderer);\n  if (isClassBased) {\n    // We actually want JS true/false here because any truthy value should add the class\n    if (!value) {\n      ngDevMode && ngDevMode.rendererRemoveClass++;\n      if (isProcedural) {\n        (renderer as Renderer2).removeClass(rNode, prop);\n      } else {\n        (rNode as HTMLElement).classList.remove(prop);\n      }\n    } else {\n      ngDevMode && ngDevMode.rendererAddClass++;\n      if (isProcedural) {\n        (renderer as Renderer2).addClass(rNode, prop);\n      } else {\n        ngDevMode && assertDefined((rNode as HTMLElement).classList, 'HTMLElement expected');\n        (rNode as HTMLElement).classList.add(prop);\n      }\n    }\n  } else {\n    let flags = prop.indexOf('-') === -1 ? undefined : RendererStyleFlags2.DashCase as number;\n    if (value == null /** || value === undefined */) {\n      ngDevMode && ngDevMode.rendererRemoveStyle++;\n      if (isProcedural) {\n        (renderer as Renderer2).removeStyle(rNode, prop, flags);\n      } else {\n        (rNode as HTMLElement).style.removeProperty(prop);\n      }\n    } else {\n      // A value is important if it ends with `!important`. The style\n      // parser strips any semicolons at the end of the value.\n      const isImportant = typeof value === 'string' ? value.endsWith('!important') : false;\n\n      if (isImportant) {\n        // !important has to be stripped from the value for it to be valid.\n        value = value.slice(0, -10);\n        flags! |= RendererStyleFlags2.Important;\n      }\n\n      ngDevMode && ngDevMode.rendererSetStyle++;\n      if (isProcedural) {\n        (renderer as Renderer2).setStyle(rNode, prop, value, flags);\n      } else {\n        ngDevMode && assertDefined((rNode as HTMLElement).style, 'HTMLElement expected');\n        (rNode as HTMLElement).style.setProperty(prop, value, isImportant ? 'important' : '');\n      }\n    }\n  }\n}\n\n\n/**\n * Write `cssText` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nexport function writeDirectStyle(renderer: Renderer3, element: RElement, newValue: string) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n  if (isProceduralRenderer(renderer)) {\n    renderer.setAttribute(element, 'style', newValue);\n  } else {\n    (element as HTMLElement).style.cssText = newValue;\n  }\n  ngDevMode && ngDevMode.rendererSetStyle++;\n}\n\n/**\n * Write `className` to `RElement`.\n *\n * This function does direct write without any reconciliation. Used for writing initial values, so\n * that static styling values do not pull in the style parser.\n *\n * @param renderer Renderer to use\n * @param element The element which needs to be updated.\n * @param newValue The new class list to write.\n */\nexport function writeDirectClass(renderer: Renderer3, element: RElement, newValue: string) {\n  ngDevMode && assertString(newValue, '\\'newValue\\' should be a string');\n  if (isProceduralRenderer(renderer)) {\n    if (newValue === '') {\n      // There are tests in `google3` which expect `element.getAttribute('class')` to be `null`.\n      renderer.removeAttribute(element, 'class');\n    } else {\n      renderer.setAttribute(element, 'class', newValue);\n    }\n  } else {\n    element.className = newValue;\n  }\n  ngDevMode && ngDevMode.rendererSetClassName++;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertNotEqual} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\n\n\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\nexport function classIndexOf(\n    className: string, classToSearch: string, startingIndex: number): number {\n  ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n  let end = className.length;\n  while (true) {\n    const foundIndex = className.indexOf(classToSearch, startingIndex);\n    if (foundIndex === -1) return foundIndex;\n    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= CharCode.SPACE) {\n      // Ensure that it has leading whitespace\n      const length = classToSearch.length;\n      if (foundIndex + length === end ||\n          className.charCodeAt(foundIndex + length) <= CharCode.SPACE) {\n        // Ensure that it has trailing whitespace\n        return foundIndex;\n      }\n    }\n    // False positive, keep searching from where we left off.\n    startingIndex = foundIndex + 1;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {assertDefined, assertEqual, assertNotEqual} from '../util/assert';\n\nimport {AttributeMarker, TAttributes, TNode, TNodeType, unusedValueExportToPlacateAjd as unused1} from './interfaces/node';\nimport {CssSelector, CssSelectorList, SelectorFlags, unusedValueExportToPlacateAjd as unused2} from './interfaces/projection';\nimport {classIndexOf} from './styling/class_differ';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\n\nconst unusedValueToPlacateAjd = unused1 + unused2;\n\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(\n    attrs: TAttributes, cssClassToMatch: string, isProjectionMode: boolean): boolean {\n  // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n  // It is strange to me that sometimes the class information comes in form of `class` attribute\n  // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n  // if that is the right behavior.\n  ngDevMode &&\n      assertEqual(\n          cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n  let i = 0;\n  while (i < attrs.length) {\n    let item = attrs[i++];\n    if (isProjectionMode && item === 'class') {\n      item = attrs[i] as string;\n      if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {\n        return true;\n      }\n    } else if (item === AttributeMarker.Classes) {\n      // We found the classes section. Start searching for the class.\n      while (i < attrs.length && typeof (item = attrs[i++]) == 'string') {\n        // while we have strings\n        if (item.toLowerCase() === cssClassToMatch) return true;\n      }\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks whether the `tNode` represents an inline template (e.g. `*ngFor`).\n *\n * @param tNode current TNode\n */\nexport function isInlineTemplate(tNode: TNode): boolean {\n  return tNode.type === TNodeType.Container && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\n\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(\n    tNode: TNode, currentSelector: string, isProjectionMode: boolean): boolean {\n  const tagNameToCompare =\n      tNode.type === TNodeType.Container && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n  return currentSelector === tagNameToCompare;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSelector(\n    tNode: TNode, selector: CssSelector, isProjectionMode: boolean): boolean {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n  let mode: SelectorFlags = SelectorFlags.ELEMENT;\n  const nodeAttrs = tNode.attrs || [];\n\n  // Find the index of first attribute that has no value, only a name.\n  const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = (current as number) | (mode & SelectorFlags.NOT);\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & SelectorFlags.ELEMENT) {\n      mode = SelectorFlags.ATTRIBUTE | mode & SelectorFlags.NOT;\n      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||\n          current === '' && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = mode & SelectorFlags.CLASS ? current : selector[++i];\n\n      // special case for matching against classes when a tNode has been instantiated with\n      // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n      if ((mode & SelectorFlags.CLASS) && tNode.attrs !== null) {\n        if (!isCssClassMatching(tNode.attrs, selectorAttrValue as string, isProjectionMode)) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n        continue;\n      }\n\n      const attrName = (mode & SelectorFlags.CLASS) ? 'class' : current;\n      const attrIndexInNode =\n          findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue: string;\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode &&\n              assertNotEqual(\n                  nodeAttrs[attrIndexInNode], AttributeMarker.NamespaceURI,\n                  'We do not match directives on namespaced attributes');\n          // we lowercase the attribute value to be able to match\n          // selectors without case-sensitivity\n          // (selectors are already in lowercase when generated)\n          nodeAttrValue = (nodeAttrs[attrIndexInNode + 1] as string).toLowerCase();\n        }\n\n        const compareAgainstClassName = mode & SelectorFlags.CLASS ? nodeAttrValue : null;\n        if (compareAgainstClassName &&\n                classIndexOf(compareAgainstClassName, selectorAttrValue as string, 0) !== -1 ||\n            mode & SelectorFlags.ATTRIBUTE && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode: SelectorFlags): boolean {\n  return (mode & SelectorFlags.NOT) === 0;\n}\n\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(\n    name: string, attrs: TAttributes|null, isInlineTemplate: boolean,\n    isProjectionMode: boolean): number {\n  if (attrs === null) return -1;\n\n  let i = 0;\n\n  if (isProjectionMode || !isInlineTemplate) {\n    let bindingsMode = false;\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n      if (maybeAttrName === name) {\n        return i;\n      } else if (\n          maybeAttrName === AttributeMarker.Bindings || maybeAttrName === AttributeMarker.I18n) {\n        bindingsMode = true;\n      } else if (\n          maybeAttrName === AttributeMarker.Classes || maybeAttrName === AttributeMarker.Styles) {\n        let value = attrs[++i];\n        // We should skip classes here because we have a separate mechanism for\n        // matching classes in projection mode.\n        while (typeof value === 'string') {\n          value = attrs[++i];\n        }\n        continue;\n      } else if (maybeAttrName === AttributeMarker.Template) {\n        // We do not care about Template attributes in this scenario.\n        break;\n      } else if (maybeAttrName === AttributeMarker.NamespaceURI) {\n        // Skip the whole namespaced attribute and value. This is by design.\n        i += 4;\n        continue;\n      }\n      // In binding mode there are only names, rather than name-value pairs.\n      i += bindingsMode ? 1 : 2;\n    }\n    // We did not match the attribute\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\n\nexport function isNodeMatchingSelectorList(\n    tNode: TNode, selector: CssSelectorList, isProjectionMode: boolean = false): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): CssSelector|null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(AttributeMarker.ProjectAs);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1] as CssSelector;\n    }\n  }\n  return null;\n}\n\nfunction getNameOnlyMarkerIndex(nodeAttrs: TAttributes) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n  return nodeAttrs.length;\n}\n\nfunction matchTemplateAttribute(attrs: TAttributes, name: string): number {\n  let i = attrs.indexOf(AttributeMarker.Template);\n  if (i > -1) {\n    i++;\n    while (i < attrs.length) {\n      const attr = attrs[i];\n      // Return in case we checked all template attrs and are switching to the next section in the\n      // attrs array (that starts with a number that represents an attribute marker).\n      if (typeof attr === 'number') return -1;\n      if (attr === name) return i;\n      i++;\n    }\n  }\n  return -1;\n}\n\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nexport function isSelectorInSelectorList(selector: CssSelector, list: CssSelectorList): boolean {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction maybeWrapInNotSelector(isNegativeMode: boolean, chunk: string): string {\n  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\n\nfunction stringifyCSSSelector(selector: CssSelector): string {\n  let result = selector[0] as string;\n  let i = 1;\n  let mode = SelectorFlags.ATTRIBUTE;\n  let currentChunk = '';\n  let isNegativeMode = false;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode & SelectorFlags.ATTRIBUTE) {\n        const attrValue = selector[++i] as string;\n        currentChunk +=\n            '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n      } else if (mode & SelectorFlags.CLASS) {\n        currentChunk += '.' + valueOrMarker;\n      } else if (mode & SelectorFlags.ELEMENT) {\n        currentChunk += ' ' + valueOrMarker;\n      }\n    } else {\n      //\n      // Append current chunk to the final result in case we come across SelectorFlag, which\n      // indicates that the previous section of a selector is over. We need to accumulate content\n      // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n      // ```\n      //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n      // ```\n      // should be transformed to `.classA :not(.classB .classC)`.\n      //\n      // Note: for negative selector part, we accumulate content between flags until we find the\n      // next negative flag. This is needed to support a case where `:not()` rule contains more than\n      // one chunk, e.g. the following selector:\n      // ```\n      //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n      // ```\n      // should be stringified to `:not(p.foo) :not(.bar)`\n      //\n      if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n        currentChunk = '';\n      }\n      mode = valueOrMarker;\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector.\n      isNegativeMode = isNegativeMode || !isPositive(mode);\n    }\n    i++;\n  }\n  if (currentChunk !== '') {\n    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n  }\n  return result;\n}\n\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nexport function stringifyCSSSelectorList(selectorList: CssSelectorList): string {\n  return selectorList.map(stringifyCSSSelector).join(',');\n}\n\n/**\n * Extracts attributes and classes information from a given CSS selector.\n *\n * This function is used while creating a component dynamically. In this case, the host element\n * (that is created dynamically) should contain attributes and classes specified in component's CSS\n * selector.\n *\n * @param selector CSS selector in parsed form (in a form of array)\n * @returns object with `attrs` and `classes` fields that contain extracted information\n */\nexport function extractAttrsAndClassesFromSelector(selector: CssSelector):\n    {attrs: string[], classes: string[]} {\n  const attrs: string[] = [];\n  const classes: string[] = [];\n  let i = 1;\n  let mode = SelectorFlags.ATTRIBUTE;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode === SelectorFlags.ATTRIBUTE) {\n        if (valueOrMarker !== '') {\n          attrs.push(valueOrMarker, selector[++i] as string);\n        }\n      } else if (mode === SelectorFlags.CLASS) {\n        classes.push(valueOrMarker);\n      }\n    } else {\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector. Since attributes and classes are\n      // extracted only for \"positive\" part of the selector, we can stop here.\n      if (!isPositive(mode)) break;\n      mode = valueOrMarker;\n    }\n    i++;\n  }\n  return {attrs, classes};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  __brand__: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE: NO_CHANGE =\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? {__brand__: 'NO_CHANGE'} : ({} as NO_CHANGE);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertGreaterThan} from '../../util/assert';\nimport {assertIndexInDeclRange} from '../assert';\nimport {executeCheckHooks, executeInitAndCheckHooks} from '../hooks';\nimport {FLAGS, InitPhaseState, LView, LViewFlags, TView} from '../interfaces/view';\nimport {getLView, getSelectedIndex, getTView, isInCheckNoChangesMode, setSelectedIndex} from '../state';\n\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n *   if (rf & 1) {\n *     text(0, 'Hello');\n *     text(1, 'Goodbye')\n *     element(2, 'div');\n *   }\n *   if (rf & 2) {\n *     advance(2); // Advance twice to the <div>.\n *     property('title', 'test');\n *   }\n *  }\n * ```\n * @param delta Number of elements to advance forwards by.\n *\n * @codeGenApi\n */\nexport function ɵɵadvance(delta: number): void {\n  ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, isInCheckNoChangesMode());\n}\n\nexport function selectIndexInternal(\n    tView: TView, lView: LView, index: number, checkNoChangesMode: boolean) {\n  ngDevMode && assertIndexInDeclRange(lView, index);\n\n  // Flush the initial hooks for elements in the view that have been added up to this point.\n  // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n  if (!checkNoChangesMode) {\n    const hooksInitPhaseCompleted =\n        (lView[FLAGS] & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = tView.preOrderCheckHooks;\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, index);\n      }\n    } else {\n      const preOrderHooks = tView.preOrderHooks;\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, index);\n      }\n    }\n  }\n\n  // We must set the selected index *after* running the hooks, because hooks may have side-effects\n  // that cause other template functions to run, thus updating the selected index, which is global\n  // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n  // will be altered by the time we leave the `ɵɵadvance` instruction.\n  setSelectedIndex(index);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {KeyValueArray} from '../../util/array_utils';\nimport {assertNumber, assertNumberInRange} from '../../util/assert';\n\n/**\n * Value stored in the `TData` which is needed to re-concatenate the styling.\n *\n * See: `TStylingKeyPrimitive` and `TStylingStatic`\n */\nexport type TStylingKey = TStylingKeyPrimitive|TStylingStatic;\n\n\n/**\n * The primitive portion (`TStylingStatic` removed) of the value stored in the `TData` which is\n * needed to re-concatenate the styling.\n *\n * - `string`: Stores the property name. Used with `ɵɵstyleProp`/`ɵɵclassProp` instruction.\n * - `null`: Represents map, so there is no name. Used with `ɵɵstyleMap`/`ɵɵclassMap`.\n * - `false`: Represents an ignore case. This happens when `ɵɵstyleProp`/`ɵɵclassProp` instruction\n *   is combined with directive which shadows its input `@Input('class')`. That way the binding\n *   should not participate in the styling resolution.\n */\nexport type TStylingKeyPrimitive = string|null|false;\n\n/**\n * Store the static values for the styling binding.\n *\n * The `TStylingStatic` is just `KeyValueArray` where key `\"\"` (stored at location 0) contains the\n * `TStylingKey` (stored at location 1). In other words this wraps the `TStylingKey` such that the\n * `\"\"` contains the wrapped value.\n *\n * When instructions are resolving styling they may need to look forward or backwards in the linked\n * list to resolve the value. For this reason we have to make sure that he linked list also contains\n * the static values. However the list only has space for one item per styling instruction. For this\n * reason we store the static values here as part of the `TStylingKey`. This means that the\n * resolution function when looking for a value needs to first look at the binding value, and than\n * at `TStylingKey` (if it exists).\n *\n * Imagine we have:\n *\n * ```\n * <div class=\"TEMPLATE\" my-dir>\n *\n * @Directive({\n *   host: {\n *     class: 'DIR',\n *     '[class.dynamic]': 'exp' // ɵɵclassProp('dynamic', ctx.exp);\n *   }\n * })\n * ```\n *\n * In the above case the linked list will contain one item:\n *\n * ```\n *   // assume binding location: 10 for `ɵɵclassProp('dynamic', ctx.exp);`\n *   tData[10] = <TStylingStatic>[\n *     '': 'dynamic', // This is the wrapped value of `TStylingKey`\n *     'DIR': true,   // This is the default static value of directive binding.\n *   ];\n *   tData[10 + 1] = 0; // We don't have prev/next.\n *\n *   lView[10] = undefined;     // assume `ctx.exp` is `undefined`\n *   lView[10 + 1] = undefined; // Just normalized `lView[10]`\n * ```\n *\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into the static `TStylingStatic` too see if there is a default value for\n * `dynamic` (there is not). Therefore it is safe to remove it.\n *\n * If setting `true` case:\n * ```\n *   lView[10] = true;     // assume `ctx.exp` is `true`\n *   lView[10 + 1] = true; // Just normalized `lView[10]`\n * ```\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into `TNode.residualClass` (TNode.residualStyle) which contains\n * ```\n *   tNode.residualClass = [\n *     'TEMPLATE': true,\n *   ];\n * ```\n *\n * This means that it is safe to add class.\n */\nexport interface TStylingStatic extends KeyValueArray<any> {}\n\n/**\n * This is a branded number which contains previous and next index.\n *\n * When we come across styling instructions we need to store the `TStylingKey` in the correct\n * order so that we can re-concatenate the styling value in the desired priority.\n *\n * The insertion can happen either at the:\n * - end of template as in the case of coming across additional styling instruction in the template\n * - in front of the template in the case of coming across additional instruction in the\n *   `hostBindings`.\n *\n * We use `TStylingRange` to store the previous and next index into the `TData` where the template\n * bindings can be found.\n *\n * - bit 0 is used to mark that the previous index has a duplicate for current value.\n * - bit 1 is used to mark that the next index has a duplicate for the current value.\n * - bits 2-16 are used to encode the next/tail of the template.\n * - bits 17-32 are used to encode the previous/head of template.\n *\n * NODE: *duplicate* false implies that it is statically known that this binding will not collide\n * with other bindings and therefore there is no need to check other bindings. For example the\n * bindings in `<div [style.color]=\"exp\" [style.width]=\"exp\">` will never collide and will have\n * their bits set accordingly. Previous duplicate means that we may need to check previous if the\n * current binding is `null`. Next duplicate means that we may need to check next bindings if the\n * current binding is not `null`.\n *\n * NOTE: `0` has special significance and represents `null` as in no additional pointer.\n */\nexport interface TStylingRange {\n  __brand__: 'TStylingRange';\n}\n\n/**\n * Shift and masks constants for encoding two numbers into and duplicate info into a single number.\n */\nexport const enum StylingRange {\n  /// Number of bits to shift for the previous pointer\n  PREV_SHIFT = 17,\n  /// Previous pointer mask.\n  PREV_MASK = 0xFFFE0000,\n\n  /// Number of bits to shift for the next pointer\n  NEXT_SHIFT = 2,\n  /// Next pointer mask.\n  NEXT_MASK = 0x001FFFC,\n\n  // Mask to remove nagative bit. (interpret number as positive)\n  UNSIGNED_MASK = 0x7FFF,\n\n  /**\n   * This bit is set if the previous bindings contains a binding which could possibly cause a\n   * duplicate. For example: `<div [style]=\"map\" [style.width]=\"width\">`, the `width` binding will\n   * have previous duplicate set. The implication is that if `width` binding becomes `null`, it is\n   * necessary to defer the value to `map.width`. (Because `width` overwrites `map.width`.)\n   */\n  PREV_DUPLICATE = 0x02,\n\n  /**\n   * This bit is set to if the next binding contains a binding which could possibly cause a\n   * duplicate. For example: `<div [style]=\"map\" [style.width]=\"width\">`, the `map` binding will\n   * have next duplicate set. The implication is that if `map.width` binding becomes not `null`, it\n   * is necessary to defer the value to `width`. (Because `width` overwrites `map.width`.)\n   */\n  NEXT_DUPLICATE = 0x01,\n}\n\n\nexport function toTStylingRange(prev: number, next: number): TStylingRange {\n  ngDevMode && assertNumberInRange(prev, 0, StylingRange.UNSIGNED_MASK);\n  ngDevMode && assertNumberInRange(next, 0, StylingRange.UNSIGNED_MASK);\n  return (prev << StylingRange.PREV_SHIFT | next << StylingRange.NEXT_SHIFT) as any;\n}\n\nexport function getTStylingRangePrev(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) >> StylingRange.PREV_SHIFT) & StylingRange.UNSIGNED_MASK;\n}\n\nexport function getTStylingRangePrevDuplicate(tStylingRange: TStylingRange): boolean {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.PREV_DUPLICATE) ==\n      StylingRange.PREV_DUPLICATE;\n}\n\nexport function setTStylingRangePrev(\n    tStylingRange: TStylingRange, previous: number): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(previous, 0, StylingRange.UNSIGNED_MASK);\n  return (((tStylingRange as any as number) & ~StylingRange.PREV_MASK) |\n          (previous << StylingRange.PREV_SHIFT)) as any;\n}\n\nexport function setTStylingRangePrevDuplicate(tStylingRange: TStylingRange): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) | StylingRange.PREV_DUPLICATE) as any;\n}\n\nexport function getTStylingRangeNext(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.NEXT_MASK) >> StylingRange.NEXT_SHIFT;\n}\n\nexport function setTStylingRangeNext(tStylingRange: TStylingRange, next: number): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(next, 0, StylingRange.UNSIGNED_MASK);\n  return (((tStylingRange as any as number) & ~StylingRange.NEXT_MASK) |  //\n          next << StylingRange.NEXT_SHIFT) as any;\n}\n\nexport function getTStylingRangeNextDuplicate(tStylingRange: TStylingRange): boolean {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.NEXT_DUPLICATE) ===\n      StylingRange.NEXT_DUPLICATE;\n}\n\nexport function setTStylingRangeNextDuplicate(tStylingRange: TStylingRange): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) | StylingRange.NEXT_DUPLICATE) as any;\n}\n\nexport function getTStylingRangeTail(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  const next = getTStylingRangeNext(tStylingRange);\n  return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Injector} from '../../di';\nimport {ErrorHandler} from '../../error_handler';\nimport {DoCheck, OnChanges, OnInit} from '../../interface/lifecycle_hooks';\nimport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from '../../metadata/schema';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {validateAgainstEventAttributes, validateAgainstEventProperties} from '../../sanitization/sanitization';\nimport {Sanitizer} from '../../sanitization/sanitizer';\nimport {assertDefined, assertDomNode, assertEqual, assertGreaterThanOrEqual, assertIndexInRange, assertNotEqual, assertNotSame, assertSame, assertString} from '../../util/assert';\nimport {createNamedArrayType} from '../../util/named_array_type';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {normalizeDebugBindingName, normalizeDebugBindingValue} from '../../util/ng_reflect';\nimport {stringify} from '../../util/stringify';\nimport {assertFirstCreatePass, assertFirstUpdatePass, assertLContainer, assertLView, assertTNodeForLView, assertTNodeForTView} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {getFactoryDef} from '../definition_factory';\nimport {diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode} from '../di';\nimport {formatRuntimeError, RuntimeError, RuntimeErrorCode} from '../error_code';\nimport {throwMultipleComponentError} from '../errors';\nimport {executeCheckHooks, executeInitAndCheckHooks, incrementInitPhaseFlags} from '../hooks';\nimport {CONTAINER_HEADER_OFFSET, HAS_TRANSPLANTED_VIEWS, LContainer, MOVED_VIEWS} from '../interfaces/container';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, HostBindingsFunction, PipeDefListOrFactory, RenderFlags, ViewQueriesFunction} from '../interfaces/definition';\nimport {NodeInjectorFactory} from '../interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliases, PropertyAliasValue, TAttributes, TConstantsOrFactory, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeType, TProjectionNode} from '../interfaces/node';\nimport {isProceduralRenderer, Renderer3, RendererFactory3} from '../interfaces/renderer';\nimport {RComment, RElement, RNode, RText} from '../interfaces/renderer_dom';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {isComponentDef, isComponentHost, isContentQueryHost, isRootView} from '../interfaces/type_checks';\nimport {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, HostBindingOpCodes, InitPhaseState, INJECTOR, LView, LViewFlags, NEXT, PARENT, RENDERER, RENDERER_FACTORY, RootContext, RootContextFlags, SANITIZER, T_HOST, TData, TRANSPLANTED_VIEWS_TO_REFRESH, TVIEW, TView, TViewType} from '../interfaces/view';\nimport {assertPureTNodeType, assertTNodeType} from '../node_assert';\nimport {updateTextNode} from '../node_manipulation';\nimport {isInlineTemplate, isNodeMatchingSelectorList} from '../node_selector_matcher';\nimport {enterView, getBindingsEnabled, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentTNode, getCurrentTNodePlaceholderOk, getSelectedIndex, isCurrentTNodeParent, isInCheckNoChangesMode, isInI18nBlock, leaveView, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setIsInCheckNoChangesMode, setSelectedIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {isAnimationProp, mergeHostAttrs} from '../util/attrs_utils';\nimport {INTERPOLATION_DELIMITER} from '../util/misc_utils';\nimport {renderStringify, stringifyForError} from '../util/stringify_utils';\nimport {getFirstLContainer, getLViewParent, getNextLContainer} from '../util/view_traversal_utils';\nimport {getComponentLViewByIndex, getNativeByIndex, getNativeByTNode, isCreationMode, readPatchedLView, resetPreOrderHookFlags, unwrapLView, updateTransplantedViewCount, viewAttachedToChangeDetector} from '../util/view_utils';\n\nimport {selectIndexInternal} from './advance';\nimport {attachLContainerDebug, attachLViewDebug, cloneToLViewFromTViewBlueprint, cloneToTViewData, LCleanup, LViewBlueprint, MatchesArray, TCleanup, TNodeDebug, TNodeInitialInputs, TNodeLocalNames, TViewComponents, TViewConstructor} from './lview_debug';\n\n\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = (() => Promise.resolve(null))();\n\n/**\n * Invoke `HostBindingsFunction`s for view.\n *\n * This methods executes `TView.hostBindingOpCodes`. It is used to execute the\n * `HostBindingsFunction`s associated with the current `LView`.\n *\n * @param tView Current `TView`.\n * @param lView Current `LView`.\n */\nexport function processHostBindingOpCodes(tView: TView, lView: LView): void {\n  const hostBindingOpCodes = tView.hostBindingOpCodes;\n  if (hostBindingOpCodes === null) return;\n  try {\n    for (let i = 0; i < hostBindingOpCodes.length; i++) {\n      const opCode = hostBindingOpCodes[i] as number;\n      if (opCode < 0) {\n        // Negative numbers are element indexes.\n        setSelectedIndex(~opCode);\n      } else {\n        // Positive numbers are NumberTuple which store bindingRootIndex and directiveIndex.\n        const directiveIdx = opCode;\n        const bindingRootIndx = hostBindingOpCodes[++i] as number;\n        const hostBindingFn = hostBindingOpCodes[++i] as HostBindingsFunction<any>;\n        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n        const context = lView[directiveIdx];\n        hostBindingFn(RenderFlags.Update, context);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n  }\n}\n\n\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView: TView, lView: LView): void {\n  const contentQueries = tView.contentQueries;\n  if (contentQueries !== null) {\n    for (let i = 0; i < contentQueries.length; i += 2) {\n      const queryStartIdx = contentQueries[i];\n      const directiveDefIdx = contentQueries[i + 1];\n      if (directiveDefIdx !== -1) {\n        const directiveDef = tView.data[directiveDefIdx] as DirectiveDef<any>;\n        ngDevMode && assertDefined(directiveDef, 'DirectiveDef not found.');\n        ngDevMode &&\n            assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n        setCurrentQueryIndex(queryStartIdx);\n        directiveDef.contentQueries!(RenderFlags.Update, lView[directiveDefIdx], directiveDefIdx);\n      }\n    }\n  }\n}\n\n/** Refreshes child components in the current view (update mode). */\nfunction refreshChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    refreshComponent(hostLView, components[i]);\n  }\n}\n\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent(hostLView, components[i]);\n  }\n}\n\nexport function createLView<T>(\n    parentLView: LView|null, tView: TView, context: T|null, flags: LViewFlags, host: RElement|null,\n    tHostNode: TNode|null, rendererFactory: RendererFactory3|null, renderer: Renderer3|null,\n    sanitizer: Sanitizer|null, injector: Injector|null): LView {\n  const lView =\n      ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice() as LView;\n  lView[HOST] = host;\n  lView[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.FirstLViewPass;\n  resetPreOrderHookFlags(lView);\n  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY])!;\n  ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n  lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER])!;\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null!;\n  lView[INJECTOR as any] = injector || parentLView && parentLView[INJECTOR] || null;\n  lView[T_HOST] = tHostNode;\n  ngDevMode &&\n      assertEqual(\n          tView.type == TViewType.Embedded ? parentLView !== null : true, true,\n          'Embedded views must have parentLView');\n  lView[DECLARATION_COMPONENT_VIEW] =\n      tView.type == TViewType.Embedded ? parentLView![DECLARATION_COMPONENT_VIEW] : lView;\n  ngDevMode && attachLViewDebug(lView);\n  return lView;\n}\n\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param tView The current `TView`.\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.Element|TNodeType.Text, name: string|null,\n    attrs: TAttributes|null): TElementNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.Container, name: string|null,\n    attrs: TAttributes|null): TContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.Projection, name: null,\n    attrs: TAttributes|null): TProjectionNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.ElementContainer, name: string|null,\n    attrs: TAttributes|null): TElementContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType.Icu, name: null,\n    attrs: TAttributes|null): TElementContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, index: number, type: TNodeType, name: string|null, attrs: TAttributes|null):\n    TElementNode&TContainerNode&TElementContainerNode&TProjectionNode&TIcuContainerNode {\n  ngDevMode && index !== 0 &&  // 0 are bogus nodes and they are OK. See `createContainerRef` in\n                               // `view_engine_compatibility` for additional context.\n      assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  // Keep this function short, so that the VM will inline it.\n  ngDevMode && assertPureTNodeType(type);\n  let tNode = tView.data[index] as TNode;\n  if (tNode === null) {\n    tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n    if (isInI18nBlock()) {\n      // If we are in i18n block then all elements should be pre declared through `Placeholder`\n      // See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n      // If the `TNode` was not pre-declared than it means it was not mentioned which means it was\n      // removed, so we mark it as detached.\n      tNode.flags |= TNodeFlags.isDetached;\n    }\n  } else if (tNode.type & TNodeType.Placeholder) {\n    tNode.type = type;\n    tNode.value = name;\n    tNode.attrs = attrs;\n    const parent = getCurrentParentTNode();\n    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n    ngDevMode && assertTNodeForTView(tNode, tView);\n    ngDevMode && assertEqual(index, tNode.index, 'Expecting same index');\n  }\n  setCurrentTNode(tNode, true);\n  return tNode as TElementNode & TContainerNode & TElementContainerNode & TProjectionNode &\n      TIcuContainerNode;\n}\n\nexport function createTNodeAtIndex(\n    tView: TView, index: number, type: TNodeType, name: string|null, attrs: TAttributes|null) {\n  const currentTNode = getCurrentTNodePlaceholderOk();\n  const isParent = isCurrentTNodeParent();\n  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n  // Parents cannot cross component boundaries because components will be used in multiple places.\n  const tNode = tView.data[index] =\n      createTNode(tView, parent as TElementNode | TContainerNode, type, index, name, attrs);\n  // Assign a pointer to the first child node of a given view. The first node is not always the one\n  // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n  // the index 1 or more, so we can't just check node index.\n  if (tView.firstChild === null) {\n    tView.firstChild = tNode;\n  }\n  if (currentTNode !== null) {\n    if (isParent) {\n      // FIXME(misko): This logic looks unnecessarily complicated. Could we simplify?\n      if (currentTNode.child == null && tNode.parent !== null) {\n        // We are in the same view, which means we are adding content node to the parent view.\n        currentTNode.child = tNode;\n      }\n    } else {\n      if (currentTNode.next === null) {\n        // In the case of i18n the `currentTNode` may already be linked, in which case we don't want\n        // to break the links which i18n created.\n        currentTNode.next = tNode;\n      }\n    }\n  }\n  return tNode;\n}\n\n\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply()), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param lView The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n * @param initialValue Initial value to store in blueprint\n */\nexport function allocExpando(\n    tView: TView, lView: LView, numSlotsToAlloc: number, initialValue: any): number {\n  if (numSlotsToAlloc === 0) return -1;\n  if (ngDevMode) {\n    assertFirstCreatePass(tView);\n    assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n    assertEqual(tView.data.length, lView.length, 'Expecting LView to be same size as TView');\n    assertEqual(\n        tView.data.length, tView.blueprint.length, 'Expecting Blueprint to be same size as TView');\n    assertFirstUpdatePass(tView);\n  }\n  const allocIdx = lView.length;\n  for (let i = 0; i < numSlotsToAlloc; i++) {\n    lView.push(initialValue);\n    tView.blueprint.push(initialValue);\n    tView.data.push(null);\n  }\n  return allocIdx;\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nexport function renderView<T>(tView: TView, lView: LView, context: T): void {\n  ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n  enterView(lView);\n  try {\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(RenderFlags.Create, viewQuery, context);\n    }\n\n    // Execute a template associated with this view, if it exists. A template function might not be\n    // defined for the root component views.\n    const templateFn = tView.template;\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, RenderFlags.Create, context);\n    }\n\n    // This needs to be set before children are processed to support recursive components.\n    // This must be set to false immediately after the first creation run because in an\n    // ngFor loop, all the views will be created together before update mode runs and turns\n    // off firstCreatePass. If we don't set it here, instances will perform directive\n    // matching, etc again and again.\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    }\n\n    // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n    // content queries are resolved during change detection (i.e. update mode), after embedded\n    // views are refreshed (see block above).\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // We must materialize query results before child components are processed\n    // in case a child component has projected a container. The LContainer needs\n    // to exist so the embedded views are properly attached by the container.\n    if (tView.staticViewQueries) {\n      executeViewQueryFn(RenderFlags.Update, tView.viewQuery!, context);\n    }\n\n    // Render child component views.\n    const components = tView.components;\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n\n  } catch (error) {\n    // If we didn't manage to get past the first template pass due to\n    // an error, mark the view as corrupted so we can try to recover.\n    if (tView.firstCreatePass) {\n      tView.incompleteFirstPass = true;\n    }\n\n    throw error;\n  } finally {\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n    leaveView();\n  }\n}\n\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nexport function refreshView<T>(\n    tView: TView, lView: LView, templateFn: ComponentTemplate<{}>|null, context: T) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n  const flags = lView[FLAGS];\n  if ((flags & LViewFlags.Destroyed) === LViewFlags.Destroyed) return;\n  enterView(lView);\n  // Check no changes mode is a dev only mode used to verify that bindings have not changed\n  // since they were assigned. We do not want to execute lifecycle hooks in that mode.\n  const isInCheckNoChangesPass = isInCheckNoChangesMode();\n  try {\n    resetPreOrderHookFlags(lView);\n\n    setBindingIndex(tView.bindingStartIndex);\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, RenderFlags.Update, context);\n    }\n\n    const hooksInitPhaseCompleted =\n        (flags & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n\n    // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, null);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.OnInitHooksToBeRun);\n      }\n    }\n\n    // First mark transplanted views that are declared in this lView as needing a refresh at their\n    // insertion points. This is needed to avoid the situation where the template is defined in this\n    // `LView` but its declaration appears after the insertion component.\n    markTransplantedViewsForRefresh(lView);\n    refreshEmbeddedViews(lView);\n\n    // Content query results must be refreshed before content hooks are called.\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // execute content hooks (AfterContentInit, AfterContentChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(\n              lView, contentHooks, InitPhaseState.AfterContentInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterContentInitHooksToBeRun);\n      }\n    }\n\n    processHostBindingOpCodes(tView, lView);\n\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n      refreshChildComponents(lView, components);\n    }\n\n    // View queries must execute after refreshing child components because a template in this view\n    // could be inserted in a child component. If the view query executes before child component\n    // refresh, the template might not yet be inserted.\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(RenderFlags.Update, viewQuery, context);\n    }\n\n    // execute view hooks (AfterViewInit, AfterViewChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(lView, viewHooks, InitPhaseState.AfterViewInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterViewInitHooksToBeRun);\n      }\n    }\n    if (tView.firstUpdatePass === true) {\n      // We need to make sure that we only flip the flag on successful `refreshView` only\n      // Don't do this in `finally` block.\n      // If we did this in `finally` block then an exception could block the execution of styling\n      // instructions which in turn would be unable to insert themselves into the styling linked\n      // list. The result of this would be that if the exception would not be throw on subsequent CD\n      // the styling would be unable to process it data and reflect to the DOM.\n      tView.firstUpdatePass = false;\n    }\n\n    // Do not reset the dirty state when running in check no changes mode. We don't want components\n    // to behave differently depending on whether check no changes is enabled or not. For example:\n    // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n    // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n    // no changes cycle, the component would be not be dirty for the next update pass. This would\n    // be different in production mode where the component dirty state is not reset.\n    if (!isInCheckNoChangesPass) {\n      lView[FLAGS] &= ~(LViewFlags.Dirty | LViewFlags.FirstLViewPass);\n    }\n    if (lView[FLAGS] & LViewFlags.RefreshTransplantedView) {\n      lView[FLAGS] &= ~LViewFlags.RefreshTransplantedView;\n      updateTransplantedViewCount(lView[PARENT] as LContainer, -1);\n    }\n  } finally {\n    leaveView();\n  }\n}\n\nexport function renderComponentOrTemplate<T>(\n    tView: TView, lView: LView, templateFn: ComponentTemplate<{}>|null, context: T) {\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const normalExecutionPath = !isInCheckNoChangesMode();\n  const creationModeIsActive = isCreationMode(lView);\n  try {\n    if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (creationModeIsActive) {\n      renderView(tView, lView, context);\n    }\n    refreshView(tView, lView, templateFn, context);\n  } finally {\n    if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {\n      rendererFactory.end();\n    }\n  }\n}\n\nfunction executeTemplate<T>(\n    tView: TView, lView: LView, templateFn: ComponentTemplate<T>, rf: RenderFlags, context: T) {\n  const prevSelectedIndex = getSelectedIndex();\n  try {\n    setSelectedIndex(-1);\n    if (rf & RenderFlags.Update && lView.length > HEADER_OFFSET) {\n      // When we're updating, inherently select 0 so we don't\n      // have to generate that instruction for most update blocks.\n      selectIndexInternal(tView, lView, HEADER_OFFSET, isInCheckNoChangesMode());\n    }\n    templateFn(rf, context);\n  } finally {\n    setSelectedIndex(prevSelectedIndex);\n  }\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\nexport function executeContentQueries(tView: TView, tNode: TNode, lView: LView) {\n  if (isContentQueryHost(tNode)) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n      const def = tView.data[directiveIndex] as DirectiveDef<any>;\n      if (def.contentQueries) {\n        def.contentQueries(RenderFlags.Create, lView[directiveIndex], directiveIndex);\n      }\n    }\n  }\n}\n\n\n/**\n * Creates directive instances.\n */\nexport function createDirectivesInstances(tView: TView, lView: LView, tNode: TDirectiveHostNode) {\n  if (!getBindingsEnabled()) return;\n  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n  if ((tNode.flags & TNodeFlags.hasHostBindings) === TNodeFlags.hasHostBindings) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nexport function saveResolvedLocalsInData(\n    viewData: LView, tNode: TDirectiveHostNode,\n    localRefExtractor: LocalRefExtractor = getNativeByTNode): void {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ?\n          localRefExtractor(\n              tNode as TElementNode | TContainerNode | TElementContainerNode, viewData) :\n          viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nexport function getOrCreateTComponentView(def: ComponentDef<any>): TView {\n  const tView = def.tView;\n\n  // Create a TView if there isn't one, or recreate it if the first create pass didn't\n  // complete successfully since we can't know for sure whether it's in a usable shape.\n  if (tView === null || tView.incompleteFirstPass) {\n    // Declaration node here is null since this function is called when we dynamically create a\n    // component and hence there is no declaration.\n    const declTNode = null;\n    return def.tView = createTView(\n               TViewType.Component, declTNode, def.template, def.decls, def.vars, def.directiveDefs,\n               def.pipeDefs, def.viewQuery, def.schemas, def.consts);\n  }\n\n  return tView;\n}\n\n\n/**\n * Creates a TView instance\n *\n * @param type Type of `TView`.\n * @param declTNode Declaration location of this `TView`.\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nexport function createTView(\n    type: TViewType, declTNode: TNode|null, templateFn: ComponentTemplate<any>|null, decls: number,\n    vars: number, directives: DirectiveDefListOrFactory|null, pipes: PipeDefListOrFactory|null,\n    viewQuery: ViewQueriesFunction<any>|null, schemas: SchemaMetadata[]|null,\n    constsOrFactory: TConstantsOrFactory|null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + decls;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  const consts = typeof constsOrFactory === 'function' ? constsOrFactory() : constsOrFactory;\n  const tView = blueprint[TVIEW as any] = ngDevMode ?\n      new TViewConstructor(\n          type,        // type: TViewType,\n          blueprint,   // blueprint: LView,\n          templateFn,  // template: ComponentTemplate<{}>|null,\n          null,        // queries: TQueries|null\n          viewQuery,   // viewQuery: ViewQueriesFunction<{}>|null,\n          declTNode,   // declTNode: TNode|null,\n          cloneToTViewData(blueprint).fill(null, bindingStartIndex),  // data: TData,\n          bindingStartIndex,                                          // bindingStartIndex: number,\n          initialViewLength,                                          // expandoStartIndex: number,\n          null,                               // hostBindingOpCodes: HostBindingOpCodes,\n          true,                               // firstCreatePass: boolean,\n          true,                               // firstUpdatePass: boolean,\n          false,                              // staticViewQueries: boolean,\n          false,                              // staticContentQueries: boolean,\n          null,                               // preOrderHooks: HookData|null,\n          null,                               // preOrderCheckHooks: HookData|null,\n          null,                               // contentHooks: HookData|null,\n          null,                               // contentCheckHooks: HookData|null,\n          null,                               // viewHooks: HookData|null,\n          null,                               // viewCheckHooks: HookData|null,\n          null,                               // destroyHooks: DestroyHookData|null,\n          null,                               // cleanup: any[]|null,\n          null,                               // contentQueries: number[]|null,\n          null,                               // components: number[]|null,\n          typeof directives === 'function' ?  //\n              directives() :                  //\n              directives,                     // directiveRegistry: DirectiveDefList|null,\n          typeof pipes === 'function' ? pipes() : pipes,  // pipeRegistry: PipeDefList|null,\n          null,                                           // firstChild: TNode|null,\n          schemas,                                        // schemas: SchemaMetadata[]|null,\n          consts,                                         // consts: TConstants|null\n          false,                                          // incompleteFirstPass: boolean\n          decls,                                          // ngDevMode only: decls\n          vars,                                           // ngDevMode only: vars\n          ) :\n      {\n        type: type,\n        blueprint: blueprint,\n        template: templateFn,\n        queries: null,\n        viewQuery: viewQuery,\n        declTNode: declTNode,\n        data: blueprint.slice().fill(null, bindingStartIndex),\n        bindingStartIndex: bindingStartIndex,\n        expandoStartIndex: initialViewLength,\n        hostBindingOpCodes: null,\n        firstCreatePass: true,\n        firstUpdatePass: true,\n        staticViewQueries: false,\n        staticContentQueries: false,\n        preOrderHooks: null,\n        preOrderCheckHooks: null,\n        contentHooks: null,\n        contentCheckHooks: null,\n        viewHooks: null,\n        viewCheckHooks: null,\n        destroyHooks: null,\n        cleanup: null,\n        contentQueries: null,\n        components: null,\n        directiveRegistry: typeof directives === 'function' ? directives() : directives,\n        pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n        firstChild: null,\n        schemas: schemas,\n        consts: consts,\n        incompleteFirstPass: false\n      };\n  if (ngDevMode) {\n    // For performance reasons it is important that the tView retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tView);\n  }\n  return tView;\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LView {\n  const blueprint = ngDevMode ? new LViewBlueprint() : [];\n\n  for (let i = 0; i < initialViewLength; i++) {\n    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n  }\n\n  return blueprint as LView;\n}\n\nfunction createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);\n}\n\nfunction assertHostNodeExists(rElement: RElement, elementOrSelector: RElement|string) {\n  if (!rElement) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n}\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param rendererFactory Factory function to create renderer instance.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n */\nexport function locateHostElement(\n    renderer: Renderer3, elementOrSelector: RElement|string,\n    encapsulation: ViewEncapsulation): RElement {\n  if (isProceduralRenderer(renderer)) {\n    // When using native Shadow DOM, do not clear host element to allow native slot projection\n    const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;\n    return renderer.selectRootElement(elementOrSelector, preserveContent);\n  }\n\n  let rElement = typeof elementOrSelector === 'string' ?\n      renderer.querySelector(elementOrSelector)! :\n      elementOrSelector;\n  ngDevMode && assertHostNodeExists(rElement, elementOrSelector);\n\n  // Always clear host element's content when Renderer3 is in use. For procedural renderer case we\n  // make it depend on whether ShadowDom encapsulation is used (in which case the content should be\n  // preserved to allow native slot projection). ShadowDom encapsulation requires procedural\n  // renderer, and procedural renderer case is handled above.\n  rElement.textContent = '';\n\n  return rElement;\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n *\n * This function can also be used to store instance specific cleanup fns. In that case the `context`\n * is `null` and the function is store in `LView` (rather than it `TView`).\n */\nexport function storeCleanupWithContext(\n    tView: TView, lView: LView, context: any, cleanupFn: Function): void {\n  const lCleanup = getLCleanup(lView);\n  if (context === null) {\n    // If context is null that this is instance specific callback. These callbacks can only be\n    // inserted after template shared instances. For this reason in ngDevMode we freeze the TView.\n    if (ngDevMode) {\n      Object.freeze(getTViewCleanup(tView));\n    }\n    lCleanup.push(cleanupFn);\n  } else {\n    lCleanup.push(context);\n\n    if (tView.firstCreatePass) {\n      getTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n    }\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param tView `TView` to which this `TNode` belongs (used only in `ngDevMode`)\n * @param tParent Parent `TNode`\n * @param type The type of the node\n * @param index The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.Container,\n    index: number, tagName: string|null, attrs: TAttributes|null): TContainerNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.Element|TNodeType.Text,\n    index: number, tagName: string|null, attrs: TAttributes|null): TElementNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.ElementContainer,\n    index: number, tagName: string|null, attrs: TAttributes|null): TElementContainerNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.Icu, index: number,\n    tagName: string|null, attrs: TAttributes|null): TIcuContainerNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType.Projection,\n    index: number, tagName: string|null, attrs: TAttributes|null): TProjectionNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType, index: number,\n    tagName: string|null, attrs: TAttributes|null): TNode;\nexport function createTNode(\n    tView: TView, tParent: TElementNode|TContainerNode|null, type: TNodeType, index: number,\n    value: string|null, attrs: TAttributes|null): TNode {\n  ngDevMode && index !== 0 &&  // 0 are bogus nodes and they are OK. See `createContainerRef` in\n                               // `view_engine_compatibility` for additional context.\n      assertGreaterThanOrEqual(index, HEADER_OFFSET, 'TNodes can\\'t be in the LView header.');\n  ngDevMode && assertNotSame(attrs, undefined, '\\'undefined\\' is not valid value for \\'attrs\\'');\n  ngDevMode && ngDevMode.tNode++;\n  ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n  let injectorIndex = tParent ? tParent.injectorIndex : -1;\n  const tNode = ngDevMode ?\n      new TNodeDebug(\n          tView,          // tView_: TView\n          type,           // type: TNodeType\n          index,          // index: number\n          null,           // insertBeforeIndex: null|-1|number|number[]\n          injectorIndex,  // injectorIndex: number\n          -1,             // directiveStart: number\n          -1,             // directiveEnd: number\n          -1,             // directiveStylingLast: number\n          null,           // propertyBindings: number[]|null\n          0,              // flags: TNodeFlags\n          0,              // providerIndexes: TNodeProviderIndexes\n          value,          // value: string|null\n          attrs,          // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null\n          null,           // mergedAttrs\n          null,           // localNames: (string|number)[]|null\n          undefined,      // initialInputs: (string[]|null)[]|null|undefined\n          null,           // inputs: PropertyAliases|null\n          null,           // outputs: PropertyAliases|null\n          null,           // tViews: ITView|ITView[]|null\n          null,           // next: ITNode|null\n          null,           // projectionNext: ITNode|null\n          null,           // child: ITNode|null\n          tParent,        // parent: TElementNode|TContainerNode|null\n          null,           // projection: number|(ITNode|RNode[])[]|null\n          null,           // styles: string|null\n          null,           // stylesWithoutHost: string|null\n          undefined,      // residualStyles: string|null\n          null,           // classes: string|null\n          null,           // classesWithoutHost: string|null\n          undefined,      // residualClasses: string|null\n          0 as any,       // classBindings: TStylingRange;\n          0 as any,       // styleBindings: TStylingRange;\n          ) :\n      {\n        type,\n        index,\n        insertBeforeIndex: null,\n        injectorIndex,\n        directiveStart: -1,\n        directiveEnd: -1,\n        directiveStylingLast: -1,\n        propertyBindings: null,\n        flags: 0,\n        providerIndexes: 0,\n        value: value,\n        attrs: attrs,\n        mergedAttrs: null,\n        localNames: null,\n        initialInputs: undefined,\n        inputs: null,\n        outputs: null,\n        tViews: null,\n        next: null,\n        projectionNext: null,\n        child: null,\n        parent: tParent,\n        projection: null,\n        styles: null,\n        stylesWithoutHost: null,\n        residualStyles: undefined,\n        classes: null,\n        classesWithoutHost: null,\n        residualClasses: undefined,\n        classBindings: 0 as any,\n        styleBindings: 0 as any,\n      };\n  if (ngDevMode) {\n    // For performance reasons it is important that the tNode retains the same shape during runtime.\n    // (To make sure that all of the code is monomorphic.) For this reason we seal the object to\n    // prevent class transitions.\n    Object.seal(tNode);\n  }\n  return tNode;\n}\n\n\nfunction generatePropertyAliases(\n    inputAliasMap: {[publicName: string]: string}, directiveDefIdx: number,\n    propStore: PropertyAliases|null): PropertyAliases|null {\n  for (let publicName in inputAliasMap) {\n    if (inputAliasMap.hasOwnProperty(publicName)) {\n      propStore = propStore === null ? {} : propStore;\n      const internalName = inputAliasMap[publicName];\n\n      if (propStore.hasOwnProperty(publicName)) {\n        propStore[publicName].push(directiveDefIdx, internalName);\n      } else {\n        (propStore[publicName] = [directiveDefIdx, internalName]);\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Initializes data structures required to work with directive inputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nfunction initializeInputAndOutputAliases(tView: TView, tNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const tViewData = tView.data;\n\n  const tNodeAttrs = tNode.attrs;\n  const inputsFromAttrs: InitialInputData = ngDevMode ? new TNodeInitialInputs() : [];\n  let inputsStore: PropertyAliases|null = null;\n  let outputsStore: PropertyAliases|null = null;\n  for (let i = start; i < end; i++) {\n    const directiveDef = tViewData[i] as DirectiveDef<any>;\n    const directiveInputs = directiveDef.inputs;\n    // Do not use unbound attributes as inputs to structural directives, since structural\n    // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n    // TODO(FW-1930): microsyntax expressions may also contain unbound/static attributes, which\n    // should be set for inline templates.\n    const initialInputs = (tNodeAttrs !== null && !isInlineTemplate(tNode)) ?\n        generateInitialInputs(directiveInputs, tNodeAttrs) :\n        null;\n    inputsFromAttrs.push(initialInputs);\n    inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);\n    outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);\n  }\n\n  if (inputsStore !== null) {\n    if (inputsStore.hasOwnProperty('class')) {\n      tNode.flags |= TNodeFlags.hasClassInput;\n    }\n    if (inputsStore.hasOwnProperty('style')) {\n      tNode.flags |= TNodeFlags.hasStyleInput;\n    }\n  }\n\n  tNode.initialInputs = inputsFromAttrs;\n  tNode.inputs = inputsStore;\n  tNode.outputs = outputsStore;\n}\n\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name: string): string {\n  if (name === 'class') return 'className';\n  if (name === 'for') return 'htmlFor';\n  if (name === 'formaction') return 'formAction';\n  if (name === 'innerHtml') return 'innerHTML';\n  if (name === 'readonly') return 'readOnly';\n  if (name === 'tabindex') return 'tabIndex';\n  return name;\n}\n\nexport function elementPropertyInternal<T>(\n    tView: TView, tNode: TNode, lView: LView, propName: string, value: T, renderer: Renderer3,\n    sanitizer: SanitizerFn|null|undefined, nativeOnly: boolean): void {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n  const element = getNativeByTNode(tNode, lView) as RElement | RComment;\n  let inputData = tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n    setInputsForProperty(tView, lView, dataValue, propName, value);\n    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, tNode.index);\n    if (ngDevMode) {\n      setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n    }\n  } else if (tNode.type & TNodeType.AnyRNode) {\n    propName = mapPropName(propName);\n\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n      if (!validateProperty(tView, element, propName, tNode)) {\n        // Return here since we only log warnings for unknown properties.\n        logUnknownPropertyError(propName, tNode);\n        return;\n      }\n      ngDevMode.rendererSetProperty++;\n    }\n\n    // It is assumed that the sanitizer is only added when the compiler determines that the\n    // property is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value, tNode.value || '', propName) as any) : value;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setProperty(element as RElement, propName, value);\n    } else if (!isAnimationProp(propName)) {\n      (element as RElement).setProperty ? (element as any).setProperty(propName, value) :\n                                          (element as any)[propName] = value;\n    }\n  } else if (tNode.type & TNodeType.AnyContainer) {\n    // If the node is a container and the property didn't\n    // match any of the inputs or schemas we should throw.\n    if (ngDevMode && !matchingSchemas(tView, tNode.value)) {\n      logUnknownPropertyError(propName, tNode);\n    }\n  }\n}\n\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView: LView, viewIndex: number): void {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & LViewFlags.CheckAlways)) {\n    childComponentLView[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\nfunction setNgReflectProperty(\n    lView: LView, element: RElement|RComment, type: TNodeType, attrName: string, value: any) {\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n  if (type & TNodeType.AnyRNode) {\n    if (value == null) {\n      isProceduralRenderer(renderer) ? renderer.removeAttribute((element as RElement), attrName) :\n                                       (element as RElement).removeAttribute(attrName);\n    } else {\n      isProceduralRenderer(renderer) ?\n          renderer.setAttribute((element as RElement), attrName, debugValue) :\n          (element as RElement).setAttribute(attrName, debugValue);\n    }\n  } else {\n    const textContent = `bindings=${JSON.stringify({[attrName]: debugValue}, null, 2)}`;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setValue((element as RComment), textContent);\n    } else {\n      (element as RComment).textContent = textContent;\n    }\n  }\n}\n\nexport function setNgReflectProperties(\n    lView: LView, element: RElement|RComment, type: TNodeType, dataValue: PropertyAliasValue,\n    value: any) {\n  if (type & (TNodeType.AnyRNode | TNodeType.Container)) {\n    /**\n     * dataValue is an array containing runtime input or output names for the directives:\n     * i+0: directive instance index\n     * i+1: privateName\n     *\n     * e.g. [0, 'change', 'change-minified']\n     * we want to set the reflected property with the privateName: dataValue[i+1]\n     */\n    for (let i = 0; i < dataValue.length; i += 2) {\n      setNgReflectProperty(lView, element, type, dataValue[i + 1] as string, value);\n    }\n  }\n}\n\nfunction validateProperty(\n    tView: TView, element: RElement|RComment, propName: string, tNode: TNode): boolean {\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (tView.schemas === null) return true;\n\n  // The property is considered valid if the element matches the schema, it exists on the element\n  // or it is synthetic, and we are in a browser context (web worker nodes should be skipped).\n  if (matchingSchemas(tView, tNode.value) || propName in element || isAnimationProp(propName)) {\n    return true;\n  }\n\n  // Note: `typeof Node` returns 'function' in most browsers, but on IE it is 'object' so we\n  // need to account for both here, while being careful for `typeof null` also returning 'object'.\n  return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n\nexport function matchingSchemas(tView: TView, tagName: string|null): boolean {\n  const schemas = tView.schemas;\n\n  if (schemas !== null) {\n    for (let i = 0; i < schemas.length; i++) {\n      const schema = schemas[i];\n      if (schema === NO_ERRORS_SCHEMA ||\n          schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Logs an error that a property is not supported on an element.\n * @param propName Name of the invalid property.\n * @param tNode Node on which we encountered the property.\n */\nfunction logUnknownPropertyError(propName: string, tNode: TNode): void {\n  let message = `Can't bind to '${propName}' since it isn't a known property of '${tNode.value}'.`;\n  console.error(formatRuntimeError(RuntimeErrorCode.UNKNOWN_BINDING, message));\n}\n\n/**\n * Instantiate a root component.\n */\nexport function instantiateRootComponent<T>(tView: TView, lView: LView, def: ComponentDef<T>): T {\n  const rootTNode = getCurrentTNode()!;\n  if (tView.firstCreatePass) {\n    if (def.providersResolver) def.providersResolver(def);\n    const directiveIndex = allocExpando(tView, lView, 1, null);\n    ngDevMode &&\n        assertEqual(\n            directiveIndex, rootTNode.directiveStart,\n            'Because this is a root component the allocated expando should match the TNode component.');\n    configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def);\n  }\n  const directive =\n      getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode as TElementNode);\n  attachPatchData(directive, lView);\n  const native = getNativeByTNode(rootTNode, lView);\n  if (native) {\n    attachPatchData(native, lView);\n  }\n  return directive;\n}\n\n/**\n * Resolve the matched directives on a node.\n */\nexport function resolveDirectives(\n    tView: TView, lView: LView, tNode: TElementNode|TContainerNode|TElementContainerNode,\n    localRefs: string[]|null): boolean {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n  // tsickle.\n  ngDevMode && assertFirstCreatePass(tView);\n\n  let hasDirectives = false;\n  if (getBindingsEnabled()) {\n    const directiveDefs: DirectiveDef<any>[]|null = findDirectiveDefMatches(tView, lView, tNode);\n    const exportsMap: ({[key: string]: number}|null) = localRefs === null ? null : {'': -1};\n\n    if (directiveDefs !== null) {\n      hasDirectives = true;\n      initTNodeFlags(tNode, tView.data.length, directiveDefs.length);\n      // When the same token is provided by several directives on the same node, some rules apply in\n      // the viewEngine:\n      // - viewProviders have priority over providers\n      // - the last directive in NgModule.declarations has priority over the previous one\n      // So to match these rules, the order in which providers are added in the arrays is very\n      // important.\n      for (let i = 0; i < directiveDefs.length; i++) {\n        const def = directiveDefs[i];\n        if (def.providersResolver) def.providersResolver(def);\n      }\n      let preOrderHooksFound = false;\n      let preOrderCheckHooksFound = false;\n      let directiveIdx = allocExpando(tView, lView, directiveDefs.length, null);\n      ngDevMode &&\n          assertSame(\n              directiveIdx, tNode.directiveStart,\n              'TNode.directiveStart should point to just allocated space');\n\n      for (let i = 0; i < directiveDefs.length; i++) {\n        const def = directiveDefs[i];\n        // Merge the attrs in the order of matches. This assumes that the first directive is the\n        // component itself, so that the component has the least priority.\n        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n\n        configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n        saveNameToExportMap(directiveIdx, def, exportsMap);\n\n        if (def.contentQueries !== null) tNode.flags |= TNodeFlags.hasContentQuery;\n        if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)\n          tNode.flags |= TNodeFlags.hasHostBindings;\n\n        const lifeCycleHooks: OnChanges&OnInit&DoCheck = def.type.prototype;\n        // Only push a node index into the preOrderHooks array if this is the first\n        // pre-order hook found on this node.\n        if (!preOrderHooksFound &&\n            (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n          // We will push the actual hook function into this array later during dir instantiation.\n          // We cannot do it now because we must ensure hooks are registered in the same\n          // order that directives are created (i.e. injection order).\n          (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index);\n          preOrderHooksFound = true;\n        }\n\n        if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n          (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(tNode.index);\n          preOrderCheckHooksFound = true;\n        }\n\n        directiveIdx++;\n      }\n\n      initializeInputAndOutputAliases(tView, tNode);\n    }\n    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  }\n  // Merge the template attrs last so that they have the highest priority.\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n  return hasDirectives;\n}\n\n/**\n * Add `hostBindings` to the `TView.hostBindingOpCodes`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param tNode `TNode` the element which contains the directive\n * @param lView `LView` current `LView`\n * @param directiveIdx Directive index in view.\n * @param directiveVarsIdx Where will the directive's vars be stored\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\nexport function registerHostBindingOpCodes(\n    tView: TView, tNode: TNode, lView: LView, directiveIdx: number, directiveVarsIdx: number,\n    def: ComponentDef<any>|DirectiveDef<any>): void {\n  ngDevMode && assertFirstCreatePass(tView);\n\n  const hostBindings = def.hostBindings;\n  if (hostBindings) {\n    let hostBindingOpCodes = tView.hostBindingOpCodes;\n    if (hostBindingOpCodes === null) {\n      hostBindingOpCodes = tView.hostBindingOpCodes = [] as any as HostBindingOpCodes;\n    }\n    const elementIndx = ~tNode.index;\n    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n      // Conditionally add select element so that we are more efficient in execution.\n      // NOTE: this is strictly not necessary and it trades code size for runtime perf.\n      // (We could just always add it.)\n      hostBindingOpCodes.push(elementIndx);\n    }\n    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n  }\n}\n\n/**\n * Returns the last selected element index in the `HostBindingOpCodes`\n *\n * For perf reasons we don't need to update the selected element index in `HostBindingOpCodes` only\n * if it changes. This method returns the last index (or '0' if not found.)\n *\n * Selected element index are only the ones which are negative.\n */\nfunction lastSelectedElementIdx(hostBindingOpCodes: HostBindingOpCodes): number {\n  let i = hostBindingOpCodes.length;\n  while (i > 0) {\n    const value = hostBindingOpCodes[--i];\n    if (typeof value === 'number' && value < 0) {\n      return value;\n    }\n  }\n  return 0;\n}\n\n\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(\n    tView: TView, lView: LView, tNode: TDirectiveHostNode, native: RNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n\n  attachPatchData(native, lView);\n\n  const initialInputs = tNode.initialInputs;\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    const isComponent = isComponentDef(def);\n\n    if (isComponent) {\n      ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode);\n      addComponentLogic(lView, tNode as TElementNode, def as ComponentDef<any>);\n    }\n\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs!);\n    }\n\n    if (isComponent) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = directive;\n    }\n  }\n}\n\nfunction invokeDirectivesHostBindings(tView: TView, lView: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const firstCreatePass = tView.firstCreatePass;\n  const elementIndex = tNode.index;\n  const currentDirectiveIndex = getCurrentDirectiveIndex();\n  try {\n    setSelectedIndex(elementIndex);\n    for (let dirIndex = start; dirIndex < end; dirIndex++) {\n      const def = tView.data[dirIndex] as DirectiveDef<unknown>;\n      const directive = lView[dirIndex];\n      setCurrentDirectiveIndex(dirIndex);\n      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n        invokeHostBindingsInCreationMode(def, directive);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n  }\n}\n\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nexport function invokeHostBindingsInCreationMode(def: DirectiveDef<any>, directive: any) {\n  if (def.hostBindings !== null) {\n    def.hostBindings!(RenderFlags.Create, directive);\n  }\n}\n\n/**\n * Matches the current node against all available selectors.\n * If a component is matched (at most one), it is returned in first position in the array.\n */\nfunction findDirectiveDefMatches(\n    tView: TView, viewData: LView,\n    tNode: TElementNode|TContainerNode|TElementContainerNode): DirectiveDef<any>[]|null {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode | TNodeType.AnyContainer);\n\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i] as ComponentDef<any>| DirectiveDef<any>;\n      if (isNodeMatchingSelectorList(tNode, def.selectors!, /* isProjectionMode */ false)) {\n        matches || (matches = ngDevMode ? new MatchesArray() : []);\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);\n\n        if (isComponentDef(def)) {\n          if (ngDevMode) {\n            assertTNodeType(\n                tNode, TNodeType.Element,\n                `\"${tNode.value}\" tags cannot be used as component hosts. ` +\n                    `Please use a different tag to activate the ${stringify(def.type)} component.`);\n\n            if (tNode.flags & TNodeFlags.isComponentHost) throwMultipleComponentError(tNode);\n          }\n          markAsComponentHost(tView, tNode);\n          // The component is always stored first with directives after.\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting appropriate TNode flags;\n * - storing index of component's host element so it will be queued for view refresh during CD.\n */\nexport function markAsComponentHost(tView: TView, hostTNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  hostTNode.flags |= TNodeFlags.isComponentHost;\n  (tView.components || (tView.components = ngDevMode ? new TViewComponents() : []))\n      .push(hostTNode.index);\n}\n\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[]|null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string|number)[] = tNode.localNames = ngDevMode ? new TNodeLocalNames() : [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null)\n        throw new RuntimeError(\n            RuntimeErrorCode.EXPORT_NOT_FOUND, `Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(\n    directiveIdx: number, def: DirectiveDef<any>|ComponentDef<any>,\n    exportsMap: {[key: string]: number}|null) {\n  if (exportsMap) {\n    if (def.exportAs) {\n      for (let i = 0; i < def.exportAs.length; i++) {\n        exportsMap[def.exportAs[i]] = directiveIdx;\n      }\n    }\n    if (isComponentDef(def)) exportsMap[''] = directiveIdx;\n  }\n}\n\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nexport function initTNodeFlags(tNode: TNode, index: number, numberOfDirectives: number) {\n  ngDevMode &&\n      assertNotEqual(\n          numberOfDirectives, tNode.directiveEnd - tNode.directiveStart,\n          'Reached the max number of directives');\n  tNode.flags |= TNodeFlags.isDirectiveHost;\n  // When the first directive is created on a node, save the index\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n\n/**\n * Setup directive for instantiation.\n *\n * We need to create a `NodeInjectorFactory` which is then inserted in both the `Blueprint` as well\n * as `LView`. `TView` gets the `DirectiveDef`.\n *\n * @param tView `TView`\n * @param tNode `TNode`\n * @param lView `LView`\n * @param directiveIndex Index where the directive will be stored in the Expando.\n * @param def `DirectiveDef`\n */\nfunction configureViewWithDirective<T>(\n    tView: TView, tNode: TNode, lView: LView, directiveIndex: number, def: DirectiveDef<T>): void {\n  ngDevMode &&\n      assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, 'Must be in Expando section');\n  tView.data[directiveIndex] = def;\n  const directiveFactory =\n      def.factory || ((def as {factory: Function}).factory = getFactoryDef(def.type, true));\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);\n  tView.blueprint[directiveIndex] = nodeInjectorFactory;\n  lView[directiveIndex] = nodeInjectorFactory;\n\n  registerHostBindingOpCodes(\n      tView, tNode, lView, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE),\n      def);\n}\n\nfunction addComponentLogic<T>(lView: LView, hostTNode: TElementNode, def: ComponentDef<T>): void {\n  const native = getNativeByTNode(hostTNode, lView) as RElement;\n  const tView = getOrCreateTComponentView(def);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const componentView = addToViewTree(\n      lView,\n      createLView(\n          lView, tView, null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, native,\n          hostTNode as TElementNode, rendererFactory, rendererFactory.createRenderer(native, def),\n          null, null));\n\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  lView[hostTNode.index] = componentView;\n}\n\nexport function elementAttributeInternal(\n    tNode: TNode, lView: LView, name: string, value: any, sanitizer: SanitizerFn|null|undefined,\n    namespace: string|null|undefined) {\n  if (ngDevMode) {\n    assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n    validateAgainstEventAttributes(name);\n    assertTNodeType(\n        tNode, TNodeType.Element,\n        `Attempted to set attribute \\`${name}\\` on a container node. ` +\n            `Host bindings are not valid on ng-container or ng-template.`);\n  }\n  const element = getNativeByTNode(tNode, lView) as RElement;\n  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\n\nexport function setElementAttribute(\n    renderer: Renderer3, element: RElement, namespace: string|null|undefined, tagName: string|null,\n    name: string, value: any, sanitizer: SanitizerFn|null|undefined) {\n  if (value == null) {\n    ngDevMode && ngDevMode.rendererRemoveAttribute++;\n    isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) :\n                                     element.removeAttribute(name);\n  } else {\n    ngDevMode && ngDevMode.rendererSetAttribute++;\n    const strValue =\n        sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || '', name);\n\n\n    if (isProceduralRenderer(renderer)) {\n      renderer.setAttribute(element, name, strValue, namespace);\n    } else {\n      namespace ? element.setAttributeNS(namespace, name, strValue) :\n                  element.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    lView: LView, directiveIndex: number, instance: T, def: DirectiveDef<T>, tNode: TNode,\n    initialInputData: InitialInputData): void {\n  const initialInputs: InitialInputs|null = initialInputData![directiveIndex];\n  if (initialInputs !== null) {\n    const setInput = def.setInput;\n    for (let i = 0; i < initialInputs.length;) {\n      const publicName = initialInputs[i++];\n      const privateName = initialInputs[i++];\n      const value = initialInputs[i++];\n      if (setInput !== null) {\n        def.setInput!(instance, value, publicName, privateName);\n      } else {\n        (instance as any)[privateName] = value;\n      }\n      if (ngDevMode) {\n        const nativeElement = getNativeByTNode(tNode, lView) as RElement;\n        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n      }\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs The list of inputs from the directive def\n * @param attrs The static attrs on this node\n */\nfunction generateInitialInputs(inputs: {[key: string]: string}, attrs: TAttributes): InitialInputs|\n    null {\n  let inputsToStore: InitialInputs|null = null;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    } else if (attrName === AttributeMarker.ProjectAs) {\n      // Skip over the `ngProjectAs` value.\n      i += 2;\n      continue;\n    }\n\n    // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n    if (typeof attrName === 'number') break;\n\n    if (inputs.hasOwnProperty(attrName as string)) {\n      if (inputsToStore === null) inputsToStore = [];\n      inputsToStore.push(attrName as string, inputs[attrName as string], attrs[i + 1] as string);\n    }\n\n    i += 2;\n  }\n  return inputsToStore;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n// Not sure why I need to do `any` here but TS complains later.\nconst LContainerArray: any = ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) &&\n    createNamedArrayType('LContainer');\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    hostNative: RElement|RComment|LView, currentView: LView, native: RComment,\n    tNode: TNode): LContainer {\n  ngDevMode && assertLView(currentView);\n  ngDevMode && !isProceduralRenderer(currentView[RENDERER]) && assertDomNode(native);\n  // https://jsperf.com/array-literal-vs-new-array-really\n  const lContainer: LContainer = new (ngDevMode ? LContainerArray : Array)(\n      hostNative,   // host native\n      true,         // Boolean `true` in this position signifies that this is an `LContainer`\n      false,        // has transplanted views\n      currentView,  // parent\n      null,         // next\n      0,            // transplanted views to refresh count\n      tNode,        // t_host\n      native,       // native,\n      null,         // view refs\n      null,         // moved views\n  );\n  ngDevMode &&\n      assertEqual(\n          lContainer.length, CONTAINER_HEADER_OFFSET,\n          'Should allocate correct number of slots for LContainer header.');\n  ngDevMode && attachLContainerDebug(lContainer);\n  return lContainer;\n}\n\n/**\n * Goes over embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction refreshEmbeddedViews(lView: LView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null;\n       lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      const embeddedTView = embeddedLView[TVIEW];\n      ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n      if (viewAttachedToChangeDetector(embeddedLView)) {\n        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]!);\n      }\n    }\n  }\n}\n\n/**\n * Mark transplanted views as needing to be refreshed at their insertion points.\n *\n * @param lView The `LView` that may have transplanted views.\n */\nfunction markTransplantedViewsForRefresh(lView: LView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null;\n       lContainer = getNextLContainer(lContainer)) {\n    if (!lContainer[HAS_TRANSPLANTED_VIEWS]) continue;\n\n    const movedViews = lContainer[MOVED_VIEWS]!;\n    ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n    for (let i = 0; i < movedViews.length; i++) {\n      const movedLView = movedViews[i]!;\n      const insertionLContainer = movedLView[PARENT] as LContainer;\n      ngDevMode && assertLContainer(insertionLContainer);\n      // We don't want to increment the counter if the moved LView was already marked for\n      // refresh.\n      if ((movedLView[FLAGS] & LViewFlags.RefreshTransplantedView) === 0) {\n        updateTransplantedViewCount(insertionLContainer, 1);\n      }\n      // Note, it is possible that the `movedViews` is tracking views that are transplanted *and*\n      // those that aren't (declaration component === insertion component). In the latter case,\n      // it's fine to add the flag, as we will clear it immediately in\n      // `refreshEmbeddedViews` for the view currently being refreshed.\n      movedLView[FLAGS] |= LViewFlags.RefreshTransplantedView;\n    }\n  }\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction refreshComponent(hostLView: LView, componentHostIdx: number): void {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n  if (viewAttachedToChangeDetector(componentView)) {\n    const tView = componentView[TVIEW];\n    if (componentView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n      refreshView(tView, componentView, tView.template, componentView[CONTEXT]);\n    } else if (componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n      // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n      refreshContainsDirtyView(componentView);\n    }\n  }\n}\n\n/**\n * Refreshes all transplanted views marked with `LViewFlags.RefreshTransplantedView` that are\n * children or descendants of the given lView.\n *\n * @param lView The lView which contains descendant transplanted views that need to be refreshed.\n */\nfunction refreshContainsDirtyView(lView: LView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null;\n       lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      if (embeddedLView[FLAGS] & LViewFlags.RefreshTransplantedView) {\n        const embeddedTView = embeddedLView[TVIEW];\n        ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n        refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT]!);\n      } else if (embeddedLView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n        refreshContainsDirtyView(embeddedLView);\n      }\n    }\n  }\n\n  const tView = lView[TVIEW];\n  // Refresh child component views.\n  const components = tView.components;\n  if (components !== null) {\n    for (let i = 0; i < components.length; i++) {\n      const componentView = getComponentLViewByIndex(components[i], lView);\n      // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n      if (viewAttachedToChangeDetector(componentView) &&\n          componentView[TRANSPLANTED_VIEWS_TO_REFRESH] > 0) {\n        refreshContainsDirtyView(componentView);\n      }\n    }\n  }\n}\n\nfunction renderComponent(hostLView: LView, componentHostIdx: number) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  const componentTView = componentView[TVIEW];\n  syncViewWithBlueprint(componentTView, componentView);\n  renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nfunction syncViewWithBlueprint(tView: TView, lView: LView) {\n  for (let i = lView.length; i < tView.blueprint.length; i++) {\n    lView.push(tView.blueprint[i]);\n  }\n}\n\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LView|LContainer>(lView: LView, lViewOrLContainer: T): T {\n  // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n  // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n  // of order, the change detection will run out of order, as the act of retrieving the the\n  // LContainer from the RNode is what adds it to the queue.\n  if (lView[CHILD_HEAD]) {\n    lView[CHILD_TAIL]![NEXT] = lViewOrLContainer;\n  } else {\n    lView[CHILD_HEAD] = lViewOrLContainer;\n  }\n  lView[CHILD_TAIL] = lViewOrLContainer;\n  return lViewOrLContainer;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nexport function markViewDirty(lView: LView): LView|null {\n  while (lView) {\n    lView[FLAGS] |= LViewFlags.Dirty;\n    const parent = getLViewParent(lView);\n    // Stop traversing up as soon as you find a root view that wasn't attached to any container\n    if (isRootView(lView) && !parent) {\n      return lView;\n    }\n    // continue otherwise\n    lView = parent!;\n  }\n  return null;\n}\n\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick(rootContext: RootContext, flags: RootContextFlags) {\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n    // https://github.com/angular/angular/issues/39296\n    // should only attach the flags when really scheduling a tick\n    rootContext.flags |= flags;\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & RootContextFlags.DetectChanges) {\n        rootContext.flags &= ~RootContextFlags.DetectChanges;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & RootContextFlags.FlushPlayers) {\n        rootContext.flags &= ~RootContextFlags.FlushPlayers;\n        const playerHandler = rootContext.playerHandler;\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res!(null);\n    });\n  }\n}\n\nexport function tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    const lView = readPatchedLView(rootComponent)!;\n    const tView = lView[TVIEW];\n    renderComponentOrTemplate(tView, lView, tView.template, rootComponent);\n  }\n}\n\nexport function detectChangesInternal<T>(tView: TView, lView: LView, context: T) {\n  const rendererFactory = lView[RENDERER_FACTORY];\n  if (rendererFactory.begin) rendererFactory.begin();\n  try {\n    refreshView(tView, lView, tView.template, context);\n  } catch (error) {\n    handleError(lView, error);\n    throw error;\n  } finally {\n    if (rendererFactory.end) rendererFactory.end();\n  }\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lView The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lView: LView): void {\n  tickRootContext(lView[CONTEXT] as RootContext);\n}\n\nexport function checkNoChangesInternal<T>(tView: TView, view: LView, context: T) {\n  setIsInCheckNoChangesMode(true);\n  try {\n    detectChangesInternal(tView, view, context);\n  } finally {\n    setIsInCheckNoChangesMode(false);\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lView The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lView: LView): void {\n  setIsInCheckNoChangesMode(true);\n  try {\n    detectChangesInRootView(lView);\n  } finally {\n    setIsInCheckNoChangesMode(false);\n  }\n}\n\nfunction executeViewQueryFn<T>(\n    flags: RenderFlags, viewQueryFn: ViewQueriesFunction<{}>, component: T): void {\n  ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n  setCurrentQueryIndex(0);\n  viewQueryFn(flags, component);\n}\n\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyName�prefix�interpolation_static_part1�..interpolation_static_partN�suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param tNode `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nexport function storePropertyBindingMetadata(\n    tData: TData, tNode: TNode, propertyName: string, bindingIndex: number,\n    ...interpolationParts: string[]) {\n  // Binding meta-data are stored only the first time a given property instruction is processed.\n  // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n  // binding meta-data to decide if one should be stored (or if was stored already).\n  if (tData[bindingIndex] === null) {\n    if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n      if (interpolationParts.length > 0) {\n        bindingMetadata +=\n            INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n\nexport function getLCleanup(view: LView): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);\n}\n\nexport function getTViewCleanup(tView: TView): any[] {\n  return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);\n}\n\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nexport function loadComponentRenderer(\n    currentDef: DirectiveDef<any>|null, tNode: TNode, lView: LView): Renderer3 {\n  // TODO(FW-2043): the `currentDef` is null when host bindings are invoked while creating root\n  // component (see packages/core/src/render3/component.ts). This is not consistent with the process\n  // of creating inner components, when current directive index is available in the state. In order\n  // to avoid relying on current def being `null` (thus special-casing root component creation), the\n  // process of creating root component should be unified with the process of creating inner\n  // components.\n  if (currentDef === null || isComponentDef(currentDef)) {\n    lView = unwrapLView(lView[tNode.index])!;\n  }\n  return lView[RENDERER];\n}\n\n/** Handles an error thrown in an LView. */\nexport function handleError(lView: LView, error: any): void {\n  const injector = lView[INJECTOR];\n  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n  errorHandler && errorHandler.handleError(error);\n}\n\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\nexport function setInputsForProperty(\n    tView: TView, lView: LView, inputs: PropertyAliasValue, publicName: string, value: any): void {\n  for (let i = 0; i < inputs.length;) {\n    const index = inputs[i++] as number;\n    const privateName = inputs[i++] as string;\n    const instance = lView[index];\n    ngDevMode && assertIndexInRange(lView, index);\n    const def = tView.data[index] as DirectiveDef<any>;\n    if (def.setInput !== null) {\n      def.setInput!(instance, value, publicName, privateName);\n    } else {\n      instance[privateName] = value;\n    }\n  }\n}\n\n/**\n * Updates a text binding at a given index in a given LView.\n */\nexport function textBindingInternal(lView: LView, index: number, value: string): void {\n  ngDevMode && assertString(value, 'Value should be a string');\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'value should not be NO_CHANGE');\n  ngDevMode && assertIndexInRange(lView, index);\n  const element = getNativeByIndex(index, lView) as any as RText;\n  ngDevMode && assertDefined(element, 'native element should exist');\n  updateTextNode(lView[RENDERER], element, value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {concatStringsWithSpace} from '../../util/stringify';\nimport {assertFirstCreatePass} from '../assert';\nimport {AttributeMarker, TAttributes, TNode} from '../interfaces/node';\nimport {getTView} from '../state';\n\n/**\n * Compute the static styling (class/style) from `TAttributes`.\n *\n * This function should be called during `firstCreatePass` only.\n *\n * @param tNode The `TNode` into which the styling information should be loaded.\n * @param attrs `TAttributes` containing the styling information.\n * @param writeToHost Where should the resulting static styles be written?\n *   - `false` Write to `TNode.stylesWithoutHost` / `TNode.classesWithoutHost`\n *   - `true` Write to `TNode.styles` / `TNode.classes`\n */\nexport function computeStaticStyling(\n    tNode: TNode, attrs: TAttributes|null, writeToHost: boolean): void {\n  ngDevMode &&\n      assertFirstCreatePass(getTView(), 'Expecting to be called in first template pass only');\n  let styles: string|null = writeToHost ? tNode.styles : null;\n  let classes: string|null = writeToHost ? tNode.classes : null;\n  let mode: AttributeMarker|0 = 0;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const value = attrs[i];\n      if (typeof value === 'number') {\n        mode = value;\n      } else if (mode == AttributeMarker.Classes) {\n        classes = concatStringsWithSpace(classes, value as string);\n      } else if (mode == AttributeMarker.Styles) {\n        const style = value as string;\n        const styleValue = attrs[++i] as string;\n        styles = concatStringsWithSpace(styles, style + ': ' + styleValue + ';');\n      }\n    }\n  }\n  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {InjectorMarkers} from './injector_marker';\n\n\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport const INJECTOR = new InjectionToken<Injector>(\n    'INJECTOR',\n    // Dissable tslint because this is const enum which gets inlined not top level prop access.\n    // tslint:disable-next-line: no-toplevel-property-access\n    InjectorMarkers.Injector as any,  // Special value used by Ivy to identify `Injector`.\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {stringify} from '../util/stringify';\nimport {Injector} from './injector';\nimport {THROW_IF_NOT_FOUND} from './injector_compatibility';\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n      error.name = 'NullInjectorError';\n      throw error;\n    }\n    return notFoundValue;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from './injection_token';\n\n\n/**\n * An internal token whose presence in an injector indicates that the injector should treat itself\n * as a root scoped injector when processing requests for unknown tokens which may indicate\n * they are provided in the root scope.\n */\nexport const INJECTOR_SCOPE = new InjectionToken<'root'|'platform'|null>('Set Injector scope.');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {OnDestroy} from '../interface/lifecycle_hooks';\nimport {AbstractType, Type} from '../interface/type';\nimport {FactoryFn, getFactoryDef} from '../render3/definition_factory';\nimport {throwCyclicDependencyError, throwInvalidProviderError, throwMixedMultiProviderError} from '../render3/errors_di';\nimport {deepForEach, newArray} from '../util/array_utils';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {catchInjectorError, injectArgs, NG_TEMP_TOKEN_PATH, setCurrentInjector, THROW_IF_NOT_FOUND, USE_VALUE, ɵɵinject} from './injector_compatibility';\nimport {INJECTOR} from './injector_token';\nimport {getInheritedInjectableDef, getInjectableDef, getInjectorDef, InjectorType, InjectorTypeWithProviders, ɵɵInjectableDef} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, TypeProvider, ValueProvider} from './interface/provider';\nimport {NullInjector} from './null_injector';\nimport {INJECTOR_SCOPE} from './scope';\n\n\n\n/**\n * Internal type for a single provider in a deep provider array.\n */\ntype SingleProvider = TypeProvider|ValueProvider|ClassProvider|ConstructorProvider|ExistingProvider|\n    FactoryProvider|StaticClassProvider;\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\nconst EMPTY_ARRAY = [] as any[];\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector|undefined = undefined;\n\nfunction getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: (() => T)|undefined;\n  value: T|{};\n  multi: any[]|undefined;\n}\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @publicApi\n */\nexport function createInjector(\n    defType: /* InjectorType<any> */ any, parent: Injector|null = null,\n    additionalProviders: StaticProvider[]|null = null, name?: string): Injector {\n  const injector =\n      createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n  injector._resolveInjectorDefTypes();\n  return injector;\n}\n\n/**\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\n */\nexport function createInjectorWithoutInjectorInstances(\n    defType: /* InjectorType<any> */ any, parent: Injector|null = null,\n    additionalProviders: StaticProvider[]|null = null, name?: string): R3Injector {\n  return new R3Injector(defType, additionalProviders, parent || getNullInjector(), name);\n}\n\nexport class R3Injector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n   * to prevent further searches.\n   */\n  private records = new Map<Type<any>|AbstractType<any>|InjectionToken<any>, Record<any>|null>();\n\n  /**\n   * The transitive set of `InjectorType`s which define this injector.\n   */\n  private injectorDefTypes = new Set<InjectorType<any>>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private onDestroy = new Set<OnDestroy>();\n\n  /**\n   * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\n   * root scope.\n   */\n  private readonly scope: 'root'|'platform'|null;\n\n  readonly source: string|null;\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n  private _destroyed = false;\n\n  constructor(\n      def: InjectorType<any>, additionalProviders: StaticProvider[]|null, readonly parent: Injector,\n      source: string|null = null) {\n    const dedupStack: InjectorType<any>[] = [];\n\n    // Start off by creating Records for every provider declared in every InjectorType\n    // included transitively in additional providers then do the same for `def`. This order is\n    // important because `def` may include providers that override ones in additionalProviders.\n    additionalProviders &&\n        deepForEach(\n            additionalProviders,\n            provider => this.processProvider(provider, def, additionalProviders));\n\n    deepForEach([def], injectorDef => this.processInjectorType(injectorDef, [], dedupStack));\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    const record = this.records.get(INJECTOR_SCOPE);\n    this.scope = record != null ? record.value : null;\n\n    // Source name, used for debugging\n    this.source = source || (typeof def === 'object' ? null : stringify(def));\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy(): void {\n    this.assertNotDestroyed();\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this._destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      this.onDestroy.forEach(service => service.ngOnDestroy());\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this.onDestroy.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n\n  get<T>(\n      token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n      flags = InjectFlags.Default): T {\n    this.assertNotDestroyed();\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T>|undefined|null = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an injectable\n          // def with a scope matching this injector.\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            // Found an injectable def and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record != null /* NOT null || undefined */) {\n          return this.hydrate(token, record);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\n      // is undefined, the value is null, otherwise it's the notFoundValue.\n      notFoundValue = (flags & InjectFlags.Optional) && notFoundValue === THROW_IF_NOT_FOUND ?\n          null :\n          notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (e) {\n      if (e.name === 'NullInjectorError') {\n        const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n        path.unshift(stringify(token));\n        if (previousInjector) {\n          // We still have a parent injector, keep throwing\n          throw e;\n        } else {\n          // Format & throw the final error message when we don't have any previous injector\n          return catchInjectorError(e, token, 'R3InjectorError', this.source);\n        }\n      } else {\n        throw e;\n      }\n    } finally {\n      // Lastly, clean up the state by restoring the previous injector.\n      setCurrentInjector(previousInjector);\n    }\n  }\n\n  /** @internal */\n  _resolveInjectorDefTypes() {\n    this.injectorDefTypes.forEach(defType => this.get(defType));\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this.records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `R3Injector[${tokens.join(', ')}]`;\n  }\n\n  private assertNotDestroyed(): void {\n    if (this._destroyed) {\n      throw new Error('Injector has already been destroyed.');\n    }\n  }\n\n  /**\n   * Add an `InjectorType` or `InjectorTypeWithProviders` and all of its transitive providers\n   * to this injector.\n   *\n   * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\n   * the function will return \"true\" to indicate that the providers of the type definition need\n   * to be processed. This allows us to process providers of injector types after all imports of\n   * an injector definition are processed. (following View Engine semantics: see FW-1349)\n   */\n  private processInjectorType(\n      defOrWrappedDef: InjectorType<any>|InjectorTypeWithProviders<any>,\n      parents: InjectorType<any>[],\n      dedupStack: InjectorType<any>[]): defOrWrappedDef is InjectorTypeWithProviders<any> {\n    defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\n    if (!defOrWrappedDef) return false;\n\n    // Either the defOrWrappedDef is an InjectorType (with injector def) or an\n    // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\n    // read, so care is taken to only do the read once.\n\n    // First attempt to read the injector def (`ɵinj`).\n    let def = getInjectorDef(defOrWrappedDef);\n\n    // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\n    const ngModule =\n        (def == null) && (defOrWrappedDef as InjectorTypeWithProviders<any>).ngModule || undefined;\n\n    // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,\n    // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\n    // is the `ngModule`.\n    const defType: InjectorType<any> =\n        (ngModule === undefined) ? (defOrWrappedDef as InjectorType<any>) : ngModule;\n\n    // Check for circular dependencies.\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\n      const defName = stringify(defType);\n      const path = parents.map(stringify);\n      throwCyclicDependencyError(defName, path);\n    }\n\n    // Check for multiple imports of the same module\n    const isDuplicate = dedupStack.indexOf(defType) !== -1;\n\n    // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\n    // `InjectorDef` is on its `ngModule`.\n    if (ngModule !== undefined) {\n      def = getInjectorDef(ngModule);\n    }\n\n    // If no definition was found, it might be from exports. Remove it.\n    if (def == null) {\n      return false;\n    }\n\n    // Add providers in the same way that @NgModule resolution did:\n\n    // First, include providers from any imports.\n    if (def.imports != null && !isDuplicate) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      ngDevMode && parents.push(defType);\n      // Add it to the set of dedups. This way we can detect multiple imports of the same module\n      dedupStack.push(defType);\n\n      let importTypesWithProviders: (InjectorTypeWithProviders<any>[])|undefined;\n      try {\n        deepForEach(def.imports, imported => {\n          if (this.processInjectorType(imported, parents, dedupStack)) {\n            if (importTypesWithProviders === undefined) importTypesWithProviders = [];\n            // If the processed import is an injector type with providers, we store it in the\n            // list of import types with providers, so that we can process those afterwards.\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        // Remove it from the parents set when finished.\n        ngDevMode && parents.pop();\n      }\n\n      // Imports which are declared with providers (TypeWithProviders) need to be processed\n      // after all imported modules are processed. This is similar to how View Engine\n      // processes/merges module imports in the metadata resolver. See: FW-1349.\n      if (importTypesWithProviders !== undefined) {\n        for (let i = 0; i < importTypesWithProviders.length; i++) {\n          const {ngModule, providers} = importTypesWithProviders[i];\n          deepForEach(\n              providers!,\n              provider => this.processProvider(provider, ngModule, providers || EMPTY_ARRAY));\n        }\n      }\n    }\n    // Track the InjectorType and add a provider for it. It's important that this is done after the\n    // def's imports.\n    this.injectorDefTypes.add(defType);\n    this.records.set(defType, makeRecord(def.factory, NOT_YET));\n\n    // Next, include providers listed on the definition itself.\n    const defProviders = def.providers;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = defOrWrappedDef as InjectorType<any>;\n      deepForEach(\n          defProviders, provider => this.processProvider(provider, injectorType, defProviders));\n    }\n\n    return (\n        ngModule !== undefined &&\n        (defOrWrappedDef as InjectorTypeWithProviders<any>).providers !== undefined);\n  }\n\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  private processProvider(\n      provider: SingleProvider, ngModuleType: InjectorType<any>, providers: any[]): void {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token: any =\n        isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider, ngModuleType, providers);\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (ngDevMode && multiRecord.multi === undefined) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord!.multi!);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi!.push(provider);\n    } else {\n      const existing = this.records.get(token);\n      if (ngDevMode && existing && existing.multi !== undefined) {\n        throwMixedMultiProviderError();\n      }\n    }\n    this.records.set(token, record);\n  }\n\n  private hydrate<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, record: Record<T>): T {\n    if (ngDevMode && record.value === CIRCULAR) {\n      throwCyclicDependencyError(stringify(token));\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory!();\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this.onDestroy.add(record.value);\n    }\n    return record.value as T;\n  }\n\n  private injectableDefInScope(def: ɵɵInjectableDef<any>): boolean {\n    if (!def.providedIn) {\n      return false;\n    } else if (typeof def.providedIn === 'string') {\n      return def.providedIn === 'any' || (def.providedIn === this.scope);\n    } else {\n      return this.injectorDefTypes.has(def.providedIn);\n    }\n  }\n}\n\nfunction injectableDefOrInjectorDefFactory(token: Type<any>|AbstractType<any>|\n                                           InjectionToken<any>): FactoryFn<any> {\n  // Most tokens will have an injectable def directly on them, which specifies a factory directly.\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n\n  if (factory !== null) {\n    return factory;\n  }\n\n  // If the token is an NgModule, it's also injectable but the factory is on its injector def\n  // (`ɵinj`)\n  const injectorDef = getInjectorDef(token);\n  if (injectorDef !== null) {\n    return injectorDef.factory;\n  }\n\n  // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\n  // If it's missing that, it's an error.\n  if (token instanceof InjectionToken) {\n    throw new Error(`Token ${stringify(token)} is missing a ɵprov definition.`);\n  }\n\n  // Undecorated types can sometimes be created if they have no constructor arguments.\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  }\n\n  // There was no way to resolve a factory for this token.\n  throw new Error('unreachable');\n}\n\nfunction getUndecoratedInjectableFactory(token: Function) {\n  // If the token has parameters then it has dependencies that we cannot resolve implicitly.\n  const paramLength = token.length;\n  if (paramLength > 0) {\n    const args: string[] = newArray(paramLength, '?');\n    throw new Error(`Can't resolve all parameters for ${stringify(token)}: (${args.join(', ')}).`);\n  }\n\n  // The constructor function appears to have no parameters.\n  // This might be because it inherits from a super-class. In which case, use an injectable\n  // def from an ancestor if there is one.\n  // Otherwise this really is a simple class with no dependencies, so return a factory that\n  // just instantiates the zero-arg constructor.\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token as Type<any>);\n  } else {\n    return () => new (token as Type<any>)();\n  }\n}\n\nfunction providerToRecord(\n    provider: SingleProvider, ngModuleType: InjectorType<any>, providers: any[]): Record<any> {\n  if (isValueProvider(provider)) {\n    return makeRecord(undefined, provider.useValue);\n  } else {\n    const factory: (() => any)|undefined = providerToFactory(provider, ngModuleType, providers);\n    return makeRecord(factory, NOT_YET);\n  }\n}\n\n/**\n * Converts a `SingleProvider` into a factory function.\n *\n * @param provider provider to convert to factory\n */\nexport function providerToFactory(\n    provider: SingleProvider, ngModuleType?: InjectorType<any>, providers?: any[]): () => any {\n  let factory: (() => any)|undefined = undefined;\n  if (isTypeProvider(provider)) {\n    const unwrappedProvider = resolveForwardRef(provider);\n    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else if (isExistingProvider(provider)) {\n      factory = () => ɵɵinject(resolveForwardRef(provider.useExisting));\n    } else {\n      const classRef = resolveForwardRef(\n          provider &&\n          ((provider as StaticClassProvider | ClassProvider).useClass || provider.provide));\n      if (ngDevMode && !classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n      if (hasDeps(provider)) {\n        factory = () => new (classRef)(...injectArgs(provider.deps));\n      } else {\n        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\n\nfunction makeRecord<T>(\n    factory: (() => T)|undefined, value: T|{}, multi: boolean = false): Record<T> {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined,\n  };\n}\n\nfunction isValueProvider(value: SingleProvider): value is ValueProvider {\n  return value !== null && typeof value == 'object' && USE_VALUE in value;\n}\n\nfunction isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value && (value as ExistingProvider).useExisting);\n}\n\nfunction isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value && (value as FactoryProvider).useFactory);\n}\n\nexport function isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nexport function isClassProvider(value: SingleProvider): value is ClassProvider {\n  return !!(value as StaticClassProvider | ClassProvider).useClass;\n}\n\nfunction hasDeps(value: ClassProvider|ConstructorProvider|\n                 StaticClassProvider): value is ClassProvider&{deps: any[]} {\n  return !!(value as any).deps;\n}\n\nfunction hasOnDestroy(value: any): value is OnDestroy {\n  return value !== null && typeof value === 'object' &&\n      typeof (value as OnDestroy).ngOnDestroy === 'function';\n}\n\nfunction couldBeInjectableType(value: any): value is Type<any>|AbstractType<any>|\n    InjectionToken<any> {\n  return (typeof value === 'function') ||\n      (typeof value === 'object' && value instanceof InjectionToken);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractType, Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {catchInjectorError, formatError, NG_TEMP_TOKEN_PATH, setCurrentInjector, THROW_IF_NOT_FOUND, USE_VALUE, ɵɵinject} from './injector_compatibility';\nimport {InjectorMarkers} from './injector_marker';\nimport {INJECTOR} from './injector_token';\nimport {getInjectableDef, ɵɵdefineInjectable} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './interface/provider';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {NullInjector} from './null_injector';\nimport {createInjector} from './r3_injector';\nimport {INJECTOR_SCOPE} from './scope';\n\nexport function INJECTOR_IMPL__PRE_R3__(\n    providers: StaticProvider[], parent: Injector|undefined, name: string) {\n  return new StaticInjector(providers, parent, name);\n}\n\nexport function INJECTOR_IMPL__POST_R3__(\n    providers: StaticProvider[], parent: Injector|undefined, name: string) {\n  return createInjector({name: name}, parent, providers, name);\n}\n\nexport const INJECTOR_IMPL = INJECTOR_IMPL__PRE_R3__;\n\n/**\n * Concrete injectors implement this interface. Injectors are configured\n * with [providers](guide/glossary#provider) that associate\n * dependencies of various types with [injection tokens](guide/glossary#di-token).\n *\n * @see [\"DI Providers\"](guide/dependency-injection-providers).\n * @see `StaticProvider`\n *\n * @usageNotes\n *\n *  The following example creates a service injector instance.\n *\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n *\n * ### Usage example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n * @publicApi\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(\n      token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T>, AbstractType<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  /**\n   * Creates a new injector instance that provides one or more dependencies,\n   * according to a given type or types of `StaticProvider`.\n   *\n   * @param options An object with the following properties:\n   * * `providers`: An array of providers of the [StaticProvider type](api/core/StaticProvider).\n   * * `parent`: (optional) A parent injector.\n   * * `name`: (optional) A developer-defined identifying name for the new injector.\n   *\n   * @returns The new injector instance.\n   *\n   */\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return INJECTOR_IMPL(options, parent, '');\n    } else {\n      return INJECTOR_IMPL(options.providers, options.parent, options.name || '');\n    }\n  }\n\n  /** @nocollapse */\n  static ɵprov = ɵɵdefineInjectable({\n    token: Injector,\n    providedIn: 'any' as any,\n    factory: () => ɵɵinject(INJECTOR),\n  });\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = InjectorMarkers.Injector;\n}\n\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\n\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NO_NEW_LINE = 'ɵ';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n  readonly scope: string|null;\n\n  private _records: Map<any, Record|null>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = Injector.NULL, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    this.scope = recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags):\n      T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const records = this._records;\n    let record = records.get(token);\n    if (record === undefined) {\n      // This means we have never seen this record, see if it is tree shakable provider.\n      const injectableDef = getInjectableDef(token);\n      if (injectableDef) {\n        const providedIn = injectableDef && injectableDef.providedIn;\n        if (providedIn === 'any' || providedIn != null && providedIn === this.scope) {\n          records.set(\n              token,\n              record = resolveProvider(\n                  {provide: token, useFactory: injectableDef.factory, deps: EMPTY}));\n        }\n      }\n      if (record === undefined) {\n        // Set record to null to make sure that we don't go through expensive lookup above again.\n        records.set(token, null);\n      }\n    }\n    let lastInjector = setCurrentInjector(this);\n    try {\n      return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      return catchInjectorError(e, token, 'StaticInjectorError', this.source);\n    } finally {\n      setCurrentInjector(lastInjector);\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider|ExistingProvider|StaticClassProvider|ConstructorProvider|FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider): string|\n    null {\n  let scope: string|null = null;\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (Array.isArray(provider)) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        scope = recursivelyProcessProviders(records, provider[i]) || scope;\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      if (token === INJECTOR_SCOPE) {\n        scope = resolvedProvider.value;\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n  return scope;\n}\n\nfunction tryResolveToken(\n    token: any, record: Record|undefined|null, records: Map<any, Record|null>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record|undefined|null, records: Map<any, Record|null>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? Injector.NULL : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  } else if (!(flags & InjectFlags.Optional)) {\n    value = Injector.NULL.get(token, notFoundValue);\n  } else {\n    value = Injector.NULL.get(token, typeof notFoundValue !== 'undefined' ? notFoundValue : null);\n  }\n  return value;\n}\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (Array.isArray(token)) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj, 'StaticInjectorError'));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// We are temporarily importing the existing viewEngine from core so we can be sure we are\n// correctly implementing its interfaces for backwards compatibility.\nimport {Injector} from '../di/injector';\nimport {Type} from '../interface/type';\nimport {Sanitizer} from '../sanitization/sanitizer';\nimport {assertDefined, assertIndexInRange} from '../util/assert';\nimport {assertComponentType} from './assert';\nimport {getComponentDef} from './definition';\nimport {diPublicInInjector, getOrCreateNodeInjectorForNode} from './di';\nimport {throwProviderNotFoundError} from './errors_di';\nimport {registerPostOrderHooks} from './hooks';\nimport {addToViewTree, CLEAN_PROMISE, createLView, createTView, getOrCreateTComponentView, getOrCreateTNode, initTNodeFlags, instantiateRootComponent, invokeHostBindingsInCreationMode, locateHostElement, markAsComponentHost, refreshView, registerHostBindingOpCodes, renderView} from './instructions/shared';\nimport {ComponentDef, ComponentType, RenderFlags} from './interfaces/definition';\nimport {TElementNode, TNodeType} from './interfaces/node';\nimport {PlayerHandler} from './interfaces/player';\nimport {domRendererFactory3, Renderer3, RendererFactory3} from './interfaces/renderer';\nimport {RElement} from './interfaces/renderer_dom';\nimport {CONTEXT, HEADER_OFFSET, LView, LViewFlags, RootContext, RootContextFlags, TVIEW, TViewType} from './interfaces/view';\nimport {writeDirectClass, writeDirectStyle} from './node_manipulation';\nimport {enterView, getCurrentTNode, leaveView, setSelectedIndex} from './state';\nimport {computeStaticStyling} from './styling/static_styling';\nimport {setUpAttributes} from './util/attrs_utils';\nimport {publishDefaultGlobalUtils} from './util/global_utils';\nimport {defaultScheduler} from './util/misc_utils';\nimport {getRootContext} from './util/view_traversal_utils';\nimport {readPatchedLView} from './util/view_utils';\n\n\n\n/** Options that control how the component should be bootstrapped. */\nexport interface CreateComponentOptions {\n  /** Which renderer factory to use. */\n  rendererFactory?: RendererFactory3;\n\n  /** A custom sanitizer instance */\n  sanitizer?: Sanitizer;\n\n  /** A custom animation player handler */\n  playerHandler?: PlayerHandler;\n\n  /**\n   * Host element on which the component will be bootstrapped. If not specified,\n   * the component definition's `tag` is used to query the existing DOM for the\n   * element to bootstrap.\n   */\n  host?: RElement|string;\n\n  /** Module injector for the component. If unspecified, the injector will be NULL_INJECTOR. */\n  injector?: Injector;\n\n  /**\n   * List of features to be applied to the created component. Features are simply\n   * functions that decorate a component with a certain behavior.\n   *\n   * Typically, the features in this list are features that cannot be added to the\n   * other features list in the component definition because they rely on other factors.\n   *\n   * Example: `LifecycleHooksFeature` is a function that adds lifecycle hook capabilities\n   * to root components in a tree-shakable way. It cannot be added to the component\n   * features list because there's no way of knowing when the component will be used as\n   * a root component.\n   */\n  hostFeatures?: HostFeature[];\n\n  /**\n   * A function which is used to schedule change detection work in the future.\n   *\n   * When marking components as dirty, it is necessary to schedule the work of\n   * change detection in the future. This is done to coalesce multiple\n   * {@link markDirty} calls into a single changed detection processing.\n   *\n   * The default value of the scheduler is the `requestAnimationFrame` function.\n   *\n   * It is also useful to override this function for testing purposes.\n   */\n  scheduler?: (work: () => void) => void;\n}\n\n/** See CreateComponentOptions.hostFeatures */\ntype HostFeature = (<T>(component: T, componentDef: ComponentDef<T>) => void);\n\n// TODO: A hack to not pull in the NullInjector from @angular/core.\nexport const NULL_INJECTOR: Injector = {\n  get: (token: any, notFoundValue?: any) => {\n    throwProviderNotFoundError(token, 'NullInjector');\n  }\n};\n\n/**\n * Bootstraps a Component into an existing host element and returns an instance\n * of the component.\n *\n * Use this function to bootstrap a component into the DOM tree. Each invocation\n * of this function will create a separate tree of components, injectors and\n * change detection cycles and lifetimes. To dynamically insert a new component\n * into an existing tree such that it shares the same injection, change detection\n * and object lifetime, use {@link ViewContainer#createComponent}.\n *\n * @param componentType Component to bootstrap\n * @param options Optional parameters which control bootstrapping\n */\nexport function renderComponent<T>(\n    componentType: ComponentType<T>|\n    Type<T>/* Type as workaround for: Microsoft/TypeScript/issues/4881 */\n    ,\n    opts: CreateComponentOptions = {}): T {\n  ngDevMode && publishDefaultGlobalUtils();\n  ngDevMode && assertComponentType(componentType);\n\n  const rendererFactory = opts.rendererFactory || domRendererFactory3;\n  const sanitizer = opts.sanitizer || null;\n  const componentDef = getComponentDef<T>(componentType)!;\n  if (componentDef.type != componentType) (componentDef as {type: Type<any>}).type = componentType;\n\n  // The first index of the first selector is the tag name.\n  const componentTag = componentDef.selectors![0]![0] as string;\n  const hostRenderer = rendererFactory.createRenderer(null, null);\n  const hostRNode =\n      locateHostElement(hostRenderer, opts.host || componentTag, componentDef.encapsulation);\n  const rootFlags = componentDef.onPush ? LViewFlags.Dirty | LViewFlags.IsRoot :\n                                          LViewFlags.CheckAlways | LViewFlags.IsRoot;\n  const rootContext = createRootContext(opts.scheduler, opts.playerHandler);\n\n  const renderer = rendererFactory.createRenderer(hostRNode, componentDef);\n  const rootTView = createTView(TViewType.Root, null, null, 1, 0, null, null, null, null, null);\n  const rootView: LView = createLView(\n      null, rootTView, rootContext, rootFlags, null, null, rendererFactory, renderer, null,\n      opts.injector || null);\n\n  enterView(rootView);\n  let component: T;\n\n  try {\n    if (rendererFactory.begin) rendererFactory.begin();\n    const componentView = createRootComponentView(\n        hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);\n    component = createRootComponent(\n        componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);\n\n    // create mode pass\n    renderView(rootTView, rootView, null);\n    // update mode pass\n    refreshView(rootTView, rootView, null, null);\n\n  } finally {\n    leaveView();\n    if (rendererFactory.end) rendererFactory.end();\n  }\n\n  return component;\n}\n\n/**\n * Creates the root component view and the root component node.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n * @param rootView The parent view where the host node is stored\n * @param rendererFactory Factory to be used for creating child renderers.\n * @param hostRenderer The current renderer\n * @param sanitizer The sanitizer, if provided\n *\n * @returns Component view created\n */\nexport function createRootComponentView(\n    rNode: RElement|null, def: ComponentDef<any>, rootView: LView,\n    rendererFactory: RendererFactory3, hostRenderer: Renderer3, sanitizer?: Sanitizer|null): LView {\n  const tView = rootView[TVIEW];\n  const index = HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(rootView, index);\n  rootView[index] = rNode;\n  // '#host' is added here as we don't know the real host DOM name (we don't want to read it) and at\n  // the same time we want to communicate the the debug `TNode` that this is a special `TNode`\n  // representing a host element.\n  const tNode: TElementNode = getOrCreateTNode(tView, index, TNodeType.Element, '#host', null);\n  const mergedAttrs = tNode.mergedAttrs = def.hostAttrs;\n  if (mergedAttrs !== null) {\n    computeStaticStyling(tNode, mergedAttrs, true);\n    if (rNode !== null) {\n      setUpAttributes(hostRenderer, rNode, mergedAttrs);\n      if (tNode.classes !== null) {\n        writeDirectClass(hostRenderer, rNode, tNode.classes);\n      }\n      if (tNode.styles !== null) {\n        writeDirectStyle(hostRenderer, rNode, tNode.styles);\n      }\n    }\n  }\n\n  const viewRenderer = rendererFactory.createRenderer(rNode, def);\n  const componentView = createLView(\n      rootView, getOrCreateTComponentView(def), null,\n      def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, rootView[index], tNode,\n      rendererFactory, viewRenderer, sanitizer || null, null);\n\n  if (tView.firstCreatePass) {\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);\n    markAsComponentHost(tView, tNode);\n    initTNodeFlags(tNode, rootView.length, 1);\n  }\n\n  addToViewTree(rootView, componentView);\n\n  // Store component view at node index, with node as the HOST\n  return rootView[index] = componentView;\n}\n\n/**\n * Creates a root component and sets it up with features and host bindings. Shared by\n * renderComponent() and ViewContainerRef.createComponent().\n */\nexport function createRootComponent<T>(\n    componentView: LView, componentDef: ComponentDef<T>, rootLView: LView, rootContext: RootContext,\n    hostFeatures: HostFeature[]|null): any {\n  const tView = rootLView[TVIEW];\n  // Create directive instance with factory() and store at next index in viewData\n  const component = instantiateRootComponent(tView, rootLView, componentDef);\n\n  rootContext.components.push(component);\n  componentView[CONTEXT] = component;\n\n  hostFeatures && hostFeatures.forEach((feature) => feature(component, componentDef));\n\n  // We want to generate an empty QueryList for root content queries for backwards\n  // compatibility with ViewEngine.\n  if (componentDef.contentQueries) {\n    const tNode = getCurrentTNode()!;\n    ngDevMode && assertDefined(tNode, 'TNode expected');\n    componentDef.contentQueries(RenderFlags.Create, component, tNode.directiveStart);\n  }\n\n  const rootTNode = getCurrentTNode()!;\n  ngDevMode && assertDefined(rootTNode, 'tNode should have been already created');\n  if (tView.firstCreatePass &&\n      (componentDef.hostBindings !== null || componentDef.hostAttrs !== null)) {\n    setSelectedIndex(rootTNode.index);\n\n    const rootTView = rootLView[TVIEW];\n    registerHostBindingOpCodes(\n        rootTView, rootTNode, rootLView, rootTNode.directiveStart, rootTNode.directiveEnd,\n        componentDef);\n\n    invokeHostBindingsInCreationMode(componentDef, component);\n  }\n  return component;\n}\n\n\nexport function createRootContext(\n    scheduler?: (workFn: () => void) => void, playerHandler?: PlayerHandler|null): RootContext {\n  return {\n    components: [],\n    scheduler: scheduler || defaultScheduler,\n    clean: CLEAN_PROMISE,\n    playerHandler: playerHandler || null,\n    flags: RootContextFlags.Empty\n  };\n}\n\n/**\n * Used to enable lifecycle hooks on the root component.\n *\n * Include this feature when calling `renderComponent` if the root component\n * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't\n * be called properly.\n *\n * Example:\n *\n * ```\n * renderComponent(AppComponent, {hostFeatures: [LifecycleHooksFeature]});\n * ```\n */\nexport function LifecycleHooksFeature(component: any, def: ComponentDef<any>): void {\n  const lView = readPatchedLView(component)!;\n  ngDevMode && assertDefined(lView, 'LView is required');\n  const tView = lView[TVIEW];\n  const tNode = getCurrentTNode()!;\n  ngDevMode && assertDefined(tNode, 'TNode is required');\n  registerPostOrderHooks(tView, tNode);\n}\n\n/**\n * Wait on component until it is rendered.\n *\n * This function returns a `Promise` which is resolved when the component's\n * change detection is executed. This is determined by finding the scheduler\n * associated with the `component`'s render tree and waiting until the scheduler\n * flushes. If nothing is scheduled, the function returns a resolved promise.\n *\n * Example:\n * ```\n * await whenRendered(myComponent);\n * ```\n *\n * @param component Component to wait upon\n * @returns Promise which resolves when the component is rendered.\n */\nexport function whenRendered(component: any): Promise<null> {\n  return getRootContext(component).clean;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global as _global} from './global';\n\n// When Symbol.iterator doesn't exist, retrieves the key used in es6-shim\ndeclare const Symbol: any;\nlet _symbolIterator: any = null;\nexport function getSymbolIterator(): string|symbol {\n  if (!_symbolIterator) {\n    const Symbol = _global['Symbol'];\n    if (Symbol && Symbol.iterator) {\n      _symbolIterator = Symbol.iterator;\n    } else {\n      // es6-shim specific logic\n      const keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key !== 'entries' && key !== 'size' &&\n            (Map as any).prototype[key] === Map.prototype['entries']) {\n          _symbolIterator = key;\n        }\n      }\n    }\n  }\n  return _symbolIterator;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getSymbolIterator} from '../util/symbol';\n\nexport function devModeEqual(a: any, b: any): boolean {\n  const isListLikeIterableA = isListLikeIterable(a);\n  const isListLikeIterableB = isListLikeIterable(b);\n  if (isListLikeIterableA && isListLikeIterableB) {\n    return areIterablesEqual(a, b, devModeEqual);\n  } else {\n    const isAObject = a && (typeof a === 'object' || typeof a === 'function');\n    const isBObject = b && (typeof b === 'object' || typeof b === 'function');\n    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n      return true;\n    } else {\n      return Object.is(a, b);\n    }\n  }\n}\n\n/**\n * Indicates that the result of a {@link Pipe} transformation has changed even though the\n * reference has not changed.\n *\n * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value\n * is stored.\n *\n * Example:\n *\n * ```\n * if (this._latestValue === this._latestReturnedValue) {\n *    return this._latestReturnedValue;\n *  } else {\n *    this._latestReturnedValue = this._latestValue;\n *    return WrappedValue.wrap(this._latestValue); // this will force update\n *  }\n * ```\n *\n * @publicApi\n * @deprecated from v10 stop using. (No replacement, deemed unnecessary.)\n */\nexport class WrappedValue {\n  /** @deprecated from 5.3, use `unwrap()` instead - will switch to protected */\n  wrapped: any;\n\n  constructor(value: any) {\n    this.wrapped = value;\n  }\n\n  /** Creates a wrapped value. */\n  static wrap(value: any): WrappedValue {\n    return new WrappedValue(value);\n  }\n\n  /**\n   * Returns the underlying value of a wrapped value.\n   * Returns the given `value` when it is not wrapped.\n   **/\n  static unwrap(value: any): any {\n    return WrappedValue.isWrapped(value) ? value.wrapped : value;\n  }\n\n  /** Returns true if `value` is a wrapped value. */\n  static isWrapped(value: any): value is WrappedValue {\n    return value instanceof WrappedValue;\n  }\n}\n\nexport function isListLikeIterable(obj: any): boolean {\n  if (!isJsObject(obj)) return false;\n  return Array.isArray(obj) ||\n      (!(obj instanceof Map) &&      // JS Map are iterables but return entries as [k, v]\n       getSymbolIterator() in obj);  // JS Iterable have a Symbol.iterator prop\n}\n\nexport function areIterablesEqual(\n    a: any, b: any, comparator: (a: any, b: any) => boolean): boolean {\n  const iterator1 = a[getSymbolIterator()]();\n  const iterator2 = b[getSymbolIterator()]();\n\n  while (true) {\n    const item1 = iterator1.next();\n    const item2 = iterator2.next();\n    if (item1.done && item2.done) return true;\n    if (item1.done || item2.done) return false;\n    if (!comparator(item1.value, item2.value)) return false;\n  }\n}\n\nexport function iterateListLike(obj: any, fn: (p: any) => any) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn(obj[i]);\n    }\n  } else {\n    const iterator = obj[getSymbolIterator()]();\n    let item: any;\n    while (!((item = iterator.next()).done)) {\n      fn(item.value);\n    }\n  }\n}\n\nexport function isJsObject(o: any): boolean {\n  return o !== null && (typeof o === 'function' || typeof o === 'object');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {devModeEqual} from '../change_detection/change_detection_util';\nimport {assertIndexInRange, assertLessThan, assertNotSame} from '../util/assert';\n\nimport {getExpressionChangedErrorDetails, throwErrorIfNoChangesMode} from './errors';\nimport {LView} from './interfaces/view';\nimport {isInCheckNoChangesMode} from './state';\nimport {NO_CHANGE} from './tokens';\n\n\n// TODO(misko): consider inlining\n/** Updates binding and returns the value. */\nexport function updateBinding(lView: LView, bindingIndex: number, value: any): any {\n  return lView[bindingIndex] = value;\n}\n\n\n/** Gets the current binding value. */\nexport function getBinding(lView: LView, bindingIndex: number): any {\n  ngDevMode && assertIndexInRange(lView, bindingIndex);\n  ngDevMode &&\n      assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return lView[bindingIndex];\n}\n\n/**\n * Updates binding if changed, then returns whether it was updated.\n *\n * This function also checks the `CheckNoChangesMode` and throws if changes are made.\n * Some changes (Objects/iterables) during `CheckNoChangesMode` are exempt to comply with VE\n * behavior.\n *\n * @param lView current `LView`\n * @param bindingIndex The binding in the `LView` to check\n * @param value New value to check against `lView[bindingIndex]`\n * @returns `true` if the bindings has changed. (Throws if binding has changed during\n *          `CheckNoChangesMode`)\n */\nexport function bindingUpdated(lView: LView, bindingIndex: number, value: any): boolean {\n  ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode &&\n      assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n  const oldValue = lView[bindingIndex];\n\n  if (Object.is(oldValue, value)) {\n    return false;\n  } else {\n    if (ngDevMode && isInCheckNoChangesMode()) {\n      // View engine didn't report undefined values as changed on the first checkNoChanges pass\n      // (before the change detection was run).\n      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;\n      if (!devModeEqual(oldValueToCompare, value)) {\n        const details =\n            getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);\n        throwErrorIfNoChangesMode(\n            oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName);\n      }\n      // There was a change, but the `devModeEqual` decided that the change is exempt from an error.\n      // For this reason we exit as if no change. The early exit is needed to prevent the changed\n      // value to be written into `LView` (If we would write the new value that we would not see it\n      // as change on next CD.)\n      return false;\n    }\n    lView[bindingIndex] = value;\n    return true;\n  }\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(lView: LView, bindingIndex: number, exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(lView, bindingIndex, exp1);\n  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\n\n/** Updates 3 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated3(\n    lView: LView, bindingIndex: number, exp1: any, exp2: any, exp3: any): boolean {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(\n    lView: LView, bindingIndex: number, exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectFlags, InjectionToken, resolveForwardRef} from '../../di';\nimport {assertInjectImplementationNotEqual} from '../../di/inject_switch';\nimport {ɵɵinject} from '../../di/injector_compatibility';\nimport {AbstractType, Type} from '../../interface/type';\nimport {getOrCreateInjectable} from '../di';\nimport {TDirectiveHostNode} from '../interfaces/node';\nimport {getCurrentTNode, getLView} from '../state';\n\n/**\n * Returns the value associated to the given token from the injectors.\n *\n * `directiveInject` is intended to be used for directive, component and pipe factories.\n *  All other injection use `inject` which does not walk the node injector tree.\n *\n * Usage example (in factory function):\n *\n * ```ts\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ɵdir = ɵɵdefineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(ɵɵdirectiveInject(DirectiveA))\n *   });\n * }\n * ```\n * @param token the type or token to inject\n * @param flags Injection flags\n * @returns the value from the injector or `null` when not found\n *\n * @codeGenApi\n */\nexport function ɵɵdirectiveInject<T>(token: Type<T>|AbstractType<T>|InjectionToken<T>): T;\nexport function ɵɵdirectiveInject<T>(\n    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags: InjectFlags): T;\nexport function ɵɵdirectiveInject<T>(\n    token: Type<T>|AbstractType<T>|InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  const lView = getLView();\n  // Fall back to inject() if view hasn't been created. This situation can happen in tests\n  // if inject utilities are used before bootstrapping.\n  if (lView === null) {\n    // Verify that we will not get into infinite loop.\n    ngDevMode && assertInjectImplementationNotEqual(ɵɵdirectiveInject);\n    return ɵɵinject(token, flags);\n  }\n  const tNode = getCurrentTNode();\n  return getOrCreateInjectable<T>(\n      tNode as TDirectiveHostNode, lView, resolveForwardRef(token), flags);\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport function ɵɵinvalidFactory(): never {\n  const msg =\n      ngDevMode ? `This constructor was not compatible with Dependency Injection.` : 'invalid';\n  throw new Error(msg);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {bindingUpdated} from '../bindings';\nimport {TNode} from '../interfaces/node';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {LView, RENDERER, TView} from '../interfaces/view';\nimport {getLView, getSelectedTNode, getTView, nextBindingIndex} from '../state';\n\nimport {elementPropertyInternal, setInputsForProperty, storePropertyBindingMetadata} from './shared';\n\n\n/**\n * Update a property on a selected element.\n *\n * Operates on the element selected by index via the {@link select} instruction.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new `@Inputs` don't have to be re-compiled\n *\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n * @returns This function returns itself so that it may be chained\n * (e.g. `property('name', ctx.name)('title', ctx.title)`)\n *\n * @codeGenApi\n */\nexport function ɵɵproperty<T>(\n    propName: string, value: T, sanitizer?: SanitizerFn|null): typeof ɵɵproperty {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(\n        tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return ɵɵproperty;\n}\n\n/**\n * Given `<div style=\"...\" my-dir>` and `MyDir` with `@Input('style')` we need to write to\n * directive input.\n */\nexport function setDirectiveInputsWhichShadowsStyling(\n    tView: TView, tNode: TNode, lView: LView, value: any, isClassBased: boolean) {\n  const inputs = tNode.inputs!;\n  const property = isClassBased ? 'class' : 'style';\n  // We support both 'class' and `className` hence the fallback.\n  setInputsForProperty(tView, lView, inputs[property], property, value);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual, assertIndexInRange} from '../../util/assert';\nimport {assertFirstCreatePass, assertHasParent} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {formatRuntimeError, RuntimeErrorCode} from '../error_code';\nimport {registerPostOrderHooks} from '../hooks';\nimport {hasClassInput, hasStyleInput, TAttributes, TElementNode, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {isContentQueryHost, isDirectiveHost} from '../interfaces/type_checks';\nimport {HEADER_OFFSET, LView, RENDERER, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {appendChild, createElementNode, writeDirectClass, writeDirectStyle} from '../node_manipulation';\nimport {decreaseElementDepthCount, getBindingIndex, getCurrentTNode, getElementDepthCount, getLView, getNamespace, getTView, increaseElementDepthCount, isCurrentTNodeParent, setCurrentTNode, setCurrentTNodeAsNotParent} from '../state';\nimport {computeStaticStyling} from '../styling/static_styling';\nimport {setUpAttributes} from '../util/attrs_utils';\nimport {getConstant} from '../util/view_utils';\nimport {setDirectiveInputsWhichShadowsStyling} from './property';\nimport {createDirectivesInstances, executeContentQueries, getOrCreateTNode, matchingSchemas, resolveDirectives, saveResolvedLocalsInData} from './shared';\n\n\n\nfunction elementStartFirstCreatePass(\n    index: number, tView: TView, lView: LView, native: RElement, name: string,\n    attrsIndex?: number|null, localRefsIndex?: number): TElementNode {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n\n  const tViewConsts = tView.consts;\n  const attrs = getConstant<TAttributes>(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, TNodeType.Element, name, attrs);\n\n  const hasDirectives =\n      resolveDirectives(tView, lView, tNode, getConstant<string[]>(tViewConsts, localRefsIndex));\n  ngDevMode && logUnknownElementError(tView, native, tNode, hasDirectives);\n\n  if (tNode.attrs !== null) {\n    computeStaticStyling(tNode, tNode.attrs, false);\n  }\n\n  if (tNode.mergedAttrs !== null) {\n    computeStaticStyling(tNode, tNode.mergedAttrs, true);\n  }\n\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LView array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n *\n * @codeGenApi\n */\nexport function ɵɵelementStart(\n    index: number, name: string, attrsIndex?: number|null, localRefsIndex?: number): void {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = HEADER_OFFSET + index;\n\n  ngDevMode &&\n      assertEqual(\n          getBindingIndex(), tView.bindingStartIndex,\n          'elements should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n\n  const renderer = lView[RENDERER];\n  const native = lView[adjustedIndex] = createElementNode(renderer, name, getNamespace());\n  const tNode = tView.firstCreatePass ?\n      elementStartFirstCreatePass(\n          adjustedIndex, tView, lView, native, name, attrsIndex, localRefsIndex) :\n      tView.data[adjustedIndex] as TElementNode;\n  setCurrentTNode(tNode, true);\n\n  const mergedAttrs = tNode.mergedAttrs;\n  if (mergedAttrs !== null) {\n    setUpAttributes(renderer, native, mergedAttrs);\n  }\n  const classes = tNode.classes;\n  if (classes !== null) {\n    writeDirectClass(renderer, native, classes);\n  }\n  const styles = tNode.styles;\n  if (styles !== null) {\n    writeDirectStyle(renderer, native, styles);\n  }\n\n  if ((tNode.flags & TNodeFlags.isDetached) !== TNodeFlags.isDetached) {\n    // In the i18n case, the translation may have removed this element, so only add it if it is not\n    // detached. See `TNodeType.Placeholder` and `LFrame.inI18n` for more context.\n    appendChild(tView, lView, native, tNode);\n  }\n\n  // any immediate children of a component or template container must be pre-emptively\n  // monkey-patched with the component view data so that the element can be inspected\n  // later on using any element discovery utility methods (see `element_discovery.ts`)\n  if (getElementDepthCount() === 0) {\n    attachPatchData(native, lView);\n  }\n  increaseElementDepthCount();\n\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n  if (localRefsIndex !== null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n}\n\n/**\n * Mark the end of the element.\n *\n * @codeGenApi\n */\nexport function ɵɵelementEnd(): void {\n  let currentTNode = getCurrentTNode()!;\n  ngDevMode && assertDefined(currentTNode, 'No parent node to close.');\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(getCurrentTNode());\n    currentTNode = currentTNode.parent!;\n    setCurrentTNode(currentTNode, false);\n  }\n\n  const tNode = currentTNode;\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode);\n\n\n  decreaseElementDepthCount();\n\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, currentTNode);\n    if (isContentQueryHost(currentTNode)) {\n      tView.queries!.elementEnd(currentTNode);\n    }\n  }\n\n  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);\n  }\n\n  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);\n  }\n}\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrsIndex Index of the element's attributes in the `consts` array.\n * @param localRefsIndex Index of the element's local references in the `consts` array.\n *\n * @codeGenApi\n */\nexport function ɵɵelement(\n    index: number, name: string, attrsIndex?: number|null, localRefsIndex?: number): void {\n  ɵɵelementStart(index, name, attrsIndex, localRefsIndex);\n  ɵɵelementEnd();\n}\n\nfunction logUnknownElementError(\n    tView: TView, element: RElement, tNode: TNode, hasDirectives: boolean): void {\n  const schemas = tView.schemas;\n\n  // If `schemas` is set to `null`, that's an indication that this Component was compiled in AOT\n  // mode where this check happens at compile time. In JIT mode, `schemas` is always present and\n  // defined as an array (as an empty array in case `schemas` field is not defined) and we should\n  // execute the check below.\n  if (schemas === null) return;\n\n  const tagName = tNode.value;\n\n  // If the element matches any directive, it's considered as valid.\n  if (!hasDirectives && tagName !== null) {\n    // The element is unknown if it's an instance of HTMLUnknownElement or it isn't registered\n    // as a custom element. Note that unknown elements with a dash in their name won't be instances\n    // of HTMLUnknownElement in browsers that support web components.\n    const isUnknown =\n        // Note that we can't check for `typeof HTMLUnknownElement === 'function'`,\n        // because while most browsers return 'function', IE returns 'object'.\n        (typeof HTMLUnknownElement !== 'undefined' && HTMLUnknownElement &&\n         element instanceof HTMLUnknownElement) ||\n        (typeof customElements !== 'undefined' && tagName.indexOf('-') > -1 &&\n         !customElements.get(tagName));\n\n    if (isUnknown && !matchingSchemas(tView, tagName)) {\n      let message = `'${tagName}' is not a known element:\\n`;\n      message += `1. If '${\n          tagName}' is an Angular component, then verify that it is part of this module.\\n`;\n      if (tagName && tagName.indexOf('-') > -1) {\n        message += `2. If '${\n            tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;\n      } else {\n        message +=\n            `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n      }\n      console.error(formatRuntimeError(RuntimeErrorCode.UNKNOWN_ELEMENT, message));\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {KeyValueArray} from '../../util/array_utils';\nimport {TStylingRange} from '../interfaces/styling';\nimport {TIcu} from './i18n';\nimport {CssSelector} from './projection';\nimport {RNode} from './renderer_dom';\nimport {LView, TView} from './view';\n\n\n/**\n * TNodeType corresponds to the {@link TNode} `type` property.\n *\n * NOTE: type IDs are such that we use each bit to denote a type. This is done so that we can easily\n * check if the `TNode` is of more than one type.\n *\n * `if (tNode.type === TNodeType.Text || tNode.type === TNode.Element)`\n * can be written as:\n * `if (tNode.type & (TNodeType.Text | TNodeType.Element))`\n *\n * However any given `TNode` can only be of one type.\n */\nexport const enum TNodeType {\n  /**\n   * The TNode contains information about a DOM element aka {@link RText}.\n   */\n  Text = 0b1,\n\n  /**\n   * The TNode contains information about a DOM element aka {@link RElement}.\n   */\n  Element = 0b10,\n\n  /**\n   * The TNode contains information about an {@link LContainer} for embedded views.\n   */\n  Container = 0b100,\n\n  /**\n   * The TNode contains information about an `<ng-container>` element {@link RNode}.\n   */\n  ElementContainer = 0b1000,\n\n  /**\n   * The TNode contains information about an `<ng-content>` projection\n   */\n  Projection = 0b10000,\n\n  /**\n   * The TNode contains information about an ICU comment used in `i18n`.\n   */\n  Icu = 0b100000,\n\n  /**\n   * Special node type representing a placeholder for future `TNode` at this location.\n   *\n   * I18n translation blocks are created before the element nodes which they contain. (I18n blocks\n   * can span over many elements.) Because i18n `TNode`s (representing text) are created first they\n   * often may need to point to element `TNode`s which are not yet created. In such a case we create\n   * a `Placeholder` `TNode`. This allows the i18n to structurally link the `TNode`s together\n   * without knowing any information about the future nodes which will be at that location.\n   *\n   * On `firstCreatePass` When element instruction executes it will try to create a `TNode` at that\n   * location. Seeing a `Placeholder` `TNode` already there tells the system that it should reuse\n   * existing `TNode` (rather than create a new one) and just update the missing information.\n   */\n  Placeholder = 0b1000000,\n\n  // Combined Types These should never be used for `TNode.type` only as a useful way to check\n  // if `TNode.type` is one of several choices.\n\n  // See: https://github.com/microsoft/TypeScript/issues/35875 why we can't refer to existing enum.\n  AnyRNode = 0b11,        // Text | Element,\n  AnyContainer = 0b1100,  // Container | ElementContainer, // See:\n}\n\n/**\n * Converts `TNodeType` into human readable text.\n * Make sure this matches with `TNodeType`\n */\nexport function toTNodeTypeAsString(tNodeType: TNodeType): string {\n  let text = '';\n  (tNodeType & TNodeType.Text) && (text += '|Text');\n  (tNodeType & TNodeType.Element) && (text += '|Element');\n  (tNodeType & TNodeType.Container) && (text += '|Container');\n  (tNodeType & TNodeType.ElementContainer) && (text += '|ElementContainer');\n  (tNodeType & TNodeType.Projection) && (text += '|Projection');\n  (tNodeType & TNodeType.Icu) && (text += '|IcuContainer');\n  (tNodeType & TNodeType.Placeholder) && (text += '|Placeholder');\n  return text.length > 0 ? text.substring(1) : text;\n}\n\n/**\n * Corresponds to the TNode.flags property.\n */\nexport const enum TNodeFlags {\n  /** Bit #1 - This bit is set if the node is a host for any directive (including a component) */\n  isDirectiveHost = 0x1,\n\n  /**\n   * Bit #2 - This bit is set if the node is a host for a component.\n   *\n   * Setting this bit implies that the `isDirectiveHost` bit is set as well.\n   * */\n  isComponentHost = 0x2,\n\n  /** Bit #3 - This bit is set if the node has been projected */\n  isProjected = 0x4,\n\n  /** Bit #4 - This bit is set if any directive on this node has content queries */\n  hasContentQuery = 0x8,\n\n  /** Bit #5 - This bit is set if the node has any \"class\" inputs */\n  hasClassInput = 0x10,\n\n  /** Bit #6 - This bit is set if the node has any \"style\" inputs */\n  hasStyleInput = 0x20,\n\n  /** Bit #7 This bit is set if the node has been detached by i18n */\n  isDetached = 0x40,\n\n  /**\n   * Bit #8 - This bit is set if the node has directives with host bindings.\n   *\n   * This flags allows us to guard host-binding logic and invoke it only on nodes\n   * that actually have directives with host bindings.\n   */\n  hasHostBindings = 0x80,\n}\n\n/**\n * Corresponds to the TNode.providerIndexes property.\n */\nexport const enum TNodeProviderIndexes {\n  /** The index of the first provider on this node is encoded on the least significant bits. */\n  ProvidersStartIndexMask = 0b00000000000011111111111111111111,\n\n  /**\n   * The count of view providers from the component on this node is\n   * encoded on the 20 most significant bits.\n   */\n  CptViewProvidersCountShift = 20,\n  CptViewProvidersCountShifter = 0b00000000000100000000000000000000,\n}\n\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * An implicit marker which indicates that the value in the array are of `attributeKey`,\n   * `attributeValue` format.\n   *\n   * NOTE: This is implicit as it is the type when no marker is present in array. We indicate that\n   * it should not be present at runtime by the negative number.\n   */\n  ImplicitAttributes = -1,\n\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * Signals class declaration.\n   *\n   * Each value following `Classes` designates a class name to include on the element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div class=\"foo bar baz\">...<d/vi>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n   * ```\n   */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed\n   * `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   */\n  I18n = 6,\n}\n\n/**\n * A combination of:\n * - Attribute names and values.\n * - Special markers acting as flags to alter attributes processing.\n * - Parsed ngProjectAs selectors.\n */\nexport type TAttributes = (string|AttributeMarker|CssSelector)[];\n\n/**\n * Constants that are associated with a view. Includes:\n * - Attribute arrays.\n * - Local definition arrays.\n * - Translated messages (i18n).\n */\nexport type TConstants = (TAttributes|string)[];\n\n/**\n * Factory function that returns an array of consts. Consts can be represented as a function in\n * case any additional statements are required to define consts in the list. An example is i18n\n * where additional i18n calls are generated, which should be executed when consts are requested\n * for the first time.\n */\nexport type TConstantsFactory = () => TConstants;\n\n/**\n * TConstants type that describes how the `consts` field is generated on ComponentDef: it can be\n * either an array or a factory function that returns that array.\n */\nexport type TConstantsOrFactory = TConstants|TConstantsFactory;\n\n/**\n * Binding data (flyweight) for a particular node that is shared between all templates\n * of a specific type.\n *\n * If a property is:\n *    - PropertyAliases: that property's data was generated and this is it\n *    - Null: that property's data was already generated and nothing was found.\n *    - Undefined: that property's data has not yet been generated\n *\n * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern\n */\nexport interface TNode {\n  /** The type of the TNode. See TNodeType. */\n  type: TNodeType;\n\n  /**\n   * Index of the TNode in TView.data and corresponding native element in LView.\n   *\n   * This is necessary to get from any TNode to its corresponding native element when\n   * traversing the node tree.\n   *\n   * If index is -1, this is a dynamically created container node or embedded view node.\n   */\n  index: number;\n\n  /**\n   * Insert before existing DOM node index.\n   *\n   * When DOM nodes are being inserted, normally they are being appended as they are created.\n   * Under i18n case, the translated text nodes are created ahead of time as part of the\n   * `ɵɵi18nStart` instruction which means that this `TNode` can't just be appended and instead\n   * needs to be inserted using `insertBeforeIndex` semantics.\n   *\n   * Additionally sometimes it is necessary to insert new text nodes as a child of this `TNode`. In\n   * such a case the value stores an array of text nodes to insert.\n   *\n   * Example:\n   * ```\n   * <div i18n>\n   *   Hello <span>World</span>!\n   * </div>\n   * ```\n   * In the above example the `ɵɵi18nStart` instruction can create `Hello `, `World` and `!` text\n   * nodes. It can also insert `Hello ` and `!` text node as a child of `<div>`, but it can't\n   * insert `World` because the `<span>` node has not yet been created. In such a case the\n   * `<span>` `TNode` will have an array which will direct the `<span>` to not only insert\n   * itself in front of `!` but also to insert the `World` (created by `ɵɵi18nStart`) into\n   * `<span>` itself.\n   *\n   * Pseudo code:\n   * ```\n   *   if (insertBeforeIndex === null) {\n   *     // append as normal\n   *   } else if (Array.isArray(insertBeforeIndex)) {\n   *     // First insert current `TNode` at correct location\n   *     const currentNode = lView[this.index];\n   *     parentNode.insertBefore(currentNode, lView[this.insertBeforeIndex[0]]);\n   *     // Now append all of the children\n   *     for(let i=1; i<this.insertBeforeIndex; i++) {\n   *       currentNode.appendChild(lView[this.insertBeforeIndex[i]]);\n   *     }\n   *   } else {\n   *     parentNode.insertBefore(lView[this.index], lView[this.insertBeforeIndex])\n   *   }\n   * ```\n   * - null: Append as normal using `parentNode.appendChild`\n   * - `number`: Append using\n   *      `parentNode.insertBefore(lView[this.index], lView[this.insertBeforeIndex])`\n   *\n   * *Initialization*\n   *\n   * Because `ɵɵi18nStart` executes before nodes are created, on `TView.firstCreatePass` it is not\n   * possible for `ɵɵi18nStart` to set the `insertBeforeIndex` value as the corresponding `TNode`\n   * has not yet been created. For this reason the `ɵɵi18nStart` creates a `TNodeType.Placeholder`\n   * `TNode` at that location. See `TNodeType.Placeholder` for more information.\n   */\n  insertBeforeIndex: InsertBeforeIndex;\n\n  /**\n   * The index of the closest injector in this node's LView.\n   *\n   * If the index === -1, there is no injector on this node or any ancestor node in this view.\n   *\n   * If the index !== -1, it is the index of this node's injector OR the index of a parent\n   * injector in the same view. We pass the parent injector index down the node tree of a view so\n   * it's possible to find the parent injector without walking a potentially deep node tree.\n   * Injector indices are not set across view boundaries because there could be multiple component\n   * hosts.\n   *\n   * If tNode.injectorIndex === tNode.parent.injectorIndex, then the index belongs to a parent\n   * injector.\n   */\n  injectorIndex: number;\n\n  /**\n   * Stores starting index of the directives.\n   *\n   * NOTE: The first directive is always component (if present).\n   */\n  directiveStart: number;\n\n  /**\n   * Stores final exclusive index of the directives.\n   *\n   * The area right behind the `directiveStart-directiveEnd` range is used to allocate the\n   * `HostBindingFunction` `vars` (or null if no bindings.) Therefore `directiveEnd` is used to set\n   * `LFrame.bindingRootIndex` before `HostBindingFunction` is executed.\n   */\n  directiveEnd: number;\n\n  /**\n   * Stores the last directive which had a styling instruction.\n   *\n   * Initial value of this is `-1` which means that no `hostBindings` styling instruction has\n   * executed. As `hostBindings` instructions execute they set the value to the index of the\n   * `DirectiveDef` which contained the last `hostBindings` styling instruction.\n   *\n   * Valid values are:\n   * - `-1` No `hostBindings` instruction has executed.\n   * - `directiveStart <= directiveStylingLast < directiveEnd`: Points to the `DirectiveDef` of\n   * the last styling instruction which executed in the `hostBindings`.\n   *\n   * This data is needed so that styling instructions know which static styling data needs to be\n   * collected from the `DirectiveDef.hostAttrs`. A styling instruction needs to collect all data\n   * since last styling instruction.\n   */\n  directiveStylingLast: number;\n\n  /**\n   * Stores indexes of property bindings. This field is only set in the ngDevMode and holds\n   * indexes of property bindings so TestBed can get bound property metadata for a given node.\n   */\n  propertyBindings: number[]|null;\n\n  /**\n   * Stores if Node isComponent, isProjected, hasContentQuery, hasClassInput and hasStyleInput\n   * etc.\n   */\n  flags: TNodeFlags;\n\n  /**\n   * This number stores two values using its bits:\n   *\n   * - the index of the first provider on that node (first 16 bits)\n   * - the count of view providers from the component on this node (last 16 bits)\n   */\n  // TODO(misko): break this into actual vars.\n  providerIndexes: TNodeProviderIndexes;\n\n  /**\n   * The value name associated with this node.\n   * if type:\n   *   `TNodeType.Text`: text value\n   *   `TNodeType.Element`: tag name\n   *   `TNodeType.ICUContainer`: `TIcu`\n   */\n  value: any;\n\n  /**\n   * Attributes associated with an element. We need to store attributes to support various\n   * use-cases (attribute injection, content projection with selectors, directives matching).\n   * Attributes are stored statically because reading them from the DOM would be way too slow for\n   * content projection and queries.\n   *\n   * Since attrs will always be calculated first, they will never need to be marked undefined by\n   * other instructions.\n   *\n   * For regular attributes a name of an attribute and its value alternate in the array.\n   * e.g. ['role', 'checkbox']\n   * This array can contain flags that will indicate \"special attributes\" (attributes with\n   * namespaces, attributes extracted from bindings and outputs).\n   */\n  attrs: TAttributes|null;\n\n  /**\n   * Same as `TNode.attrs` but contains merged data across all directive host bindings.\n   *\n   * We need to keep `attrs` as unmerged so that it can be used for attribute selectors.\n   * We merge attrs here so that it can be used in a performant way for initial rendering.\n   *\n   * The `attrs` are merged in first pass in following order:\n   * - Component's `hostAttrs`\n   * - Directives' `hostAttrs`\n   * - Template `TNode.attrs` associated with the current `TNode`.\n   */\n  mergedAttrs: TAttributes|null;\n\n  /**\n   * A set of local names under which a given element is exported in a template and\n   * visible to queries. An entry in this array can be created for different reasons:\n   * - an element itself is referenced, ex.: `<div #foo>`\n   * - a component is referenced, ex.: `<my-cmpt #foo>`\n   * - a directive is referenced, ex.: `<my-cmpt #foo=\"directiveExportAs\">`.\n   *\n   * A given element might have different local names and those names can be associated\n   * with a directive. We store local names at even indexes while odd indexes are reserved\n   * for directive index in a view (or `-1` if there is no associated directive).\n   *\n   * Some examples:\n   * - `<div #foo>` => `[\"foo\", -1]`\n   * - `<my-cmpt #foo>` => `[\"foo\", myCmptIdx]`\n   * - `<my-cmpt #foo #bar=\"directiveExportAs\">` => `[\"foo\", myCmptIdx, \"bar\", directiveIdx]`\n   * - `<div #foo #bar=\"directiveExportAs\">` => `[\"foo\", -1, \"bar\", directiveIdx]`\n   */\n  localNames: (string|number)[]|null;\n\n  /** Information about input properties that need to be set once from attribute data. */\n  initialInputs: InitialInputData|null|undefined;\n\n  /**\n   * Input data for all directives on this node. `null` means that there are no directives with\n   * inputs on this node.\n   */\n  inputs: PropertyAliases|null;\n\n  /**\n   * Output data for all directives on this node. `null` means that there are no directives with\n   * outputs on this node.\n   */\n  outputs: PropertyAliases|null;\n\n  /**\n   * The TView or TViews attached to this node.\n   *\n   * If this TNode corresponds to an LContainer with inline views, the container will\n   * need to store separate static data for each of its view blocks (TView[]). Otherwise,\n   * nodes in inline views with the same index as nodes in their parent views will overwrite\n   * each other, as they are in the same template.\n   *\n   * Each index in this array corresponds to the static data for a certain\n   * view. So if you had V(0) and V(1) in a container, you might have:\n   *\n   * [\n   *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView\n   *   [{tagName: 'button', attrs ...}, null]    // V(1) TView\n   *\n   * If this TNode corresponds to an LContainer with a template (e.g. structural\n   * directive), the template's TView will be stored here.\n   *\n   * If this TNode corresponds to an element, tViews will be null .\n   */\n  tViews: TView|TView[]|null;\n\n  /**\n   * The next sibling node. Necessary so we can propagate through the root nodes of a view\n   * to insert them or remove them from the DOM.\n   */\n  next: TNode|null;\n\n  /**\n   * The next projected sibling. Since in Angular content projection works on the node-by-node\n   * basis the act of projecting nodes might change nodes relationship at the insertion point\n   * (target view). At the same time we need to keep initial relationship between nodes as\n   * expressed in content view.\n   */\n  projectionNext: TNode|null;\n\n  /**\n   * First child of the current node.\n   *\n   * For component nodes, the child will always be a ContentChild (in same view).\n   * For embedded view nodes, the child will be in their child view.\n   */\n  child: TNode|null;\n\n  /**\n   * Parent node (in the same view only).\n   *\n   * We need a reference to a node's parent so we can append the node to its parent's native\n   * element at the appropriate time.\n   *\n   * If the parent would be in a different view (e.g. component host), this property will be null.\n   * It's important that we don't try to cross component boundaries when retrieving the parent\n   * because the parent will change (e.g. index, attrs) depending on where the component was\n   * used (and thus shouldn't be stored on TNode). In these cases, we retrieve the parent through\n   * LView.node instead (which will be instance-specific).\n   *\n   * If this is an inline view node (V), the parent will be its container.\n   */\n  parent: TElementNode|TContainerNode|null;\n\n  /**\n   * List of projected TNodes for a given component host element OR index into the said nodes.\n   *\n   * For easier discussion assume this example:\n   * `<parent>`'s view definition:\n   * ```\n   * <child id=\"c1\">content1</child>\n   * <child id=\"c2\"><span>content2</span></child>\n   * ```\n   * `<child>`'s view definition:\n   * ```\n   * <ng-content id=\"cont1\"></ng-content>\n   * ```\n   *\n   * If `Array.isArray(projection)` then `TNode` is a host element:\n   * - `projection` stores the content nodes which are to be projected.\n   *    - The nodes represent categories defined by the selector: For example:\n   *      `<ng-content/><ng-content select=\"abc\"/>` would represent the heads for `<ng-content/>`\n   *      and `<ng-content select=\"abc\"/>` respectively.\n   *    - The nodes we store in `projection` are heads only, we used `.next` to get their\n   *      siblings.\n   *    - The nodes `.next` is sorted/rewritten as part of the projection setup.\n   *    - `projection` size is equal to the number of projections `<ng-content>`. The size of\n   *      `c1` will be `1` because `<child>` has only one `<ng-content>`.\n   * - we store `projection` with the host (`c1`, `c2`) rather than the `<ng-content>` (`cont1`)\n   *   because the same component (`<child>`) can be used in multiple locations (`c1`, `c2`) and\n   * as a result have different set of nodes to project.\n   * - without `projection` it would be difficult to efficiently traverse nodes to be projected.\n   *\n   * If `typeof projection == 'number'` then `TNode` is a `<ng-content>` element:\n   * - `projection` is an index of the host's `projection`Nodes.\n   *   - This would return the first head node to project:\n   *     `getHost(currentTNode).projection[currentTNode.projection]`.\n   * - When projecting nodes the parent node retrieved may be a `<ng-content>` node, in which case\n   *   the process is recursive in nature.\n   *\n   * If `projection` is of type `RNode[][]` than we have a collection of native nodes passed as\n   * projectable nodes during dynamic component creation.\n   */\n  projection: (TNode|RNode[])[]|number|null;\n\n  /**\n   * A collection of all `style` static values for an element (including from host).\n   *\n   * This field will be populated if and when:\n   *\n   * - There are one or more initial `style`s on an element (e.g. `<div style=\"width:200px;\">`)\n   * - There are one or more initial `style`s on a directive/component host\n   *   (e.g. `@Directive({host: {style: \"width:200px;\" } }`)\n   */\n  styles: string|null;\n\n\n  /**\n   * A collection of all `style` static values for an element excluding host sources.\n   *\n   * Populated when there are one or more initial `style`s on an element\n   * (e.g. `<div style=\"width:200px;\">`)\n   * Must be stored separately from `tNode.styles` to facilitate setting directive\n   * inputs that shadow the `style` property. If we used `tNode.styles` as is for shadowed inputs,\n   * we would feed host styles back into directives as \"inputs\". If we used `tNode.attrs`, we\n   * would have to concatenate the attributes on every template pass. Instead, we process once on\n   * first create pass and store here.\n   */\n  stylesWithoutHost: string|null;\n\n  /**\n   * A `KeyValueArray` version of residual `styles`.\n   *\n   * When there are styling instructions than each instruction stores the static styling\n   * which is of lower priority than itself. This means that there may be a higher priority\n   * styling than the instruction.\n   *\n   * Imagine:\n   * ```\n   * <div style=\"color: highest;\" my-dir>\n   *\n   * @Directive({\n   *   host: {\n   *     style: 'color: lowest; ',\n   *     '[styles.color]': 'exp' // ɵɵstyleProp('color', ctx.exp);\n   *   }\n   * })\n   * ```\n   *\n   * In the above case:\n   * - `color: lowest` is stored with `ɵɵstyleProp('color', ctx.exp);` instruction\n   * -  `color: highest` is the residual and is stored here.\n   *\n   * - `undefined': not initialized.\n   * - `null`: initialized but `styles` is `null`\n   * - `KeyValueArray`: parsed version of `styles`.\n   */\n  residualStyles: KeyValueArray<any>|undefined|null;\n\n  /**\n   * A collection of all class static values for an element (including from host).\n   *\n   * This field will be populated if and when:\n   *\n   * - There are one or more initial classes on an element (e.g. `<div class=\"one two three\">`)\n   * - There are one or more initial classes on an directive/component host\n   *   (e.g. `@Directive({host: {class: \"SOME_CLASS\" } }`)\n   */\n  classes: string|null;\n\n  /**\n   * A collection of all class static values for an element excluding host sources.\n   *\n   * Populated when there are one or more initial classes on an element\n   * (e.g. `<div class=\"SOME_CLASS\">`)\n   * Must be stored separately from `tNode.classes` to facilitate setting directive\n   * inputs that shadow the `class` property. If we used `tNode.classes` as is for shadowed\n   * inputs, we would feed host classes back into directives as \"inputs\". If we used\n   * `tNode.attrs`, we would have to concatenate the attributes on every template pass. Instead,\n   * we process once on first create pass and store here.\n   */\n  classesWithoutHost: string|null;\n\n  /**\n   * A `KeyValueArray` version of residual `classes`.\n   *\n   * Same as `TNode.residualStyles` but for classes.\n   *\n   * - `undefined': not initialized.\n   * - `null`: initialized but `classes` is `null`\n   * - `KeyValueArray`: parsed version of `classes`.\n   */\n  residualClasses: KeyValueArray<any>|undefined|null;\n\n  /**\n   * Stores the head/tail index of the class bindings.\n   *\n   * - If no bindings, the head and tail will both be 0.\n   * - If there are template bindings, stores the head/tail of the class bindings in the template.\n   * - If no template bindings but there are host bindings, the head value will point to the last\n   *   host binding for \"class\" (not the head of the linked list), tail will be 0.\n   *\n   * See: `style_binding_list.ts` for details.\n   *\n   * This is used by `insertTStylingBinding` to know where the next styling binding should be\n   * inserted so that they can be sorted in priority order.\n   */\n  classBindings: TStylingRange;\n\n  /**\n   * Stores the head/tail index of the class bindings.\n   *\n   * - If no bindings, the head and tail will both be 0.\n   * - If there are template bindings, stores the head/tail of the style bindings in the template.\n   * - If no template bindings but there are host bindings, the head value will point to the last\n   *   host binding for \"style\" (not the head of the linked list), tail will be 0.\n   *\n   * See: `style_binding_list.ts` for details.\n   *\n   * This is used by `insertTStylingBinding` to know where the next styling binding should be\n   * inserted so that they can be sorted in priority order.\n   */\n  styleBindings: TStylingRange;\n}\n\n/**\n * See `TNode.insertBeforeIndex`\n */\nexport type InsertBeforeIndex = null|number|number[];\n\n/** Static data for an element  */\nexport interface TElementNode extends TNode {\n  /** Index in the data[] array */\n  index: number;\n  child: TElementNode|TTextNode|TElementContainerNode|TContainerNode|TProjectionNode|null;\n  /**\n   * Element nodes will have parents unless they are the first node of a component or\n   * embedded view (which means their parent is in a different view and must be\n   * retrieved using viewData[HOST_NODE]).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /**\n   * If this is a component TNode with projection, this will be an array of projected\n   * TNodes or native nodes (see TNode.projection for more info). If it's a regular element node\n   * or a component without projection, it will be null.\n   */\n  projection: (TNode|RNode[])[]|null;\n\n  /**\n   * Stores TagName\n   */\n  value: string;\n}\n\n/** Static data for a text node */\nexport interface TTextNode extends TNode {\n  /** Index in the data[] array */\n  index: number;\n  child: null;\n  /**\n   * Text nodes will have parents unless they are the first node of a component or\n   * embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an LContainer */\nexport interface TContainerNode extends TNode {\n  /**\n   * Index in the data[] array.\n   *\n   * If it's -1, this is a dynamically created container node that isn't stored in\n   * data[] (e.g. when you inject ViewContainerRef) .\n   */\n  index: number;\n  child: null;\n\n  /**\n   * Container nodes will have parents unless:\n   *\n   * - They are the first node of a component or embedded view\n   * - They are dynamically created\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: TView|TView[]|null;\n  projection: null;\n  value: null;\n}\n\n/** Static data for an <ng-container> */\nexport interface TElementContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: TElementNode|TTextNode|TContainerNode|TElementContainerNode|TProjectionNode|null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an ICU expression */\nexport interface TIcuContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n  value: TIcu;\n}\n\n/** Static data for an LProjectionNode  */\nexport interface TProjectionNode extends TNode {\n  /** Index in the data[] array */\n  child: null;\n  /**\n   * Projection nodes will have parents unless they are the first node of a component\n   * or embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /** Index of the projection node. (See TNode.projection for more info.) */\n  projection: number;\n  value: null;\n}\n\n/**\n * A union type representing all TNode types that can host a directive.\n */\nexport type TDirectiveHostNode = TElementNode|TContainerNode|TElementContainerNode;\n\n/**\n * This mapping is necessary so we can set input properties and output listeners\n * properly at runtime when property names are minified or aliased.\n *\n * Key: unminified / public input or output name\n * Value: array containing minified / internal name and related directive index\n *\n * The value must be an array to support inputs and outputs with the same name\n * on the same node.\n */\nexport type PropertyAliases = {\n  // This uses an object map because using the Map type would be too slow\n  [key: string]: PropertyAliasValue\n};\n\n/**\n * Store the runtime input or output names for all the directives.\n *\n * i+0: directive instance index\n * i+1: privateName\n *\n * e.g. [0, 'change-minified']\n */\nexport type PropertyAliasValue = (number|string)[];\n\n/**\n * This array contains information about input properties that\n * need to be set once from attribute data. It's ordered by\n * directive index (relative to element) so it's simple to\n * look up a specific directive's initial input data.\n *\n * Within each sub-array:\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * If a directive on a node does not have any input properties\n * that should be set from attributes, its index is set to null\n * to avoid a sparse array.\n *\n * e.g. [null, ['role-min', 'minified-input', 'button']]\n */\nexport type InitialInputData = (InitialInputs|null)[];\n\n/**\n * Used by InitialInputData to store input properties\n * that should be set once from attributes.\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * e.g. ['role-min', 'minified-input', 'button']\n */\nexport type InitialInputs = string[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Type representing a set of TNodes that can have local refs (`#foo`) placed on them.\n */\nexport type TNodeWithLocalRefs = TContainerNode|TElementNode|TElementContainerNode;\n\n/**\n * Type for a function that extracts a value for a local refs.\n * Example:\n * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;\n * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;\n */\nexport type LocalRefExtractor = (tNode: TNodeWithLocalRefs, currentView: LView) => any;\n\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nexport function hasClassInput(tNode: TNode) {\n  return (tNode.flags & TNodeFlags.hasClassInput) !== 0;\n}\n\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nexport function hasStyleInput(tNode: TNode) {\n  return (tNode.flags & TNodeFlags.hasStyleInput) !== 0;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable, Subscribable} from 'rxjs';\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport function isPromise<T = any>(obj: any): obj is Promise<T> {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\n/**\n * Determine if the argument is a Subscribable\n */\nexport function isSubscribable(obj: any|Subscribable<any>): obj is Subscribable<any> {\n  return !!obj && typeof obj.subscribe === 'function';\n}\n\n/**\n * Determine if the argument is an Observable\n *\n * Strictly this tests that the `obj` is `Subscribable`, since `Observable`\n * types need additional methods, such as `lift()`. But it is adequate for our\n * needs since within the Angular framework code we only ever need to use the\n * `subscribe()` method, and RxJS has mechanisms to wrap `Subscribable` objects\n * into `Observable` as needed.\n */\nexport const isObservable =\n    isSubscribable as ((obj: any|Observable<any>) => obj is Observable<any>);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {assertIndexInRange} from '../../util/assert';\nimport {isObservable} from '../../util/lang';\nimport {EMPTY_OBJ} from '../empty';\nimport {PropertyAliasValue, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {GlobalTargetResolver, isProceduralRenderer, Renderer3} from '../interfaces/renderer';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {isDirectiveHost} from '../interfaces/type_checks';\nimport {CLEANUP, FLAGS, LView, LViewFlags, RENDERER, TView} from '../interfaces/view';\nimport {assertTNodeType} from '../node_assert';\nimport {getCurrentDirectiveDef, getCurrentTNode, getLView, getTView} from '../state';\nimport {getComponentLViewByIndex, getNativeByTNode, unwrapRNode} from '../util/view_utils';\n\nimport {getLCleanup, getTViewCleanup, handleError, loadComponentRenderer, markViewDirty} from './shared';\n\n\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nexport function ɵɵlistener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false,\n    eventTargetResolver?: GlobalTargetResolver): typeof ɵɵlistener {\n  const lView = getLView();\n  const tView = getTView();\n  const tNode = getCurrentTNode()!;\n  listenerInternal(\n      tView, lView, lView[RENDERER], tNode, eventName, listenerFn, useCapture, eventTargetResolver);\n  return ɵɵlistener;\n}\n\n/**\n * Registers a synthetic host listener (e.g. `(@foo.start)`) on a component or directive.\n *\n * This instruction is for compatibility purposes and is designed to ensure that a\n * synthetic host listener (e.g. `@HostListener('@foo.start')`) properly gets rendered\n * in the component's renderer. Normally all host listeners are evaluated with the\n * parent component's renderer, but, in the case of animation @triggers, they need\n * to be evaluated with the sub component's renderer (because that's where the\n * animation triggers are defined).\n *\n * Do not use this instruction as a replacement for `listener`. This instruction\n * only exists to ensure compatibility with the ViewEngine's host binding behavior.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener\n * @param eventTargetResolver Function that returns global target information in case this listener\n * should be attached to a global object like window, document or body\n *\n * @codeGenApi\n */\nexport function ɵɵsyntheticHostListener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false,\n    eventTargetResolver?: GlobalTargetResolver): typeof ɵɵsyntheticHostListener {\n  const tNode = getCurrentTNode()!;\n  const lView = getLView();\n  const tView = getTView();\n  const currentDef = getCurrentDirectiveDef(tView.data);\n  const renderer = loadComponentRenderer(currentDef, tNode, lView);\n  listenerInternal(\n      tView, lView, renderer, tNode, eventName, listenerFn, useCapture, eventTargetResolver);\n  return ɵɵsyntheticHostListener;\n}\n\n/**\n * A utility function that checks if a given element has already an event handler registered for an\n * event with a specified name. The TView.cleanup data structure is used to find out which events\n * are registered for a given element.\n */\nfunction findExistingListener(\n    tView: TView, lView: LView, eventName: string, tNodeIdx: number): ((e?: any) => any)|null {\n  const tCleanup = tView.cleanup;\n  if (tCleanup != null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      const cleanupEventName = tCleanup[i];\n      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n        // We have found a matching event name on the same node but it might not have been\n        // registered yet, so we must explicitly verify entries in the LView cleanup data\n        // structures.\n        const lCleanup = lView[CLEANUP]!;\n        const listenerIdxInLCleanup = tCleanup[i + 2];\n        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n      }\n      // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or\n      // 2-element entries (for directive and queries destroy hooks). As such we can encounter\n      // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements\n      // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check\n      // documentation of TView.cleanup for more details of this data structure layout.\n      if (typeof cleanupEventName === 'string') {\n        i += 2;\n      }\n    }\n  }\n  return null;\n}\n\nfunction listenerInternal(\n    tView: TView, lView: LView, renderer: Renderer3, tNode: TNode, eventName: string,\n    listenerFn: (e?: any) => any, useCapture = false,\n    eventTargetResolver?: GlobalTargetResolver): void {\n  const isTNodeDirectiveHost = isDirectiveHost(tNode);\n  const firstCreatePass = tView.firstCreatePass;\n  const tCleanup: false|any[] = firstCreatePass && getTViewCleanup(tView);\n\n  // When the ɵɵlistener instruction was generated and is executed we know that there is either a\n  // native listener or a directive output on this element. As such we we know that we will have to\n  // register a listener and store its cleanup function on LView.\n  const lCleanup = getLCleanup(lView);\n\n  ngDevMode && assertTNodeType(tNode, TNodeType.AnyRNode | TNodeType.AnyContainer);\n\n  let processOutputs = true;\n\n  // add native event listener - applicable to elements only\n  if (tNode.type & TNodeType.AnyRNode) {\n    const native = getNativeByTNode(tNode, lView) as RElement;\n    const resolved = eventTargetResolver ? eventTargetResolver(native) : EMPTY_OBJ as any;\n    const target = resolved.target || native;\n    const lCleanupIndex = lCleanup.length;\n    const idxOrTargetGetter = eventTargetResolver ?\n        (_lView: LView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])).target :\n        tNode.index;\n\n    // In order to match current behavior, native DOM event listeners must be added for all\n    // events (including outputs).\n    if (isProceduralRenderer(renderer)) {\n      // There might be cases where multiple directives on the same element try to register an event\n      // handler function for the same event. In this situation we want to avoid registration of\n      // several native listeners as each registration would be intercepted by NgZone and\n      // trigger change detection. This would mean that a single user action would result in several\n      // change detections being invoked. To avoid this situation we want to have only one call to\n      // native handler registration (for the same element and same type of event).\n      //\n      // In order to have just one native event handler in presence of multiple handler functions,\n      // we just register a first handler function as a native event listener and then chain\n      // (coalesce) other handler functions on top of the first native handler function.\n      let existingListener = null;\n      // Please note that the coalescing described here doesn't happen for events specifying an\n      // alternative target (ex. (document:click)) - this is to keep backward compatibility with the\n      // view engine.\n      // Also, we don't have to search for existing listeners is there are no directives\n      // matching on a given node as we can't register multiple event handlers for the same event in\n      // a template (this would mean having duplicate attributes).\n      if (!eventTargetResolver && isTNodeDirectiveHost) {\n        existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n      }\n      if (existingListener !== null) {\n        // Attach a new listener to coalesced listeners list, maintaining the order in which\n        // listeners are registered. For performance reasons, we keep a reference to the last\n        // listener in that list (in `__ngLastListenerFn__` field), so we can avoid going through\n        // the entire set each time we need to add a new listener.\n        const lastListenerFn = (<any>existingListener).__ngLastListenerFn__ || existingListener;\n        lastListenerFn.__ngNextListenerFn__ = listenerFn;\n        (<any>existingListener).__ngLastListenerFn__ = listenerFn;\n        processOutputs = false;\n      } else {\n        // The first argument of `listen` function in Procedural Renderer is:\n        // - either a target name (as a string) in case of global target (window, document, body)\n        // - or element reference (in all other cases)\n        listenerFn = wrapListener(tNode, lView, listenerFn, false /** preventDefault */);\n        const cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);\n        ngDevMode && ngDevMode.rendererAddEventListener++;\n\n        lCleanup.push(listenerFn, cleanupFn);\n        tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n      }\n\n    } else {\n      listenerFn = wrapListener(tNode, lView, listenerFn, true /** preventDefault */);\n      target.addEventListener(eventName, listenerFn, useCapture);\n      ngDevMode && ngDevMode.rendererAddEventListener++;\n\n      lCleanup.push(listenerFn);\n      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);\n    }\n  } else {\n    // Even if there is no native listener to add, we still need to wrap the listener so that OnPush\n    // ancestors are marked dirty when an event occurs.\n    listenerFn = wrapListener(tNode, lView, listenerFn, false /** preventDefault */);\n  }\n\n  // subscribe to directive outputs\n  const outputs = tNode.outputs;\n  let props: PropertyAliasValue|undefined;\n  if (processOutputs && outputs !== null && (props = outputs[eventName])) {\n    const propsLength = props.length;\n    if (propsLength) {\n      for (let i = 0; i < propsLength; i += 2) {\n        const index = props[i] as number;\n        ngDevMode && assertIndexInRange(lView, index);\n        const minifiedName = props[i + 1];\n        const directiveInstance = lView[index];\n        const output = directiveInstance[minifiedName];\n\n        if (ngDevMode && !isObservable(output)) {\n          throw new Error(`@Output ${minifiedName} not initialized in '${\n              directiveInstance.constructor.name}'.`);\n        }\n\n        const subscription = output.subscribe(listenerFn);\n        const idx = lCleanup.length;\n        lCleanup.push(listenerFn, subscription);\n        tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n      }\n    }\n  }\n}\n\nfunction executeListenerWithErrorHandling(\n    lView: LView, listenerFn: (e?: any) => any, e: any): boolean {\n  try {\n    // Only explicitly returning false from a listener should preventDefault\n    return listenerFn(e) !== false;\n  } catch (error) {\n    handleError(lView, error);\n    return false;\n  }\n}\n\n/**\n * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,\n * if applicable.\n *\n * @param tNode The TNode associated with this listener\n * @param lView The LView that contains this listener\n * @param listenerFn The listener function to call\n * @param wrapWithPreventDefault Whether or not to prevent default behavior\n * (the procedural renderer does this already, so in those cases, we should skip)\n */\nfunction wrapListener(\n    tNode: TNode, lView: LView, listenerFn: (e?: any) => any,\n    wrapWithPreventDefault: boolean): EventListener {\n  // Note: we are performing most of the work in the listener function itself\n  // to optimize listener registration.\n  return function wrapListenerIn_markDirtyAndPreventDefault(e: any) {\n    // Ivy uses `Function` as a special token that allows us to unwrap the function\n    // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`.\n    if (e === Function) {\n      return listenerFn;\n    }\n\n    // In order to be backwards compatible with View Engine, events on component host nodes\n    // must also mark the component view itself dirty (i.e. the view that it owns).\n    const startView = tNode.flags & TNodeFlags.isComponentHost ?\n        getComponentLViewByIndex(tNode.index, lView) :\n        lView;\n\n    // See interfaces/view.ts for more on LViewFlags.ManualOnPush\n    if ((lView[FLAGS] & LViewFlags.ManualOnPush) === 0) {\n      markViewDirty(startView);\n    }\n\n    let result = executeListenerWithErrorHandling(lView, listenerFn, e);\n    // A just-invoked listener function might have coalesced listeners so we need to check for\n    // their presence and invoke as needed.\n    let nextListenerFn = (<any>wrapListenerIn_markDirtyAndPreventDefault).__ngNextListenerFn__;\n    while (nextListenerFn) {\n      // We should prevent default if any of the listeners explicitly return false\n      result = executeListenerWithErrorHandling(lView, nextListenerFn, e) && result;\n      nextListenerFn = (<any>nextListenerFn).__ngNextListenerFn__;\n    }\n\n    if (wrapWithPreventDefault && result === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n\n    return result;\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {nextContextImpl} from '../state';\n\n/**\n * Retrieves a context at the level specified and saves it as the global, contextViewData.\n * Will get the next level up if level is not specified.\n *\n * This is used to save contexts of parent views so they can be bound in embedded views, or\n * in conjunction with reference() to bind a ref from a parent view.\n *\n * @param level The relative level of the view from which to grab context compared to contextVewData\n * @returns context\n *\n * @codeGenApi\n */\nexport function ɵɵnextContext<T = any>(level: number = 1): T {\n  return nextContextImpl(level);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {initNgDevMode} from './ng_dev_mode';\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\n\nexport const EMPTY_OBJ: {} = {};\nexport const EMPTY_ARRAY: any[] = [];\n\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ);\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_ARRAY);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {KeyValueArray, keyValueArrayIndexOf} from '../../util/array_utils';\nimport {assertEqual, assertIndexInRange, assertNotEqual} from '../../util/assert';\nimport {assertFirstUpdatePass} from '../assert';\nimport {TNode} from '../interfaces/node';\nimport {getTStylingRangeNext, getTStylingRangePrev, setTStylingRangeNext, setTStylingRangeNextDuplicate, setTStylingRangePrev, setTStylingRangePrevDuplicate, toTStylingRange, TStylingKey, TStylingKeyPrimitive, TStylingRange} from '../interfaces/styling';\nimport {TData} from '../interfaces/view';\nimport {getTView} from '../state';\n\n\n/**\n * NOTE: The word `styling` is used interchangeably as style or class styling.\n *\n * This file contains code to link styling instructions together so that they can be replayed in\n * priority order. The file exists because Ivy styling instruction execution order does not match\n * that of the priority order. The purpose of this code is to create a linked list so that the\n * instructions can be traversed in priority order when computing the styles.\n *\n * Assume we are dealing with the following code:\n * ```\n * @Component({\n *   template: `\n *     <my-cmp [style]=\" {color: '#001'} \"\n *             [style.color]=\" #002 \"\n *             dir-style-color-1\n *             dir-style-color-2> `\n * })\n * class ExampleComponent {\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#001'});\n *     ɵɵstyleProp('color', '#002');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-1]',\n * })\n * class Style1Directive {\n *   @HostBinding('style') style = {color: '#005'};\n *   @HostBinding('style.color') color = '#006';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#005'});\n *     ɵɵstyleProp('color', '#006');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `[dir-style-color-2]',\n * })\n * class Style2Directive {\n *   @HostBinding('style') style = {color: '#007'};\n *   @HostBinding('style.color') color = '#008';\n *\n *   static ngDir = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#007'});\n *     ɵɵstyleProp('color', '#008');\n *     ...\n *   }\n * }\n *\n * @Directive({\n *   selector: `my-cmp',\n * })\n * class MyComponent {\n *   @HostBinding('style') style = {color: '#003'};\n *   @HostBinding('style.color') color = '#004';\n *\n *   static ngComp = ... {\n *     ...\n *     // Compiler ensures that `ɵɵstyleProp` is after `ɵɵstyleMap`\n *     ɵɵstyleMap({color: '#003'});\n *     ɵɵstyleProp('color', '#004');\n *     ...\n *   }\n * }\n * ```\n *\n * The Order of instruction execution is:\n *\n * NOTE: the comment binding location is for illustrative purposes only.\n *\n * ```\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * ```\n *\n * The correct priority order of concatenation is:\n *\n * ```\n * // MyComponent\n *     ɵɵstyleMap({color: '#003'});   // Binding index: 20\n *     ɵɵstyleProp('color', '#004');  // Binding index: 22\n * // Style1Directive\n *     ɵɵstyleMap({color: '#005'});   // Binding index: 24\n *     ɵɵstyleProp('color', '#006');  // Binding index: 26\n * // Style2Directive\n *     ɵɵstyleMap({color: '#007'});   // Binding index: 28\n *     ɵɵstyleProp('color', '#008');  // Binding index: 30\n * // Template: (ExampleComponent)\n *     ɵɵstyleMap({color: '#001'});   // Binding index: 10\n *     ɵɵstyleProp('color', '#002');  // Binding index: 12\n * ```\n *\n * What color should be rendered?\n *\n * Once the items are correctly sorted in the list, the answer is simply the last item in the\n * concatenation list which is `#002`.\n *\n * To do so we keep a linked list of all of the bindings which pertain to this element.\n * Notice that the bindings are inserted in the order of execution, but the `TView.data` allows\n * us to traverse them in the order of priority.\n *\n * |Idx|`TView.data`|`LView`          | Notes\n * |---|------------|-----------------|--------------\n * |...|            |                 |\n * |10 |`null`      |`{color: '#001'}`| `ɵɵstyleMap('color', {color: '#001'})`\n * |11 |`30 | 12`   | ...             |\n * |12 |`color`     |`'#002'`         | `ɵɵstyleProp('color', '#002')`\n * |13 |`10 | 0`    | ...             |\n * |...|            |                 |\n * |20 |`null`      |`{color: '#003'}`| `ɵɵstyleMap('color', {color: '#003'})`\n * |21 |`0 | 22`    | ...             |\n * |22 |`color`     |`'#004'`         | `ɵɵstyleProp('color', '#004')`\n * |23 |`20 | 24`   | ...             |\n * |24 |`null`      |`{color: '#005'}`| `ɵɵstyleMap('color', {color: '#005'})`\n * |25 |`22 | 26`   | ...             |\n * |26 |`color`     |`'#006'`         | `ɵɵstyleProp('color', '#006')`\n * |27 |`24 | 28`   | ...             |\n * |28 |`null`      |`{color: '#007'}`| `ɵɵstyleMap('color', {color: '#007'})`\n * |29 |`26 | 30`   | ...             |\n * |30 |`color`     |`'#008'`         | `ɵɵstyleProp('color', '#008')`\n * |31 |`28 | 10`   | ...             |\n *\n * The above data structure allows us to re-concatenate the styling no matter which data binding\n * changes.\n *\n * NOTE: in addition to keeping track of next/previous index the `TView.data` also stores prev/next\n * duplicate bit. The duplicate bit if true says there either is a binding with the same name or\n * there is a map (which may contain the name). This information is useful in knowing if other\n * styles with higher priority need to be searched for overwrites.\n *\n * NOTE: See `should support example in 'tnode_linked_list.ts' documentation` in\n * `tnode_linked_list_spec.ts` for working example.\n */\nlet __unused_const_as_closure_does_not_like_standalone_comment_blocks__: undefined;\n\n/**\n * Insert new `tStyleValue` at `TData` and link existing style bindings such that we maintain linked\n * list of styles and compute the duplicate flag.\n *\n * Note: this function is executed during `firstUpdatePass` only to populate the `TView.data`.\n *\n * The function works by keeping track of `tStylingRange` which contains two pointers pointing to\n * the head/tail of the template portion of the styles.\n *  - if `isHost === false` (we are template) then insertion is at tail of `TStylingRange`\n *  - if `isHost === true` (we are host binding) then insertion is at head of `TStylingRange`\n *\n * @param tData The `TData` to insert into.\n * @param tNode `TNode` associated with the styling element.\n * @param tStylingKey See `TStylingKey`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isHostBinding `true` if the insertion is for a `hostBinding`. (insertion is in front of\n *               template.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nexport function insertTStylingBinding(\n    tData: TData, tNode: TNode, tStylingKeyWithStatic: TStylingKey, index: number,\n    isHostBinding: boolean, isClassBinding: boolean): void {\n  ngDevMode && assertFirstUpdatePass(getTView());\n  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n  let tmplHead = getTStylingRangePrev(tBindings);\n  let tmplTail = getTStylingRangeNext(tBindings);\n\n  tData[index] = tStylingKeyWithStatic;\n  let isKeyDuplicateOfStatic = false;\n  let tStylingKey: TStylingKeyPrimitive;\n  if (Array.isArray(tStylingKeyWithStatic)) {\n    // We are case when the `TStylingKey` contains static fields as well.\n    const staticKeyValueArray = tStylingKeyWithStatic as KeyValueArray<any>;\n    tStylingKey = staticKeyValueArray[1];  // unwrap.\n    // We need to check if our key is present in the static so that we can mark it as duplicate.\n    if (tStylingKey === null ||\n        keyValueArrayIndexOf(staticKeyValueArray, tStylingKey as string) > 0) {\n      // tStylingKey is present in the statics, need to mark it as duplicate.\n      isKeyDuplicateOfStatic = true;\n    }\n  } else {\n    tStylingKey = tStylingKeyWithStatic;\n  }\n  if (isHostBinding) {\n    // We are inserting host bindings\n\n    // If we don't have template bindings then `tail` is 0.\n    const hasTemplateBindings = tmplTail !== 0;\n    // This is important to know because that means that the `head` can't point to the first\n    // template bindings (there are none.) Instead the head points to the tail of the template.\n    if (hasTemplateBindings) {\n      // template head's \"prev\" will point to last host binding or to 0 if no host bindings yet\n      const previousNode = getTStylingRangePrev(tData[tmplHead + 1] as TStylingRange);\n      tData[index + 1] = toTStylingRange(previousNode, tmplHead);\n      // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n      if (previousNode !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[previousNode + 1] =\n            setTStylingRangeNext(tData[previousNode + 1] as TStylingRange, index);\n      }\n      // The \"previous\" of the template binding head should point to this host binding\n      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1] as TStylingRange, index);\n    } else {\n      tData[index + 1] = toTStylingRange(tmplHead, 0);\n      // if a host binding has already been registered, we need to update the next of that host\n      // binding to point to this one\n      if (tmplHead !== 0) {\n        // We need to update the template-tail value to point to us.\n        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1] as TStylingRange, index);\n      }\n      // if we don't have template, the head points to template-tail, and needs to be advanced.\n      tmplHead = index;\n    }\n  } else {\n    // We are inserting in template section.\n    // We need to set this binding's \"previous\" to the current template tail\n    tData[index + 1] = toTStylingRange(tmplTail, 0);\n    ngDevMode &&\n        assertEqual(\n            tmplHead !== 0 && tmplTail === 0, false,\n            'Adding template bindings after hostBindings is not allowed.');\n    if (tmplHead === 0) {\n      tmplHead = index;\n    } else {\n      // We need to update the previous value \"next\" to point to this binding\n      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1] as TStylingRange, index);\n    }\n    tmplTail = index;\n  }\n\n  // Now we need to update / compute the duplicates.\n  // Starting with our location search towards head (least priority)\n  if (isKeyDuplicateOfStatic) {\n    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1] as TStylingRange);\n  }\n  markDuplicates(tData, tStylingKey, index, true, isClassBinding);\n  markDuplicates(tData, tStylingKey, index, false, isClassBinding);\n  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n\n  tBindings = toTStylingRange(tmplHead, tmplTail);\n  if (isClassBinding) {\n    tNode.classBindings = tBindings;\n  } else {\n    tNode.styleBindings = tBindings;\n  }\n}\n\n/**\n * Look into the residual styling to see if the current `tStylingKey` is duplicate of residual.\n *\n * @param tNode `TNode` where the residual is stored.\n * @param tStylingKey `TStylingKey` to store.\n * @param tData `TData` associated with the current `LView`.\n * @param index location of where `tStyleValue` should be stored (and linked into list.)\n * @param isClassBinding True if the associated `tStylingKey` as a `class` styling.\n *                       `tNode.classBindings` should be used (or `tNode.styleBindings` otherwise.)\n */\nfunction markDuplicateOfResidualStyling(\n    tNode: TNode, tStylingKey: TStylingKey, tData: TData, index: number, isClassBinding: boolean) {\n  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n  if (residual != null /* or undefined */ && typeof tStylingKey == 'string' &&\n      keyValueArrayIndexOf(residual, tStylingKey) >= 0) {\n    // We have duplicate in the residual so mark ourselves as duplicate.\n    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1] as TStylingRange);\n  }\n}\n\n\n/**\n * Marks `TStyleValue`s as duplicates if another style binding in the list has the same\n * `TStyleValue`.\n *\n * NOTE: this function is intended to be called twice once with `isPrevDir` set to `true` and once\n * with it set to `false` to search both the previous as well as next items in the list.\n *\n * No duplicate case\n * ```\n *   [style.color]\n *   [style.width.px] <<- index\n *   [style.height.px]\n * ```\n *\n * In the above case adding `[style.width.px]` to the existing `[style.color]` produces no\n * duplicates because `width` is not found in any other part of the linked list.\n *\n * Duplicate case\n * ```\n *   [style.color]\n *   [style.width.em]\n *   [style.width.px] <<- index\n * ```\n * In the above case adding `[style.width.px]` will produce a duplicate with `[style.width.em]`\n * because `width` is found in the chain.\n *\n * Map case 1\n * ```\n *   [style.width.px]\n *   [style.color]\n *   [style]  <<- index\n * ```\n * In the above case adding `[style]` will produce a duplicate with any other bindings because\n * `[style]` is a Map and as such is fully dynamic and could produce `color` or `width`.\n *\n * Map case 2\n * ```\n *   [style]\n *   [style.width.px]\n *   [style.color]  <<- index\n * ```\n * In the above case adding `[style.color]` will produce a duplicate because there is already a\n * `[style]` binding which is a Map and as such is fully dynamic and could produce `color` or\n * `width`.\n *\n * NOTE: Once `[style]` (Map) is added into the system all things are mapped as duplicates.\n * NOTE: We use `style` as example, but same logic is applied to `class`es as well.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tStylingKey `TStylingKeyPrimitive` which contains the value to compare to other keys in\n *        the linked list.\n * @param index Starting location in the linked list to search from\n * @param isPrevDir Direction.\n *        - `true` for previous (lower priority);\n *        - `false` for next (higher priority).\n */\nfunction markDuplicates(\n    tData: TData, tStylingKey: TStylingKeyPrimitive, index: number, isPrevDir: boolean,\n    isClassBinding: boolean) {\n  const tStylingAtIndex = tData[index + 1] as TStylingRange;\n  const isMap = tStylingKey === null;\n  let cursor =\n      isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);\n  let foundDuplicate = false;\n  // We keep iterating as long as we have a cursor\n  // AND either:\n  // - we found what we are looking for, OR\n  // - we are a map in which case we have to continue searching even after we find what we were\n  //   looking for since we are a wild card and everything needs to be flipped to duplicate.\n  while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n    ngDevMode && assertIndexInRange(tData, cursor);\n    const tStylingValueAtCursor = tData[cursor] as TStylingKey;\n    const tStyleRangeAtCursor = tData[cursor + 1] as TStylingRange;\n    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n      foundDuplicate = true;\n      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) :\n                                      setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n    }\n    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) :\n                         getTStylingRangeNext(tStyleRangeAtCursor);\n  }\n  if (foundDuplicate) {\n    // if we found a duplicate, than mark ourselves.\n    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) :\n                                   setTStylingRangeNextDuplicate(tStylingAtIndex);\n  }\n}\n\n/**\n * Determines if two `TStylingKey`s are a match.\n *\n * When computing whether a binding contains a duplicate, we need to compare if the instruction\n * `TStylingKey` has a match.\n *\n * Here are examples of `TStylingKey`s which match given `tStylingKeyCursor` is:\n * - `color`\n *    - `color`    // Match another color\n *    - `null`     // That means that `tStylingKey` is a `classMap`/`styleMap` instruction\n *    - `['', 'color', 'other', true]` // wrapped `color` so match\n *    - `['', null, 'other', true]`       // wrapped `null` so match\n *    - `['', 'width', 'color', 'value']` // wrapped static value contains a match on `'color'`\n * - `null`       // `tStylingKeyCursor` always match as it is `classMap`/`styleMap` instruction\n *\n * @param tStylingKeyCursor\n * @param tStylingKey\n */\nfunction isStylingMatch(tStylingKeyCursor: TStylingKey, tStylingKey: TStylingKeyPrimitive) {\n  ngDevMode &&\n      assertNotEqual(\n          Array.isArray(tStylingKey), true, 'Expected that \\'tStylingKey\\' has been unwrapped');\n  if (\n      tStylingKeyCursor === null ||  // If the cursor is `null` it means that we have map at that\n                                     // location so we must assume that we have a match.\n      tStylingKey == null ||  // If `tStylingKey` is `null` then it is a map therefor assume that it\n                              // contains a match.\n      (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) ===\n          tStylingKey  // If the keys match explicitly than we are a match.\n  ) {\n    return true;\n  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === 'string') {\n    // if we did not find a match, but `tStylingKeyCursor` is `KeyValueArray` that means cursor has\n    // statics and we need to check those as well.\n    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >=\n        0;  // see if we are matching the key\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SafeValue, unwrapSafeValue} from '../../sanitization/bypass';\nimport {KeyValueArray, keyValueArrayGet, keyValueArraySet} from '../../util/array_utils';\nimport {assertDefined, assertEqual, assertLessThan, assertNotEqual, throwError} from '../../util/assert';\nimport {EMPTY_ARRAY} from '../../util/empty';\nimport {concatStringsWithSpace, stringify} from '../../util/stringify';\nimport {assertFirstUpdatePass} from '../assert';\nimport {bindingUpdated} from '../bindings';\nimport {DirectiveDef} from '../interfaces/definition';\nimport {AttributeMarker, TAttributes, TNode, TNodeFlags, TNodeType} from '../interfaces/node';\nimport {Renderer3} from '../interfaces/renderer';\nimport {RElement} from '../interfaces/renderer_dom';\nimport {getTStylingRangeNext, getTStylingRangeNextDuplicate, getTStylingRangePrev, getTStylingRangePrevDuplicate, TStylingKey, TStylingRange} from '../interfaces/styling';\nimport {LView, RENDERER, TData, TView} from '../interfaces/view';\nimport {applyStyling} from '../node_manipulation';\nimport {getCurrentDirectiveDef, getLView, getSelectedIndex, getTView, incrementBindingIndex} from '../state';\nimport {insertTStylingBinding} from '../styling/style_binding_list';\nimport {getLastParsedKey, getLastParsedValue, parseClassName, parseClassNameNext, parseStyle, parseStyleNext} from '../styling/styling_parser';\nimport {NO_CHANGE} from '../tokens';\nimport {getNativeByIndex} from '../util/view_utils';\nimport {setDirectiveInputsWhichShadowsStyling} from './property';\n\n\n/**\n * Update a style binding on an element with the provided value.\n *\n * If the style value is falsy then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `styleMap` or any static styles that are\n * present from when the element was created with `styling`).\n *\n * Note that the styling element is updated as part of `stylingApply`.\n *\n * @param prop A valid CSS property.\n * @param value New value to write (`null` or an empty string to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *\n * Note that this will apply the provided style value to the host element if this function is called\n * within a host binding function.\n *\n * @codeGenApi\n */\nexport function ɵɵstyleProp(\n    prop: string, value: string|number|SafeValue|undefined|null,\n    suffix?: string|null): typeof ɵɵstyleProp {\n  checkStylingProperty(prop, value, suffix, false);\n  return ɵɵstyleProp;\n}\n\n/**\n * Update a class binding on an element with the provided value.\n *\n * This instruction is meant to handle the `[class.foo]=\"exp\"` case and,\n * therefore, the class binding itself must already be allocated using\n * `styling` within the creation block.\n *\n * @param prop A valid CSS class (only one).\n * @param value A true/false value which will turn the class on or off.\n *\n * Note that this will apply the provided class value to the host element if this function\n * is called within a host binding function.\n *\n * @codeGenApi\n */\nexport function ɵɵclassProp(className: string, value: boolean|undefined|null): typeof ɵɵclassProp {\n  checkStylingProperty(className, value, null, true);\n  return ɵɵclassProp;\n}\n\n\n/**\n * Update style bindings using an object literal on an element.\n *\n * This instruction is meant to apply styling via the `[style]=\"exp\"` template bindings.\n * When styles are applied to the element they will then be updated with respect to\n * any styles/classes set via `styleProp`. If any styles are set to falsy\n * then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n *\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n *\n * Note that this will apply the provided styleMap value to the host element if this function\n * is called within a host binding.\n *\n * @codeGenApi\n */\nexport function ɵɵstyleMap(styles: {[styleName: string]: any}|string|undefined|null): void {\n  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\n\n\n/**\n * Parse text as style and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵstyleMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nexport function styleStringParser(keyValueArray: KeyValueArray<any>, text: string): void {\n  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n  }\n}\n\n\n/**\n * Update class bindings using an object literal or class-string on an element.\n *\n * This instruction is meant to apply styling via the `[class]=\"exp\"` template bindings.\n * When classes are applied to the element they will then be updated with\n * respect to any styles/classes set via `classProp`. If any\n * classes are set to falsy then they will be removed from the element.\n *\n * Note that the styling instruction will not be applied until `stylingApply` is called.\n * Note that this will the provided classMap value to the host element if this function is called\n * within a host binding.\n *\n * @param classes A key/value map or string of CSS classes that will be added to the\n *        given element. Any missing classes (that have already been applied to the element\n *        beforehand) will be removed (unset) from the element's list of CSS classes.\n *\n * @codeGenApi\n */\nexport function ɵɵclassMap(classes: {[className: string]: boolean|undefined|null}|string|undefined|\n                           null): void {\n  checkStylingMap(keyValueArraySet, classStringParser, classes, true);\n}\n\n/**\n * Parse text as class and add values to KeyValueArray.\n *\n * This code is pulled out to a separate function so that it can be tree shaken away if it is not\n * needed. It is only referenced from `ɵɵclassMap`.\n *\n * @param keyValueArray KeyValueArray to add parsed values to.\n * @param text text to parse.\n */\nexport function classStringParser(keyValueArray: KeyValueArray<any>, text: string): void {\n  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n  }\n}\n\n/**\n * Common code between `ɵɵclassProp` and `ɵɵstyleProp`.\n *\n * @param prop property name.\n * @param value binding value.\n * @param suffix suffix for the property (e.g. `em` or `px`)\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nexport function checkStylingProperty(\n    prop: string, value: any|NO_CHANGE, suffix: string|undefined|null,\n    isClassBased: boolean): void {\n  const lView = getLView();\n  const tView = getTView();\n  // Styling instructions use 2 slots per binding.\n  // 1. one for the value / TStylingKey\n  // 2. one for the intermittent-value / TStylingRange\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n  }\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    const tNode = tView.data[getSelectedIndex()] as TNode;\n    updateStyling(\n        tView, tNode, lView, lView[RENDERER], prop,\n        lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);\n  }\n}\n\n/**\n * Common code between `ɵɵclassMap` and `ɵɵstyleMap`.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done for tree shaking purposes.\n * @param stringParser Parser used to parse `value` if `string`. (Passed in as `style` and `class`\n *        have different parsers.)\n * @param value bound value from application\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nexport function checkStylingMap(\n    keyValueArraySet: (keyValueArray: KeyValueArray<any>, key: string, value: any) => void,\n    stringParser: (styleKeyValueArray: KeyValueArray<any>, text: string) => void,\n    value: any|NO_CHANGE, isClassBased: boolean): void {\n  const tView = getTView();\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n  }\n  const lView = getLView();\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tView.data[getSelectedIndex()] as TNode;\n    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n      if (ngDevMode) {\n        // verify that if we are shadowing then `TData` is appropriately marked so that we skip\n        // processing this binding in styling resolution.\n        const tStylingKey = tView.data[bindingIndex];\n        assertEqual(\n            Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false,\n            'Styling linked list shadow input should be marked as \\'false\\'');\n      }\n      // VE does not concatenate the static portion like we are doing here.\n      // Instead VE just ignores the static completely if dynamic binding is present.\n      // Because of locality we have already set the static portion because we don't know if there\n      // is a dynamic portion until later. If we would ignore the static portion it would look like\n      // the binding has removed it. This would confuse `[ngStyle]`/`[ngClass]` to do the wrong\n      // thing as it would think that the static portion was removed. For this reason we\n      // concatenate it so that `[ngStyle]`/`[ngClass]`  can continue to work on changed.\n      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n      ngDevMode && isClassBased === false && staticPrefix !== null &&\n          assertEqual(\n              staticPrefix.endsWith(';'), true, 'Expecting static portion to end with \\';\\'');\n      if (staticPrefix !== null) {\n        // We want to make sure that falsy values of `value` become empty strings.\n        value = concatStringsWithSpace(staticPrefix, value ? value : '');\n      }\n      // Given `<div [style] my-dir>` such that `my-dir` has `@Input('style')`.\n      // This takes over the `[style]` binding. (Same for `[class]`)\n      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n    } else {\n      updateStylingMap(\n          tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1],\n          lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet, stringParser, value),\n          isClassBased, bindingIndex);\n    }\n  }\n}\n\n/**\n * Determines when the binding is in `hostBindings` section\n *\n * @param tView Current `TView`\n * @param bindingIndex index of binding which we would like if it is in `hostBindings`\n */\nfunction isInHostBindings(tView: TView, bindingIndex: number): boolean {\n  // All host bindings are placed after the expando section.\n  return bindingIndex >= tView.expandoStartIndex;\n}\n\n/**\n * Collects the necessary information to insert the binding into a linked list of style bindings\n * using `insertTStylingBinding`.\n *\n * @param tView `TView` where the binding linked list will be stored.\n * @param tStylingKey Property/key of the binding.\n * @param bindingIndex Index of binding associated with the `prop`\n * @param isClassBased `true` if `class` change (`false` if `style`)\n */\nfunction stylingFirstUpdatePass(\n    tView: TView, tStylingKey: TStylingKey, bindingIndex: number, isClassBased: boolean): void {\n  ngDevMode && assertFirstUpdatePass(tView);\n  const tData = tView.data;\n  if (tData[bindingIndex + 1] === null) {\n    // The above check is necessary because we don't clear first update pass until first successful\n    // (no exception) template execution. This prevents the styling instruction from double adding\n    // itself to the list.\n    // `getSelectedIndex()` should be here (rather than in instruction) so that it is guarded by the\n    // if so as not to read unnecessarily.\n    const tNode = tData[getSelectedIndex()] as TNode;\n    ngDevMode && assertDefined(tNode, 'TNode expected');\n    const isHostBindings = isInHostBindings(tView, bindingIndex);\n    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n      // `tStylingKey === null` implies that we are either `[style]` or `[class]` binding.\n      // If there is a directive which uses `@Input('style')` or `@Input('class')` than\n      // we need to neutralize this binding since that directive is shadowing it.\n      // We turn this into a noop by setting the key to `false`\n      tStylingKey = false;\n    }\n    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n  }\n}\n\n/**\n * Adds static styling information to the binding if applicable.\n *\n * The linked list of styles not only stores the list and keys, but also stores static styling\n * information on some of the keys. This function determines if the key should contain the styling\n * information and computes it.\n *\n * See `TStylingStatic` for more details.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey `TStylingKeyPrimitive` which may need to be wrapped into `TStylingKey`\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nexport function wrapInStaticStylingKey(\n    tData: TData, tNode: TNode, stylingKey: TStylingKey, isClassBased: boolean): TStylingKey {\n  const hostDirectiveDef = getCurrentDirectiveDef(tData);\n  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n  if (hostDirectiveDef === null) {\n    // We are in template node.\n    // If template node already had styling instruction then it has already collected the static\n    // styling and there is no need to collect them again. We know that we are the first styling\n    // instruction because the `TNode.*Bindings` points to 0 (nothing has been inserted yet).\n    const isFirstStylingInstructionInTemplate =\n        (isClassBased ? tNode.classBindings : tNode.styleBindings) as any as number === 0;\n    if (isFirstStylingInstructionInTemplate) {\n      // It would be nice to be able to get the statics from `mergeAttrs`, however, at this point\n      // they are already merged and it would not be possible to figure which property belongs where\n      // in the priority.\n      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);\n      // We know that if we have styling binding in template we can't have residual.\n      residual = null;\n    }\n  } else {\n    // We are in host binding node and there was no binding instruction in template node.\n    // This means that we need to compute the residual.\n    const directiveStylingLast = tNode.directiveStylingLast;\n    const isFirstStylingInstructionInHostBinding =\n        directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n    if (isFirstStylingInstructionInHostBinding) {\n      stylingKey =\n          collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);\n      if (residual === null) {\n        // - If `null` than either:\n        //    - Template styling instruction already ran and it has consumed the static\n        //      styling into its `TStylingKey` and so there is no need to update residual. Instead\n        //      we need to update the `TStylingKey` associated with the first template node\n        //      instruction. OR\n        //    - Some other styling instruction ran and determined that there are no residuals\n        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n        if (templateStylingKey !== undefined && Array.isArray(templateStylingKey)) {\n          // Only recompute if `templateStylingKey` had static values. (If no static value found\n          // then there is nothing to do since this operation can only produce less static keys, not\n          // more.)\n          templateStylingKey = collectStylingFromDirectives(\n              null, tData, tNode, templateStylingKey[1] /* unwrap previous statics */,\n              isClassBased);\n          templateStylingKey =\n              collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);\n          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n        }\n      } else {\n        // We only need to recompute residual if it is not `null`.\n        // - If existing residual (implies there was no template styling). This means that some of\n        //   the statics may have moved from the residual to the `stylingKey` and so we have to\n        //   recompute.\n        // - If `undefined` this is the first time we are running.\n        residual = collectResidual(tData, tNode, isClassBased);\n      }\n    }\n  }\n  if (residual !== undefined) {\n    isClassBased ? (tNode.residualClasses = residual) : (tNode.residualStyles = residual);\n  }\n  return stylingKey;\n}\n\n/**\n * Retrieve the `TStylingKey` for the template styling instruction.\n *\n * This is needed since `hostBinding` styling instructions are inserted after the template\n * instruction. While the template instruction needs to update the residual in `TNode` the\n * `hostBinding` instructions need to update the `TStylingKey` of the template instruction because\n * the template instruction is downstream from the `hostBindings` instructions.\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @return `TStylingKey` if found or `undefined` if not found.\n */\nfunction getTemplateHeadTStylingKey(tData: TData, tNode: TNode, isClassBased: boolean): TStylingKey|\n    undefined {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  if (getTStylingRangeNext(bindings) === 0) {\n    // There does not seem to be a styling instruction in the `template`.\n    return undefined;\n  }\n  return tData[getTStylingRangePrev(bindings)] as TStylingKey;\n}\n\n/**\n * Update the `TStylingKey` of the first template instruction in `TNode`.\n *\n * Logically `hostBindings` styling instructions are of lower priority than that of the template.\n * However, they execute after the template styling instructions. This means that they get inserted\n * in front of the template styling instructions.\n *\n * If we have a template styling instruction and a new `hostBindings` styling instruction is\n * executed it means that it may need to steal static fields from the template instruction. This\n * method allows us to update the first template instruction `TStylingKey` with a new value.\n *\n * Assume:\n * ```\n * <div my-dir style=\"color: red\" [style.color]=\"tmplExp\"></div>\n *\n * @Directive({\n *   host: {\n *     'style': 'width: 100px',\n *     '[style.color]': 'dirExp',\n *   }\n * })\n * class MyDir {}\n * ```\n *\n * when `[style.color]=\"tmplExp\"` executes it creates this data structure.\n * ```\n *  ['', 'color', 'color', 'red', 'width', '100px'],\n * ```\n *\n * The reason for this is that the template instruction does not know if there are styling\n * instructions and must assume that there are none and must collect all of the static styling.\n * (both\n * `color' and 'width`)\n *\n * When `'[style.color]': 'dirExp',` executes we need to insert a new data into the linked list.\n * ```\n *  ['', 'color', 'width', '100px'],  // newly inserted\n *  ['', 'color', 'color', 'red', 'width', '100px'], // this is wrong\n * ```\n *\n * Notice that the template statics is now wrong as it incorrectly contains `width` so we need to\n * update it like so:\n * ```\n *  ['', 'color', 'width', '100px'],\n *  ['', 'color', 'color', 'red'],    // UPDATE\n * ```\n *\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param tStylingKey New `TStylingKey` which is replacing the old one.\n */\nfunction setTemplateHeadTStylingKey(\n    tData: TData, tNode: TNode, isClassBased: boolean, tStylingKey: TStylingKey): void {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  ngDevMode &&\n      assertNotEqual(\n          getTStylingRangeNext(bindings), 0,\n          'Expecting to have at least one template styling binding.');\n  tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\n\n/**\n * Collect all static values after the current `TNode.directiveStylingLast` index.\n *\n * Collect the remaining styling information which has not yet been collected by an existing\n * styling instruction.\n *\n * @param tData `TData` where the `DirectiveDefs` are stored.\n * @param tNode `TNode` which contains the directive range.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectResidual(tData: TData, tNode: TNode, isClassBased: boolean): KeyValueArray<any>|\n    null {\n  let residual: KeyValueArray<any>|null|undefined = undefined;\n  const directiveEnd = tNode.directiveEnd;\n  ngDevMode &&\n      assertNotEqual(\n          tNode.directiveStylingLast, -1,\n          'By the time this function gets called at least one hostBindings-node styling instruction must have executed.');\n  // We add `1 + tNode.directiveStart` because we need to skip the current directive (as we are\n  // collecting things after the last `hostBindings` directive which had a styling instruction.)\n  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n    const attrs = (tData[i] as DirectiveDef<any>).hostAttrs;\n    residual = collectStylingFromTAttrs(residual, attrs, isClassBased) as KeyValueArray<any>| null;\n  }\n  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased) as KeyValueArray<any>| null;\n}\n\n/**\n * Collect the static styling information with lower priority than `hostDirectiveDef`.\n *\n * (This is opposite of residual styling.)\n *\n * @param hostDirectiveDef `DirectiveDef` for which we want to collect lower priority static\n *        styling. (Or `null` if template styling)\n * @param tData `TData` where the linked list is stored.\n * @param tNode `TNode` for which the styling is being computed.\n * @param stylingKey Existing `TStylingKey` to update or wrap.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromDirectives(\n    hostDirectiveDef: DirectiveDef<any>|null, tData: TData, tNode: TNode, stylingKey: TStylingKey,\n    isClassBased: boolean): TStylingKey {\n  // We need to loop because there can be directives which have `hostAttrs` but don't have\n  // `hostBindings` so this loop catches up to the current directive..\n  let currentDirective: DirectiveDef<any>|null = null;\n  const directiveEnd = tNode.directiveEnd;\n  let directiveStylingLast = tNode.directiveStylingLast;\n  if (directiveStylingLast === -1) {\n    directiveStylingLast = tNode.directiveStart;\n  } else {\n    directiveStylingLast++;\n  }\n  while (directiveStylingLast < directiveEnd) {\n    currentDirective = tData[directiveStylingLast] as DirectiveDef<any>;\n    ngDevMode && assertDefined(currentDirective, 'expected to be defined');\n    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n    if (currentDirective === hostDirectiveDef) break;\n    directiveStylingLast++;\n  }\n  if (hostDirectiveDef !== null) {\n    // we only advance the styling cursor if we are collecting data from host bindings.\n    // Template executes before host bindings and so if we would update the index,\n    // host bindings would not get their statics.\n    tNode.directiveStylingLast = directiveStylingLast;\n  }\n  return stylingKey;\n}\n\n/**\n * Convert `TAttrs` into `TStylingStatic`.\n *\n * @param stylingKey existing `TStylingKey` to update or wrap.\n * @param attrs `TAttributes` to process.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction collectStylingFromTAttrs(\n    stylingKey: TStylingKey|undefined, attrs: TAttributes|null,\n    isClassBased: boolean): TStylingKey {\n  const desiredMarker = isClassBased ? AttributeMarker.Classes : AttributeMarker.Styles;\n  let currentMarker = AttributeMarker.ImplicitAttributes;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const item = attrs[i] as number | string;\n      if (typeof item === 'number') {\n        currentMarker = item;\n      } else {\n        if (currentMarker === desiredMarker) {\n          if (!Array.isArray(stylingKey)) {\n            stylingKey = stylingKey === undefined ? [] : ['', stylingKey] as any;\n          }\n          keyValueArraySet(\n              stylingKey as KeyValueArray<any>, item, isClassBased ? true : attrs[++i]);\n        }\n      }\n    }\n  }\n  return stylingKey === undefined ? null : stylingKey;\n}\n\n/**\n * Convert user input to `KeyValueArray`.\n *\n * This function takes user input which could be `string`, Object literal, or iterable and converts\n * it into a consistent representation. The output of this is `KeyValueArray` (which is an array\n * where\n * even indexes contain keys and odd indexes contain values for those keys).\n *\n * The advantage of converting to `KeyValueArray` is that we can perform diff in an input\n * independent\n * way.\n * (ie we can compare `foo bar` to `['bar', 'baz'] and determine a set of changes which need to be\n * applied)\n *\n * The fact that `KeyValueArray` is sorted is very important because it allows us to compute the\n * difference in linear fashion without the need to allocate any additional data.\n *\n * For example if we kept this as a `Map` we would have to iterate over previous `Map` to determine\n * which values need to be deleted, over the new `Map` to determine additions, and we would have to\n * keep additional `Map` to keep track of duplicates or items which have not yet been visited.\n *\n * @param keyValueArraySet (See `keyValueArraySet` in \"util/array_utils\") Gets passed in as a\n *        function so that `style` can be processed. This is done\n *        for tree shaking purposes.\n * @param stringParser The parser is passed in so that it will be tree shakable. See\n *        `styleStringParser` and `classStringParser`\n * @param value The value to parse/convert to `KeyValueArray`\n */\nexport function toStylingKeyValueArray(\n    keyValueArraySet: (keyValueArray: KeyValueArray<any>, key: string, value: any) => void,\n    stringParser: (styleKeyValueArray: KeyValueArray<any>, text: string) => void,\n    value: string|string[]|{[key: string]: any}|SafeValue|null|undefined): KeyValueArray<any> {\n  if (value == null /*|| value === undefined */ || value === '') return EMPTY_ARRAY as any;\n  const styleKeyValueArray: KeyValueArray<any> = [] as any;\n  const unwrappedValue = unwrapSafeValue(value) as string | string[] | {[key: string]: any};\n  if (Array.isArray(unwrappedValue)) {\n    for (let i = 0; i < unwrappedValue.length; i++) {\n      keyValueArraySet(styleKeyValueArray, unwrappedValue[i], true);\n    }\n  } else if (typeof unwrappedValue === 'object') {\n    for (const key in unwrappedValue) {\n      if (unwrappedValue.hasOwnProperty(key)) {\n        keyValueArraySet(styleKeyValueArray, key, unwrappedValue[key]);\n      }\n    }\n  } else if (typeof unwrappedValue === 'string') {\n    stringParser(styleKeyValueArray, unwrappedValue);\n  } else {\n    ngDevMode &&\n        throwError('Unsupported styling type ' + typeof unwrappedValue + ': ' + unwrappedValue);\n  }\n  return styleKeyValueArray;\n}\n\n/**\n * Set a `value` for a `key`.\n *\n * See: `keyValueArraySet` for details\n *\n * @param keyValueArray KeyValueArray to add to.\n * @param key Style key to add.\n * @param value The value to set.\n */\nexport function styleKeyValueArraySet(keyValueArray: KeyValueArray<any>, key: string, value: any) {\n  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\n\n/**\n * Update map based styling.\n *\n * Map based styling could be anything which contains more than one binding. For example `string`,\n * or object literal. Dealing with all of these types would complicate the logic so\n * instead this function expects that the complex input is first converted into normalized\n * `KeyValueArray`. The advantage of normalization is that we get the values sorted, which makes it\n * very cheap to compute deltas between the previous and current value.\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param oldKeyValueArray Previous value represented as `KeyValueArray`\n * @param newKeyValueArray Current value represented as `KeyValueArray`\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStylingMap(\n    tView: TView, tNode: TNode, lView: LView, renderer: Renderer3,\n    oldKeyValueArray: KeyValueArray<any>, newKeyValueArray: KeyValueArray<any>,\n    isClassBased: boolean, bindingIndex: number) {\n  if (oldKeyValueArray as KeyValueArray<any>| NO_CHANGE === NO_CHANGE) {\n    // On first execution the oldKeyValueArray is NO_CHANGE => treat it as empty KeyValueArray.\n    oldKeyValueArray = EMPTY_ARRAY as any;\n  }\n  let oldIndex = 0;\n  let newIndex = 0;\n  let oldKey: string|null = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n  let newKey: string|null = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n  while (oldKey !== null || newKey !== null) {\n    ngDevMode && assertLessThan(oldIndex, 999, 'Are we stuck in infinite loop?');\n    ngDevMode && assertLessThan(newIndex, 999, 'Are we stuck in infinite loop?');\n    const oldValue =\n        oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : undefined;\n    const newValue =\n        newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : undefined;\n    let setKey: string|null = null;\n    let setValue: any = undefined;\n    if (oldKey === newKey) {\n      // UPDATE: Keys are equal => new value is overwriting old value.\n      oldIndex += 2;\n      newIndex += 2;\n      if (oldValue !== newValue) {\n        setKey = newKey;\n        setValue = newValue;\n      }\n    } else if (newKey === null || oldKey !== null && oldKey < newKey!) {\n      // DELETE: oldKey key is missing or we did not find the oldKey in the newValue\n      // (because the keyValueArray is sorted and `newKey` is found later alphabetically).\n      // `\"background\" < \"color\"` so we need to delete `\"background\"` because it is not found in the\n      // new array.\n      oldIndex += 2;\n      setKey = oldKey;\n    } else {\n      // CREATE: newKey's is earlier alphabetically than oldKey's (or no oldKey) => we have new key.\n      // `\"color\" > \"background\"` so we need to add `color` because it is in new array but not in\n      // old array.\n      ngDevMode && assertDefined(newKey, 'Expecting to have a valid key');\n      newIndex += 2;\n      setKey = newKey;\n      setValue = newValue;\n    }\n    if (setKey !== null) {\n      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n    }\n    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n  }\n}\n\n/**\n * Update a simple (property name) styling.\n *\n * This function takes `prop` and updates the DOM to that value. The function takes the binding\n * value as well as binding priority into consideration to determine which value should be written\n * to DOM. (For example it may be determined that there is a higher priority overwrite which blocks\n * the DOM write, or if the value goes to `undefined` a lower priority overwrite may be consulted.)\n *\n * @param tView Associated `TView.data` contains the linked list of binding priorities.\n * @param tNode `TNode` where the binding is located.\n * @param lView `LView` contains the values associated with other styling binding at this `TNode`.\n * @param renderer Renderer to use if any updates.\n * @param prop Either style property name or a class name.\n * @param value Either style value for `prop` or `true`/`false` if `prop` is class.\n * @param isClassBased `true` if `class` (`false` if `style`)\n * @param bindingIndex Binding index of the binding.\n */\nfunction updateStyling(\n    tView: TView, tNode: TNode, lView: LView, renderer: Renderer3, prop: string,\n    value: string|undefined|null|boolean, isClassBased: boolean, bindingIndex: number) {\n  if (!(tNode.type & TNodeType.AnyRNode)) {\n    // It is possible to have styling on non-elements (such as ng-container).\n    // This is rare, but it does happen. In such a case, just ignore the binding.\n    return;\n  }\n  const tData = tView.data;\n  const tRange = tData[bindingIndex + 1] as TStylingRange;\n  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ?\n      findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) :\n      undefined;\n  if (!isStylingValuePresent(higherPriorityValue)) {\n    // We don't have a next duplicate, or we did not find a duplicate value.\n    if (!isStylingValuePresent(value)) {\n      // We should delete current value or restore to lower priority value.\n      if (getTStylingRangePrevDuplicate(tRange)) {\n        // We have a possible prev duplicate, let's retrieve it.\n        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n      }\n    }\n    const rNode = getNativeByIndex(getSelectedIndex(), lView) as RElement;\n    applyStyling(renderer, isClassBased, rNode, prop, value);\n  }\n}\n\n/**\n * Search for styling value with higher priority which is overwriting current value, or a\n * value of lower priority to which we should fall back if the value is `undefined`.\n *\n * When value is being applied at a location, related values need to be consulted.\n * - If there is a higher priority binding, we should be using that one instead.\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp1`\n *   requires that we check `exp2` to see if it is set to value other than `undefined`.\n * - If there is a lower priority binding and we are changing to `undefined`\n *   For example `<div  [style]=\"{color:exp1}\" [style.color]=\"exp2\">` change to `exp2` to\n *   `undefined` requires that we check `exp1` (and static values) and use that as new value.\n *\n * NOTE: The styling stores two values.\n * 1. The raw value which came from the application is stored at `index + 0` location. (This value\n *    is used for dirty checking).\n * 2. The normalized value is stored at `index + 1`.\n *\n * @param tData `TData` used for traversing the priority.\n * @param tNode `TNode` to use for resolving static styling. Also controls search direction.\n *   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n *      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n *   - `null` search prev and go all the way to end. Return last value where\n *     `isStylingValuePresent(value)` is true.\n * @param lView `LView` used for retrieving the actual values.\n * @param prop Property which we are interested in.\n * @param index Starting index in the linked list of styling bindings where the search should start.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nfunction findStylingValue(\n    tData: TData, tNode: TNode|null, lView: LView, prop: string, index: number,\n    isClassBased: boolean): any {\n  // `TNode` to use for resolving static styling. Also controls search direction.\n  //   - `TNode` search next and quit as soon as `isStylingValuePresent(value)` is true.\n  //      If no value found consult `tNode.residualStyle`/`tNode.residualClass` for default value.\n  //   - `null` search prev and go all the way to end. Return last value where\n  //     `isStylingValuePresent(value)` is true.\n  const isPrevDirection = tNode === null;\n  let value: any = undefined;\n  while (index > 0) {\n    const rawKey = tData[index] as TStylingKey;\n    const containsStatics = Array.isArray(rawKey);\n    // Unwrap the key if we contain static values.\n    const key = containsStatics ? (rawKey as string[])[1] : rawKey;\n    const isStylingMap = key === null;\n    let valueAtLViewIndex = lView[index + 1];\n    if (valueAtLViewIndex === NO_CHANGE) {\n      // In firstUpdatePass the styling instructions create a linked list of styling.\n      // On subsequent passes it is possible for a styling instruction to try to read a binding\n      // which\n      // has not yet executed. In that case we will find `NO_CHANGE` and we should assume that\n      // we have `undefined` (or empty array in case of styling-map instruction) instead. This\n      // allows the resolution to apply the value (which may later be overwritten when the\n      // binding actually executes.)\n      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : undefined;\n    }\n    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) :\n                                      key === prop ? valueAtLViewIndex : undefined;\n    if (containsStatics && !isStylingValuePresent(currentValue)) {\n      currentValue = keyValueArrayGet(rawKey as KeyValueArray<any>, prop);\n    }\n    if (isStylingValuePresent(currentValue)) {\n      value = currentValue;\n      if (isPrevDirection) {\n        return value;\n      }\n    }\n    const tRange = tData[index + 1] as TStylingRange;\n    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n  }\n  if (tNode !== null) {\n    // in case where we are going in next direction AND we did not find anything, we need to\n    // consult residual styling\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n    if (residual != null /** OR residual !=== undefined */) {\n      value = keyValueArrayGet(residual!, prop);\n    }\n  }\n  return value;\n}\n\n/**\n * Determines if the binding value should be used (or if the value is 'undefined' and hence priority\n * resolution should be used.)\n *\n * @param value Binding style value.\n */\nfunction isStylingValuePresent(value: any): boolean {\n  // Currently only `undefined` value is considered non-binding. That is `undefined` says I don't\n  // have an opinion as to what this binding should be and you should consult other bindings by\n  // priority to determine the valid value.\n  // This is extracted into a single function so that we have a single place to control this.\n  return value !== undefined;\n}\n\n/**\n * Normalizes and/or adds a suffix to the value.\n *\n * If value is `null`/`undefined` no suffix is added\n * @param value\n * @param suffix\n */\nfunction normalizeSuffix(value: any, suffix: string|undefined|null): string|null|undefined|boolean {\n  if (value == null /** || value === undefined */) {\n    // do nothing\n  } else if (typeof suffix === 'string') {\n    value = value + suffix;\n  } else if (typeof value === 'object') {\n    value = stringify(unwrapSafeValue(value));\n  }\n  return value;\n}\n\n\n/**\n * Tests if the `TNode` has input shadow.\n *\n * An input shadow is when a directive steals (shadows) the input by using `@Input('style')` or\n * `@Input('class')` as input.\n *\n * @param tNode `TNode` which we would like to see if it has shadow.\n * @param isClassBased `true` if `class` (`false` if `style`)\n */\nexport function hasStylingInputShadow(tNode: TNode, isClassBased: boolean) {\n  return (tNode.flags & (isClassBased ? TNodeFlags.hasClassInput : TNodeFlags.hasStyleInput)) !== 0;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nexport const enum BypassType {\n  Url = 'URL',\n  Html = 'HTML',\n  ResourceUrl = 'ResourceURL',\n  Script = 'Script',\n  Style = 'Style',\n}\n\n/**\n * Marker interface for a value that's safe to use in a particular context.\n *\n * @publicApi\n */\nexport interface SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as HTML.\n *\n * @publicApi\n */\nexport interface SafeHtml extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as style (CSS).\n *\n * @publicApi\n */\nexport interface SafeStyle extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as JavaScript.\n *\n * @publicApi\n */\nexport interface SafeScript extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL linking to a document.\n *\n * @publicApi\n */\nexport interface SafeUrl extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL to load executable code from.\n *\n * @publicApi\n */\nexport interface SafeResourceUrl extends SafeValue {}\n\n\nabstract class SafeValueImpl implements SafeValue {\n  constructor(public changingThisBreaksApplicationSecurity: string) {}\n\n  abstract getTypeName(): string;\n\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +\n        ` (see https://g.co/ng/security#xss)`;\n  }\n}\n\nclass SafeHtmlImpl extends SafeValueImpl implements SafeHtml {\n  getTypeName() {\n    return BypassType.Html;\n  }\n}\nclass SafeStyleImpl extends SafeValueImpl implements SafeStyle {\n  getTypeName() {\n    return BypassType.Style;\n  }\n}\nclass SafeScriptImpl extends SafeValueImpl implements SafeScript {\n  getTypeName() {\n    return BypassType.Script;\n  }\n}\nclass SafeUrlImpl extends SafeValueImpl implements SafeUrl {\n  getTypeName() {\n    return BypassType.Url;\n  }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl implements SafeResourceUrl {\n  getTypeName() {\n    return BypassType.ResourceUrl;\n  }\n}\n\nexport function unwrapSafeValue(value: SafeValue): string;\nexport function unwrapSafeValue<T>(value: T): T;\nexport function unwrapSafeValue<T>(value: T|SafeValue): T {\n  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity as any as T :\n                                          value as any as T;\n}\n\n\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Html): value is SafeHtml;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.ResourceUrl): value is SafeResourceUrl;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Script): value is SafeScript;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Style): value is SafeStyle;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType.Url): value is SafeUrl;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType): boolean;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType): boolean {\n  const actualType = getSanitizationBypassType(value);\n  if (actualType != null && actualType !== type) {\n    // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n    if (actualType === BypassType.ResourceUrl && type === BypassType.Url) return true;\n    throw new Error(\n        `Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`);\n  }\n  return actualType === type;\n}\n\nexport function getSanitizationBypassType(value: any): BypassType|null {\n  return value instanceof SafeValueImpl && value.getTypeName() as BypassType || null;\n}\n\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustHtml(trustedHtml: string): SafeHtml {\n  return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustStyle(trustedStyle: string): SafeStyle {\n  return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustScript(trustedScript: string): SafeScript {\n  return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustUrl(trustedUrl: string): SafeUrl {\n  return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustResourceUrl(trustedResourceUrl: string): SafeResourceUrl {\n  return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertEqual, assertIndexInRange} from '../../util/assert';\nimport {TElementNode, TNodeType} from '../interfaces/node';\nimport {HEADER_OFFSET, RENDERER, T_HOST} from '../interfaces/view';\nimport {appendChild, createTextNode} from '../node_manipulation';\nimport {getBindingIndex, getLView, getTView, setCurrentTNode} from '../state';\n\nimport {getOrCreateTNode} from './shared';\n\n\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Static string value to write.\n *\n * @codeGenApi\n */\nexport function ɵɵtext(index: number, value: string = ''): void {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  ngDevMode &&\n      assertEqual(\n          getBindingIndex(), tView.bindingStartIndex,\n          'text nodes should be created before any bindings');\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n\n  const tNode = tView.firstCreatePass ?\n      getOrCreateTNode(tView, adjustedIndex, TNodeType.Text, value, null) :\n      tView.data[adjustedIndex] as TElementNode;\n\n  const textNative = lView[adjustedIndex] = createTextNode(lView[RENDERER], value);\n  appendChild(tView, lView, textNative, tNode);\n\n  // Text nodes are self closing.\n  setCurrentTNode(tNode, false);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {getLView, getSelectedIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\n\nimport {interpolation1, interpolation2, interpolation3, interpolation4, interpolation5, interpolation6, interpolation7, interpolation8, interpolationV} from './interpolation';\nimport {textBindingInternal} from './shared';\n\n\n/**\n *\n * Update text content with a lone bound value\n *\n * Used when a text node has 1 interpolated value in it, an no additional text\n * surrounds that interpolated value:\n *\n * ```html\n * <div>{{v0}}</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate(v0);\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate(v0: any): typeof ɵɵtextInterpolate {\n  ɵɵtextInterpolate1('', v0, '');\n  return ɵɵtextInterpolate;\n}\n\n\n/**\n *\n * Update text content with single bound value surrounded by other text.\n *\n * Used when a text node has 1 interpolated value in it:\n *\n * ```html\n * <div>prefix{{v0}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate1('prefix', v0, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate1(\n    prefix: string, v0: any, suffix: string): typeof ɵɵtextInterpolate1 {\n  const lView = getLView();\n  const interpolated = interpolation1(lView, prefix, v0, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate1;\n}\n\n/**\n *\n * Update text content with 2 bound values surrounded by other text.\n *\n * Used when a text node has 2 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): typeof ɵɵtextInterpolate2 {\n  const lView = getLView();\n  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate2;\n}\n\n/**\n *\n * Update text content with 3 bound values surrounded by other text.\n *\n * Used when a text node has 3 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate3(\n * 'prefix', v0, '-', v1, '-', v2, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string): typeof ɵɵtextInterpolate3 {\n  const lView = getLView();\n  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate3;\n}\n\n/**\n *\n * Update text content with 4 bound values surrounded by other text.\n *\n * Used when a text node has 4 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate4(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see ɵɵtextInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): typeof ɵɵtextInterpolate4 {\n  const lView = getLView();\n  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate4;\n}\n\n/**\n *\n * Update text content with 5 bound values surrounded by other text.\n *\n * Used when a text node has 5 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate5(\n * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): typeof ɵɵtextInterpolate5 {\n  const lView = getLView();\n  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate5;\n}\n\n/**\n *\n * Update text content with 6 bound values surrounded by other text.\n *\n * Used when a text node has 6 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate6(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');\n * ```\n *\n * @param i4 Static value used for concatenation only.\n * @param v5 Value checked for change. @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): typeof ɵɵtextInterpolate6 {\n  const lView = getLView();\n  const interpolated =\n      interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate6;\n}\n\n/**\n *\n * Update text content with 7 bound values surrounded by other text.\n *\n * Used when a text node has 7 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate7(\n *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any,\n    suffix: string): typeof ɵɵtextInterpolate7 {\n  const lView = getLView();\n  const interpolated =\n      interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate7;\n}\n\n/**\n *\n * Update text content with 8 bound values surrounded by other text.\n *\n * Used when a text node has 8 interpolated values in it:\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolate8(\n *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');\n * ```\n * @returns itself, so that it may be chained.\n * @see textInterpolateV\n * @codeGenApi\n */\nexport function ɵɵtextInterpolate8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): typeof ɵɵtextInterpolate8 {\n  const lView = getLView();\n  const interpolated = interpolation8(\n      lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolate8;\n}\n\n/**\n * Update text content with 9 or more bound values other surrounded by text.\n *\n * Used when the number of interpolated values exceeds 8.\n *\n * ```html\n * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>\n * ```\n *\n * Its compiled representation is:\n *\n * ```ts\n * ɵɵtextInterpolateV(\n *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,\n *  'suffix']);\n * ```\n *.\n * @param values The collection of values and the strings in between those values, beginning with\n * a string prefix and ending with a string suffix.\n * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)\n *\n * @returns itself, so that it may be chained.\n * @codeGenApi\n */\nexport function ɵɵtextInterpolateV(values: any[]): typeof ɵɵtextInterpolateV {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated as string);\n  }\n  return ɵɵtextInterpolateV;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertLessThan} from '../../util/assert';\nimport {bindingUpdated, bindingUpdated2, bindingUpdated3, bindingUpdated4} from '../bindings';\nimport {LView} from '../interfaces/view';\nimport {getBindingIndex, incrementBindingIndex, nextBindingIndex, setBindingIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {renderStringify} from '../util/stringify_utils';\n\n\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(lView: LView, values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n  let isBindingUpdated = false;\n  let bindingIndex = getBindingIndex();\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n  }\n  setBindingIndex(bindingIndex);\n\n  if (!isBindingUpdated) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += renderStringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(lView: LView, prefix: string, v0: any, suffix: string): string|\n    NO_CHANGE {\n  const different = bindingUpdated(lView, nextBindingIndex(), v0);\n  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 2 expressions.\n */\nexport function interpolation2(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n  incrementBindingIndex(2);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 3 expressions.\n */\nexport function interpolation3(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any,\n    suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n  incrementBindingIndex(3);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Create an interpolation binding with 4 expressions.\n */\nexport function interpolation4(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  incrementBindingIndex(4);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n          renderStringify(v2) + i2 + renderStringify(v3) + suffix :\n                     NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 5 expressions.\n */\nexport function interpolation5(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n  incrementBindingIndex(5);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n          renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix :\n                     NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 6 expressions.\n */\nexport function interpolation6(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n  incrementBindingIndex(6);\n\n  return different ?\n      prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 +\n          renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 7 expressions.\n */\nexport function interpolation7(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n  incrementBindingIndex(7);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n          renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n          renderStringify(v5) + i5 + renderStringify(v6) + suffix :\n                     NO_CHANGE;\n}\n\n/**\n * Creates an interpolation binding with 8 expressions.\n */\nexport function interpolation8(\n    lView: LView, prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string,\n    v3: any, i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n  incrementBindingIndex(8);\n\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 +\n          renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 +\n          renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix :\n                     NO_CHANGE;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// THIS CODE IS GENERATED - DO NOT MODIFY\n// See angular/tools/gulp-tasks/cldr/extract.js\n\nconst u = undefined;\n\nfunction plural(n: number): number {\n  let i = Math.floor(Math.abs(n)), v = n.toString().replace(/^[^.]*\\.?/, '').length;\n  if (i === 1 && v === 0) return 1;\n  return 5;\n}\n\nexport default [\n  'en',\n  [['a', 'p'], ['AM', 'PM'], u],\n  [['AM', 'PM'], u, u],\n  [\n    ['S', 'M', 'T', 'W', 'T', 'F', 'S'], ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n    ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n    ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']\n  ],\n  u,\n  [\n    ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],\n    ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    [\n      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',\n      'October', 'November', 'December'\n    ]\n  ],\n  u,\n  [['B', 'A'], ['BC', 'AD'], ['Before Christ', 'Anno Domini']],\n  0,\n  [6, 0],\n  ['M/d/yy', 'MMM d, y', 'MMMM d, y', 'EEEE, MMMM d, y'],\n  ['h:mm a', 'h:mm:ss a', 'h:mm:ss a z', 'h:mm:ss a zzzz'],\n  ['{1}, {0}', u, '{1} \\'at\\' {0}', u],\n  ['.', ',', ';', '%', '+', '-', 'E', '×', '‰', '∞', 'NaN', ':'],\n  ['#,##0.###', '#,##0%', '¤#,##0.00', '#E0'],\n  'USD',\n  '$',\n  'US Dollar',\n  {},\n  'ltr',\n  plural\n];\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {global} from '../util/global';\n\nimport localeEn from './locale_en';\n\n/**\n * This const is used to store the locale data registered with `registerLocaleData`\n */\nlet LOCALE_DATA: {[localeId: string]: any} = {};\n\n/**\n * Register locale data to be used internally by Angular. See the\n * [\"I18n guide\"](guide/i18n#i18n-pipes) to know how to import additional locale data.\n *\n * The signature `registerLocaleData(data: any, extraData?: any)` is deprecated since v5.1\n */\nexport function registerLocaleData(data: any, localeId?: string|any, extraData?: any): void {\n  if (typeof localeId !== 'string') {\n    extraData = localeId;\n    localeId = data[LocaleDataIndex.LocaleId];\n  }\n\n  localeId = localeId.toLowerCase().replace(/_/g, '-');\n\n  LOCALE_DATA[localeId] = data;\n\n  if (extraData) {\n    LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData;\n  }\n}\n\n/**\n * Finds the locale data for a given locale.\n *\n * @param locale The locale code.\n * @returns The locale data.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n */\nexport function findLocaleData(locale: string): any {\n  const normalizedLocale = normalizeLocale(locale);\n\n  let match = getLocaleData(normalizedLocale);\n  if (match) {\n    return match;\n  }\n\n  // let's try to find a parent locale\n  const parentLocale = normalizedLocale.split('-')[0];\n  match = getLocaleData(parentLocale);\n  if (match) {\n    return match;\n  }\n\n  if (parentLocale === 'en') {\n    return localeEn;\n  }\n\n  throw new Error(`Missing locale data for the locale \"${locale}\".`);\n}\n\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n */\nexport function getLocaleCurrencyCode(locale: string): string|null {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.CurrencyCode] || null;\n}\n\n/**\n * Retrieves the plural function used by ICU expressions to determine the plural case to use\n * for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The plural function for the locale.\n * @see `NgPlural`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n */\nexport function getLocalePluralCase(locale: string): (value: number) => number {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.PluralCase];\n}\n\n\n\n/**\n * Helper function to get the given `normalizedLocale` from `LOCALE_DATA`\n * or from the global `ng.common.locale`.\n */\nexport function getLocaleData(normalizedLocale: string): any {\n  if (!(normalizedLocale in LOCALE_DATA)) {\n    LOCALE_DATA[normalizedLocale] = global.ng && global.ng.common && global.ng.common.locales &&\n        global.ng.common.locales[normalizedLocale];\n  }\n  return LOCALE_DATA[normalizedLocale];\n}\n\n/**\n * Helper function to remove all the locale data from `LOCALE_DATA`.\n */\nexport function unregisterAllLocaleData() {\n  LOCALE_DATA = {};\n}\n\n/**\n * Index of each type of locale data from the locale data array\n */\nexport enum LocaleDataIndex {\n  LocaleId = 0,\n  DayPeriodsFormat,\n  DayPeriodsStandalone,\n  DaysFormat,\n  DaysStandalone,\n  MonthsFormat,\n  MonthsStandalone,\n  Eras,\n  FirstDayOfWeek,\n  WeekendRange,\n  DateFormat,\n  TimeFormat,\n  DateTimeFormat,\n  NumberSymbols,\n  NumberFormats,\n  CurrencyCode,\n  CurrencySymbol,\n  CurrencyName,\n  Currencies,\n  Directionality,\n  PluralCase,\n  ExtraData\n}\n\n/**\n * Index of each type of locale data from the extra locale data array\n */\nexport const enum ExtraLocaleDataIndex {\n  ExtraDayPeriodFormats = 0,\n  ExtraDayPeriodStandalone,\n  ExtraDayPeriodsRules\n}\n\n/**\n * Index of each value in currency data (used to describe CURRENCIES_EN in currencies.ts)\n */\nexport const enum CurrencyIndex {\n  Symbol = 0,\n  SymbolNarrow,\n  NbOfDigits\n}\n\n/**\n * Returns the canonical form of a locale name - lowercase with `_` replaced with `-`.\n */\nfunction normalizeLocale(locale: string): string {\n  return locale.toLowerCase().replace(/_/g, '-');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DEFAULT_LOCALE_ID} from '../../i18n/localization';\nimport {assertDefined} from '../../util/assert';\n\n\n/**\n * The locale id that the application is currently using (for translations and ICU expressions).\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nlet LOCALE_ID = DEFAULT_LOCALE_ID;\n\n/**\n * Sets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n *\n * @param localeId\n */\nexport function setLocaleId(localeId: string) {\n  assertDefined(localeId, `Expected localeId to be defined`);\n  if (typeof localeId === 'string') {\n    LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');\n  }\n}\n\n/**\n * Gets the locale id that will be used for translations and ICU expressions.\n * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine\n * but is now defined as a global value.\n */\nexport function getLocaleId(): string {\n  return LOCALE_ID;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getLocalePluralCase} from './locale_data_api';\n\nconst pluralMapping = ['zero', 'one', 'two', 'few', 'many'];\n\n/**\n * Returns the plural case based on the locale\n */\nexport function getPluralCase(value: string, locale: string): string {\n  const plural = getLocalePluralCase(locale)(parseInt(value, 10));\n  const result = pluralMapping[plural];\n  return (result !== undefined) ? result : 'other';\n}\n\n/**\n * The locale id that the application is using by default (for translations and ICU expressions).\n */\nexport const DEFAULT_LOCALE_ID = 'en-US';\n\n/**\n * USD currency code that the application uses by default for CurrencyPipe when no\n * DEFAULT_CURRENCY_CODE is provided.\n */\nexport const USD_CURRENCY_CODE = 'USD';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// The functions in this file verify that the assumptions we are making\n// about state in an instruction are correct before implementing any logic.\n// They are meant only to be called in dev mode as sanity checks.\n\nimport {stringify} from './stringify';\n\nexport function assertNumber(actual: any, msg: string): asserts actual is number {\n  if (!(typeof actual === 'number')) {\n    throwError(msg, typeof actual, 'number', '===');\n  }\n}\n\nexport function assertNumberInRange(\n    actual: any, minInclusive: number, maxInclusive: number): asserts actual is number {\n  assertNumber(actual, 'Expected a number');\n  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\n\nexport function assertString(actual: any, msg: string): asserts actual is string {\n  if (!(typeof actual === 'string')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n  }\n}\n\nexport function assertFunction(actual: any, msg: string): asserts actual is Function {\n  if (!(typeof actual === 'function')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, msg: string) {\n  if (!(actual == expected)) {\n    throwError(msg, actual, expected, '==');\n  }\n}\n\nexport function assertNotEqual<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual != expected)) {\n    throwError(msg, actual, expected, '!=');\n  }\n}\n\nexport function assertSame<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual === expected)) {\n    throwError(msg, actual, expected, '===');\n  }\n}\n\nexport function assertNotSame<T>(actual: T, expected: T, msg: string) {\n  if (!(actual !== expected)) {\n    throwError(msg, actual, expected, '!==');\n  }\n}\n\nexport function assertLessThan<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual < expected)) {\n    throwError(msg, actual, expected, '<');\n  }\n}\n\nexport function assertLessThanOrEqual<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual <= expected)) {\n    throwError(msg, actual, expected, '<=');\n  }\n}\n\nexport function assertGreaterThan<T>(actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual > expected)) {\n    throwError(msg, actual, expected, '>');\n  }\n}\n\nexport function assertGreaterThanOrEqual<T>(\n    actual: T, expected: T, msg: string): asserts actual is T {\n  if (!(actual >= expected)) {\n    throwError(msg, actual, expected, '>=');\n  }\n}\n\nexport function assertNotDefined<T>(actual: T, msg: string) {\n  if (actual != null) {\n    throwError(msg, actual, null, '==');\n  }\n}\n\nexport function assertDefined<T>(actual: T|null|undefined, msg: string): asserts actual is T {\n  if (actual == null) {\n    throwError(msg, actual, null, '!=');\n  }\n}\n\nexport function throwError(msg: string): never;\nexport function throwError(msg: string, actual: any, expected: any, comparison: string): never;\nexport function throwError(msg: string, actual?: any, expected?: any, comparison?: string): never {\n  throw new Error(\n      `ASSERTION ERROR: ${msg}` +\n      (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\n\nexport function assertDomNode(node: any): asserts node is Node {\n  // If we're in a worker, `Node` will not be defined.\n  if (!(typeof Node !== 'undefined' && node instanceof Node) &&\n      !(typeof node === 'object' && node != null &&\n        node.constructor.name === 'WebWorkerRenderNode')) {\n    throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n  }\n}\n\n\nexport function assertIndexInRange(arr: any[], index: number) {\n  assertDefined(arr, 'Array must be defined.');\n  const maxLen = arr.length;\n  if (index < 0 || index >= maxLen) {\n    throwError(`Index expected to be less than ${maxLen} but got ${index}`);\n  }\n}\n\n\nexport function assertOneOf(value: any, ...validValues: any[]) {\n  if (validValues.indexOf(value) !== -1) return true;\n  throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${\n      JSON.stringify(value)}.`);\n}","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef} from '../change_detection/change_detection';\nimport {Injector} from '../di/injector';\nimport {Type} from '../interface/type';\n\nimport {ElementRef} from './element_ref';\nimport {NgModuleRef} from './ng_module_factory';\nimport {ViewRef} from './view_ref';\n\n/**\n * Represents a component created by a `ComponentFactory`.\n * Provides access to the component instance and related objects,\n * and provides the means of destroying the instance.\n *\n * @publicApi\n */\nexport abstract class ComponentRef<C> {\n  /**\n   * The host or anchor [element](guide/glossary#element) for this component instance.\n   */\n  abstract get location(): ElementRef;\n\n  /**\n   * The [dependency injector](guide/glossary#injector) for this component instance.\n   */\n  abstract get injector(): Injector;\n\n  /**\n   * This component instance.\n   */\n  abstract get instance(): C;\n\n  /**\n   * The [host view](guide/glossary#view-tree) defined by the template\n   * for this component instance.\n   */\n  abstract get hostView(): ViewRef;\n\n  /**\n   * The change detector for this component instance.\n   */\n  abstract get changeDetectorRef(): ChangeDetectorRef;\n\n  /**\n   * The type of this component (as created by a `ComponentFactory` class).\n   */\n  abstract get componentType(): Type<any>;\n\n  /**\n   * Destroys the component instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * A lifecycle hook that provides additional developer-defined cleanup\n   * functionality for the component.\n   * @param callback A handler function that cleans up developer-defined data\n   * associated with this component. Called when the `destroy()` method is invoked.\n   */\n  abstract onDestroy(callback: Function): void;\n}\n\n/**\n * Base class for a factory that can create a component dynamically.\n * Instantiate a factory for a given type of component with `resolveComponentFactory()`.\n * Use the resulting `ComponentFactory.create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n *\n * @publicApi\n */\nexport abstract class ComponentFactory<C> {\n  /**\n   * The component's HTML selector.\n   */\n  abstract get selector(): string;\n  /**\n   * The type of component the factory will create.\n   */\n  abstract get componentType(): Type<any>;\n  /**\n   * Selector for all <ng-content> elements in the component.\n   */\n  abstract get ngContentSelectors(): string[];\n  /**\n   * The inputs of the component.\n   */\n  abstract get inputs(): {propName: string, templateName: string}[];\n  /**\n   * The outputs of the component.\n   */\n  abstract get outputs(): {propName: string, templateName: string}[];\n  /**\n   * Creates a new component.\n   */\n  abstract create(\n      injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string|any,\n      ngModule?: NgModuleRef<any>): ComponentRef<C>;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {Type} from '../interface/type';\nimport {stringify} from '../util/stringify';\n\nimport {ComponentFactory, ComponentRef} from './component_factory';\nimport {NgModuleRef} from './ng_module_factory';\n\nexport function noComponentFactoryError(component: Function) {\n  const error = Error(`No component factory found for ${\n      stringify(component)}. Did you add it to @NgModule.entryComponents?`);\n  (error as any)[ERROR_COMPONENT] = component;\n  return error;\n}\n\nconst ERROR_COMPONENT = 'ngComponent';\n\nexport function getComponent(error: Error): Type<any> {\n  return (error as any)[ERROR_COMPONENT];\n}\n\n\nclass _NullComponentFactoryResolver implements ComponentFactoryResolver {\n  resolveComponentFactory<T>(component: {new(...args: any[]): T}): ComponentFactory<T> {\n    throw noComponentFactoryError(component);\n  }\n}\n\n/**\n * A simple registry that maps `Components` to generated `ComponentFactory` classes\n * that can be used to create instances of components.\n * Use to obtain the factory for a given component type,\n * then use the factory's `create()` method to create a component of that type.\n *\n * @see [Dynamic Components](guide/dynamic-component-loader)\n * @publicApi\n */\nexport abstract class ComponentFactoryResolver {\n  static NULL: ComponentFactoryResolver = new _NullComponentFactoryResolver();\n  /**\n   * Retrieves the factory object that creates a component of the given type.\n   * @param component The component type.\n   */\n  abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n}\n\nexport class CodegenComponentFactoryResolver implements ComponentFactoryResolver {\n  private _factories = new Map<any, ComponentFactory<any>>();\n\n  constructor(\n      factories: ComponentFactory<any>[], private _parent: ComponentFactoryResolver,\n      private _ngModule: NgModuleRef<any>) {\n    for (let i = 0; i < factories.length; i++) {\n      const factory = factories[i];\n      this._factories.set(factory.componentType, factory);\n    }\n  }\n\n  resolveComponentFactory<T>(component: {new(...args: any[]): T}): ComponentFactory<T> {\n    let factory = this._factories.get(component);\n    if (!factory && this._parent) {\n      factory = this._parent.resolveComponentFactory(component);\n    }\n    if (!factory) {\n      throw noComponentFactoryError(component);\n    }\n    return new ComponentFactoryBoundToModule(factory, this._ngModule);\n  }\n}\n\nexport class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> {\n  readonly selector: string;\n  readonly componentType: Type<any>;\n  readonly ngContentSelectors: string[];\n  readonly inputs: {propName: string, templateName: string}[];\n  readonly outputs: {propName: string, templateName: string}[];\n\n  constructor(private factory: ComponentFactory<C>, private ngModule: NgModuleRef<any>) {\n    super();\n    this.selector = factory.selector;\n    this.componentType = factory.componentType;\n    this.ngContentSelectors = factory.ngContentSelectors;\n    this.inputs = factory.inputs;\n    this.outputs = factory.outputs;\n  }\n\n  create(\n      injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string|any,\n      ngModule?: NgModuleRef<any>): ComponentRef<C> {\n    return this.factory.create(\n        injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function noop(...args: any[]): any {\n  // Do nothing.\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TNode} from '../render3/interfaces/node';\nimport {RElement} from '../render3/interfaces/renderer_dom';\nimport {LView} from '../render3/interfaces/view';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {getNativeByTNode} from '../render3/util/view_utils';\nimport {noop} from '../util/noop';\n\n/**\n * Creates an ElementRef from the most recent node.\n *\n * @returns The ElementRef instance to use\n */\nexport function injectElementRef(): ElementRef {\n  return createElementRef(getCurrentTNode()!, getLView());\n}\n\n/**\n * Creates an ElementRef given a node.\n *\n * @param tNode The node for which you'd like an ElementRef\n * @param lView The view to which the node belongs\n * @returns The ElementRef instance to use\n */\nexport function createElementRef(tNode: TNode, lView: LView): ElementRef {\n  return new ElementRef(getNativeByTNode(tNode, lView) as RElement);\n}\n\nexport const SWITCH_ELEMENT_REF_FACTORY__POST_R3__ = injectElementRef;\nconst SWITCH_ELEMENT_REF_FACTORY__PRE_R3__ = noop;\nconst SWITCH_ELEMENT_REF_FACTORY: typeof injectElementRef = SWITCH_ELEMENT_REF_FACTORY__PRE_R3__;\n\n/**\n * A wrapper around a native element inside of a View.\n *\n * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM\n * element.\n *\n * @security Permitting direct access to the DOM can make your application more vulnerable to\n * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the\n * [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\n// Note: We don't expose things like `Injector`, `ViewContainer`, ... here,\n// i.e. users have to ask for what they need. With that, we can build better analysis tools\n// and could do better codegen in the future.\nexport class ElementRef<T = any> {\n  /**\n   * The underlying native element or `null` if direct access to native elements is not supported\n   * (e.g. when the application runs in a web worker).\n   *\n   * <div class=\"callout is-critical\">\n   *   <header>Use with caution</header>\n   *   <p>\n   *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n   *    data-binding provided by Angular instead. Alternatively you can take a look at {@link\n   * Renderer2}\n   *    which provides API that can safely be used even when direct access to native elements is not\n   *    supported.\n   *   </p>\n   *   <p>\n   *    Relying on direct DOM access creates tight coupling between your application and rendering\n   *    layers which will make it impossible to separate the two and deploy your application into a\n   *    web worker.\n   *   </p>\n   * </div>\n   *\n   */\n  public nativeElement: T;\n\n  constructor(nativeElement: T) {\n    this.nativeElement = nativeElement;\n  }\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => ElementRef = SWITCH_ELEMENT_REF_FACTORY;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../di/injection_token';\nimport {isProceduralRenderer} from '../render3/interfaces/renderer';\nimport {isLView} from '../render3/interfaces/type_checks';\nimport {LView, RENDERER} from '../render3/interfaces/view';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {getComponentLViewByIndex} from '../render3/util/view_utils';\nimport {noop} from '../util/noop';\nimport {RendererStyleFlags2, RendererType2} from './api_flags';\n\n\nexport const Renderer2Interceptor = new InjectionToken<Renderer2[]>('Renderer2Interceptor');\n\n\n/**\n * Creates and initializes a custom renderer that implements the `Renderer2` base class.\n *\n * @publicApi\n */\nexport abstract class RendererFactory2 {\n  /**\n   * Creates and initializes a custom renderer for a host DOM element.\n   * @param hostElement The element to render.\n   * @param type The base class to implement.\n   * @returns The new custom renderer instance.\n   */\n  abstract createRenderer(hostElement: any, type: RendererType2|null): Renderer2;\n  /**\n   * A callback invoked when rendering has begun.\n   */\n  abstract begin?(): void;\n  /**\n   * A callback invoked when rendering has completed.\n   */\n  abstract end?(): void;\n  /**\n   * Use with animations test-only mode. Notifies the test when rendering has completed.\n   * @returns The asynchronous result of the developer-defined function.\n   */\n  abstract whenRenderingDone?(): Promise<any>;\n}\n\n\n/**\n * Extend this base class to implement custom rendering. By default, Angular\n * renders a template into DOM. You can use custom rendering to intercept\n * rendering calls, or to render to something other than DOM.\n *\n * Create your custom renderer using `RendererFactory2`.\n *\n * Use a custom renderer to bypass Angular's templating and\n * make custom UI changes that can't be expressed declaratively.\n * For example if you need to set a property or an attribute whose name is\n * not statically known, use the `setProperty()` or\n * `setAttribute()` method.\n *\n * @publicApi\n */\nexport abstract class Renderer2 {\n  /**\n   * Use to store arbitrary developer-defined data on a renderer instance,\n   * as an object containing key-value pairs.\n   * This is useful for renderers that delegate to other renderers.\n   */\n  abstract get data(): {[key: string]: any};\n\n  /**\n   * Implement this callback to destroy the renderer or the host element.\n   */\n  abstract destroy(): void;\n  /**\n   * Implement this callback to create an instance of the host element.\n   * @param name An identifying name for the new element, unique within the namespace.\n   * @param namespace The namespace for the new element.\n   * @returns The new element.\n   */\n  abstract createElement(name: string, namespace?: string|null): any;\n  /**\n   * Implement this callback to add a comment to the DOM of the host element.\n   * @param value The comment text.\n   * @returns The modified element.\n   */\n  abstract createComment(value: string): any;\n\n  /**\n   * Implement this callback to add text to the DOM of the host element.\n   * @param value The text string.\n   * @returns The modified element.\n   */\n  abstract createText(value: string): any;\n  /**\n   * If null or undefined, the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  // TODO(issue/24571): remove '!'.\n  destroyNode!: ((node: any) => void)|null;\n  /**\n   * Appends a child to a given parent node in the host element DOM.\n   * @param parent The parent node.\n   * @param newChild The new child node.\n   */\n  abstract appendChild(parent: any, newChild: any): void;\n  /**\n   * Implement this callback to insert a child node at a given position in a parent node\n   * in the host element DOM.\n   * @param parent The parent node.\n   * @param newChild The new child nodes.\n   * @param refChild The existing child node before which `newChild` is inserted.\n   * @param isMove Optional argument which signifies if the current `insertBefore` is a result of a\n   *     move. Animation uses this information to trigger move animations. In the past the Animation\n   *     would always assume that any `insertBefore` is a move. This is not strictly true because\n   *     with runtime i18n it is possible to invoke `insertBefore` as a result of i18n and it should\n   *     not trigger an animation move.\n   */\n  abstract insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean): void;\n  /**\n   * Implement this callback to remove a child node from the host element's DOM.\n   * @param parent The parent node.\n   * @param oldChild The child node to remove.\n   * @param isHostElement Optionally signal to the renderer whether this element is a host element\n   * or not\n   */\n  abstract removeChild(parent: any, oldChild: any, isHostElement?: boolean): void;\n  /**\n   * Implement this callback to prepare an element to be bootstrapped\n   * as a root element, and return the element instance.\n   * @param selectorOrNode The DOM element.\n   * @param preserveContent Whether the contents of the root element\n   * should be preserved, or cleared upon bootstrap (default behavior).\n   * Use with `ViewEncapsulation.ShadowDom` to allow simple native\n   * content projection via `<slot>` elements.\n   * @returns The root element.\n   */\n  abstract selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): any;\n  /**\n   * Implement this callback to get the parent of a given node\n   * in the host element's DOM.\n   * @param node The child node to query.\n   * @returns The parent node, or null if there is no parent.\n   * For WebWorkers, always returns true.\n   * This is because the check is synchronous,\n   * and the caller can't rely on checking for null.\n   */\n  abstract parentNode(node: any): any;\n  /**\n   * Implement this callback to get the next sibling node of a given node\n   * in the host element's DOM.\n   * @returns The sibling node, or null if there is no sibling.\n   * For WebWorkers, always returns a value.\n   * This is because the check is synchronous,\n   * and the caller can't rely on checking for null.\n   */\n  abstract nextSibling(node: any): any;\n  /**\n   * Implement this callback to set an attribute value for an element in the DOM.\n   * @param el The element.\n   * @param name The attribute name.\n   * @param value The new value.\n   * @param namespace The namespace.\n   */\n  abstract setAttribute(el: any, name: string, value: string, namespace?: string|null): void;\n\n  /**\n   * Implement this callback to remove an attribute from an element in the DOM.\n   * @param el The element.\n   * @param name The attribute name.\n   * @param namespace The namespace.\n   */\n  abstract removeAttribute(el: any, name: string, namespace?: string|null): void;\n  /**\n   * Implement this callback to add a class to an element in the DOM.\n   * @param el The element.\n   * @param name The class name.\n   */\n  abstract addClass(el: any, name: string): void;\n\n  /**\n   * Implement this callback to remove a class from an element in the DOM.\n   * @param el The element.\n   * @param name The class name.\n   */\n  abstract removeClass(el: any, name: string): void;\n\n  /**\n   * Implement this callback to set a CSS style for an element in the DOM.\n   * @param el The element.\n   * @param style The name of the style.\n   * @param value The new value.\n   * @param flags Flags for style variations. No flags are set by default.\n   */\n  abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;\n\n  /**\n   * Implement this callback to remove the value from a CSS style for an element in the DOM.\n   * @param el The element.\n   * @param style The name of the style.\n   * @param flags Flags for style variations to remove, if set. ???\n   */\n  abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;\n\n  /**\n   * Implement this callback to set the value of a property of an element in the DOM.\n   * @param el The element.\n   * @param name The property name.\n   * @param value The new value.\n   */\n  abstract setProperty(el: any, name: string, value: any): void;\n\n  /**\n   * Implement this callback to set the value of a node in the host element.\n   * @param node The node.\n   * @param value The new value.\n   */\n  abstract setValue(node: any, value: string): void;\n\n  /**\n   * Implement this callback to start an event listener.\n   * @param target The context in which to listen for events. Can be\n   * the entire window or document, the body of the document, or a specific\n   * DOM element.\n   * @param eventName The event to listen for.\n   * @param callback A handler function to invoke when the event occurs.\n   * @returns An \"unlisten\" function for disposing of this handler.\n   */\n  abstract listen(\n      target: 'window'|'document'|'body'|any, eventName: string,\n      callback: (event: any) => boolean | void): () => void;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => Renderer2 = () => SWITCH_RENDERER2_FACTORY();\n}\n\n\nexport const SWITCH_RENDERER2_FACTORY__POST_R3__ = injectRenderer2;\nconst SWITCH_RENDERER2_FACTORY__PRE_R3__ = noop;\nconst SWITCH_RENDERER2_FACTORY: typeof injectRenderer2 = SWITCH_RENDERER2_FACTORY__PRE_R3__;\n\n/** Returns a Renderer2 (or throws when application was bootstrapped with Renderer3) */\nfunction getOrCreateRenderer2(lView: LView): Renderer2 {\n  const renderer = lView[RENDERER];\n  if (ngDevMode && !isProceduralRenderer(renderer)) {\n    throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');\n  }\n  return renderer as Renderer2;\n}\n\n/** Injects a Renderer2 for the current component. */\nexport function injectRenderer2(): Renderer2 {\n  // We need the Renderer to be based on the component that it's being injected into, however since\n  // DI happens before we've entered its view, `getLView` will return the parent view instead.\n  const lView = getLView();\n  const tNode = getCurrentTNode()!;\n  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n  return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵɵdefineInjectable} from '../di/interface/defs';\nimport {SecurityContext} from './security';\n\n/**\n * Sanitizer is used by the views to sanitize potentially dangerous values.\n *\n * @publicApi\n */\nexport abstract class Sanitizer {\n  abstract sanitize(context: SecurityContext, value: {}|string|null): string|null;\n  /** @nocollapse */\n  static ɵprov = ɵɵdefineInjectable({\n    token: Sanitizer,\n    providedIn: 'root',\n    factory: () => null,\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @description Represents the version of Angular\n *\n * @publicApi\n */\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    this.major = full.split('.')[0];\n    this.minor = full.split('.')[1];\n    this.patch = full.split('.').slice(2).join('.');\n  }\n}\n\n/**\n * @publicApi\n */\nexport const VERSION = new Version('0.0.0-PLACEHOLDER');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {stringify} from '../../util/stringify';\nimport {isListLikeIterable, iterateListLike} from '../change_detection_util';\n\nimport {IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, NgIterable, TrackByFunction} from './iterable_differs';\n\n\nexport class DefaultIterableDifferFactory implements IterableDifferFactory {\n  constructor() {}\n  supports(obj: Object|null|undefined): boolean {\n    return isListLikeIterable(obj);\n  }\n\n  create<V>(trackByFn?: TrackByFunction<V>): DefaultIterableDiffer<V> {\n    return new DefaultIterableDiffer<V>(trackByFn);\n  }\n}\n\nconst trackByIdentity = (index: number, item: any) => item;\n\n/**\n * @deprecated v4.0.0 - Should not be part of public API.\n * @publicApi\n */\nexport class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {\n  public readonly length: number = 0;\n  // TODO(issue/24571): remove '!'.\n  public readonly collection!: V[]|Iterable<V>|null;\n  // Keeps track of the used records at any point in time (during & across `_check()` calls)\n  private _linkedRecords: _DuplicateMap<V>|null = null;\n  // Keeps track of the removed records at any point in time during `_check()` calls.\n  private _unlinkedRecords: _DuplicateMap<V>|null = null;\n  private _previousItHead: IterableChangeRecord_<V>|null = null;\n  private _itHead: IterableChangeRecord_<V>|null = null;\n  private _itTail: IterableChangeRecord_<V>|null = null;\n  private _additionsHead: IterableChangeRecord_<V>|null = null;\n  private _additionsTail: IterableChangeRecord_<V>|null = null;\n  private _movesHead: IterableChangeRecord_<V>|null = null;\n  private _movesTail: IterableChangeRecord_<V>|null = null;\n  private _removalsHead: IterableChangeRecord_<V>|null = null;\n  private _removalsTail: IterableChangeRecord_<V>|null = null;\n  // Keeps track of records where custom track by is the same, but item identity has changed\n  private _identityChangesHead: IterableChangeRecord_<V>|null = null;\n  private _identityChangesTail: IterableChangeRecord_<V>|null = null;\n  private _trackByFn: TrackByFunction<V>;\n\n  constructor(trackByFn?: TrackByFunction<V>) {\n    this._trackByFn = trackByFn || trackByIdentity;\n  }\n\n  forEachItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._itHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachOperation(\n      fn: (item: IterableChangeRecord<V>, previousIndex: number|null, currentIndex: number|null) =>\n          void) {\n    let nextIt = this._itHead;\n    let nextRemove = this._removalsHead;\n    let addRemoveOffset = 0;\n    let moveOffsets: number[]|null = null;\n    while (nextIt || nextRemove) {\n      // Figure out which is the next record to process\n      // Order: remove, add, move\n      const record: IterableChangeRecord<V> = !nextRemove ||\n              nextIt &&\n                  nextIt.currentIndex! <\n                      getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?\n          nextIt! :\n          nextRemove;\n      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\n      const currentIndex = record.currentIndex;\n\n      // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\n      if (record === nextRemove) {\n        addRemoveOffset--;\n        nextRemove = nextRemove._nextRemoved;\n      } else {\n        nextIt = nextIt!._next;\n        if (record.previousIndex == null) {\n          addRemoveOffset++;\n        } else {\n          // INVARIANT:  currentIndex < previousIndex\n          if (!moveOffsets) moveOffsets = [];\n          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\n          const localCurrentIndex = currentIndex! - addRemoveOffset;\n          if (localMovePreviousIndex != localCurrentIndex) {\n            for (let i = 0; i < localMovePreviousIndex; i++) {\n              const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\n              const index = offset + i;\n              if (localCurrentIndex <= index && index < localMovePreviousIndex) {\n                moveOffsets[i] = offset + 1;\n              }\n            }\n            const previousIndex = record.previousIndex;\n            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\n          }\n        }\n      }\n\n      if (adjPreviousIndex !== currentIndex) {\n        fn(record, adjPreviousIndex, currentIndex);\n      }\n    }\n  }\n\n  forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._movesHead; record !== null; record = record._nextMoved) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void) {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\n      fn(record);\n    }\n  }\n\n  diff(collection: NgIterable<V>|null|undefined): DefaultIterableDiffer<V>|null {\n    if (collection == null) collection = [];\n    if (!isListLikeIterable(collection)) {\n      throw new Error(\n          `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);\n    }\n\n    if (this.check(collection)) {\n      return this;\n    } else {\n      return null;\n    }\n  }\n\n  onDestroy() {}\n\n  check(collection: NgIterable<V>): boolean {\n    this._reset();\n\n    let record: IterableChangeRecord_<V>|null = this._itHead;\n    let mayBeDirty: boolean = false;\n    let index: number;\n    let item: V;\n    let itemTrackBy: any;\n    if (Array.isArray(collection)) {\n      (this as {length: number}).length = collection.length;\n\n      for (let index = 0; index < this.length; index++) {\n        item = collection[index];\n        itemTrackBy = this._trackByFn(index, item);\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            // TODO(misko): can we limit this to duplicates only?\n            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n          }\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n        }\n\n        record = record._next;\n      }\n    } else {\n      index = 0;\n      iterateListLike(collection, (item: V) => {\n        itemTrackBy = this._trackByFn(index, item);\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            // TODO(misko): can we limit this to duplicates only?\n            record = this._verifyReinsertion(record, item, itemTrackBy, index);\n          }\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n        }\n        record = record._next;\n        index++;\n      });\n      (this as {length: number}).length = index;\n    }\n\n    this._truncate(record);\n    (this as {collection: V[] | Iterable<V>}).collection = collection;\n    return this.isDirty;\n  }\n\n  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\n   * changes.\n   */\n  get isDirty(): boolean {\n    return this._additionsHead !== null || this._movesHead !== null ||\n        this._removalsHead !== null || this._identityChangesHead !== null;\n  }\n\n  /**\n   * Reset the state of the change objects to show no changes. This means set previousKey to\n   * currentKey, and clear all of the queues (additions, moves, removals).\n   * Set the previousIndexes of moved and added items to their currentIndexes\n   * Reset the list of additions, moves and removals\n   *\n   * @internal\n   */\n  _reset() {\n    if (this.isDirty) {\n      let record: IterableChangeRecord_<V>|null;\n\n      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._additionsHead = this._additionsTail = null;\n\n      for (record = this._movesHead; record !== null; record = record._nextMoved) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._movesHead = this._movesTail = null;\n      this._removalsHead = this._removalsTail = null;\n      this._identityChangesHead = this._identityChangesTail = null;\n\n      // TODO(vicb): when assert gets supported\n      // assert(!this.isDirty);\n    }\n  }\n\n  /**\n   * This is the core function which handles differences between collections.\n   *\n   * - `record` is the record which we saw at this position last time. If null then it is a new\n   *   item.\n   * - `item` is the current item in the collection\n   * - `index` is the position of the item in the collection\n   *\n   * @internal\n   */\n  _mismatch(record: IterableChangeRecord_<V>|null, item: V, itemTrackBy: any, index: number):\n      IterableChangeRecord_<V> {\n    // The previous record after which we will append the current one.\n    let previousRecord: IterableChangeRecord_<V>|null;\n\n    if (record === null) {\n      previousRecord = this._itTail;\n    } else {\n      previousRecord = record._prev;\n      // Remove the record from the collection since we know it does not match the item.\n      this._remove(record);\n    }\n\n    // Attempt to see if we have seen the item before.\n    record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\n    if (record !== null) {\n      // We have seen this before, we need to move it forward in the collection.\n      // But first we need to check if identity changed, so we can update in view if necessary\n      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n\n      this._moveAfter(record, previousRecord, index);\n    } else {\n      // Never seen it, check evicted list.\n      record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n      if (record !== null) {\n        // It is an item which we have evicted earlier: reinsert it back into the list.\n        // But first we need to check if identity changed, so we can update in view if necessary\n        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n\n        this._reinsertAfter(record, previousRecord, index);\n      } else {\n        // It is a new item: add it.\n        record =\n            this._addAfter(new IterableChangeRecord_<V>(item, itemTrackBy), previousRecord, index);\n      }\n    }\n    return record;\n  }\n\n  /**\n   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\n   *\n   * Use case: `[a, a]` => `[b, a, a]`\n   *\n   * If we did not have this check then the insertion of `b` would:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) leave `a` at index `1` as is. <-- this is wrong!\n   *   3) reinsert `a` at index 2. <-- this is wrong!\n   *\n   * The correct behavior is:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) reinsert `a` at index 1.\n   *   3) move `a` at from `1` to `2`.\n   *\n   *\n   * Double check that we have not evicted a duplicate item. We need to check if the item type may\n   * have already been removed:\n   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\n   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\n   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\n   * at the end.\n   *\n   * @internal\n   */\n  _verifyReinsertion(record: IterableChangeRecord_<V>, item: V, itemTrackBy: any, index: number):\n      IterableChangeRecord_<V> {\n    let reinsertRecord: IterableChangeRecord_<V>|null =\n        this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n    if (reinsertRecord !== null) {\n      record = this._reinsertAfter(reinsertRecord, record._prev!, index);\n    } else if (record.currentIndex != index) {\n      record.currentIndex = index;\n      this._addToMoves(record, index);\n    }\n    return record;\n  }\n\n  /**\n   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\n   *\n   * - `record` The first excess {@link IterableChangeRecord_}.\n   *\n   * @internal\n   */\n  _truncate(record: IterableChangeRecord_<V>|null) {\n    // Anything after that needs to be removed;\n    while (record !== null) {\n      const nextRecord: IterableChangeRecord_<V>|null = record._next;\n      this._addToRemovals(this._unlink(record));\n      record = nextRecord;\n    }\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.clear();\n    }\n\n    if (this._additionsTail !== null) {\n      this._additionsTail._nextAdded = null;\n    }\n    if (this._movesTail !== null) {\n      this._movesTail._nextMoved = null;\n    }\n    if (this._itTail !== null) {\n      this._itTail._next = null;\n    }\n    if (this._removalsTail !== null) {\n      this._removalsTail._nextRemoved = null;\n    }\n    if (this._identityChangesTail !== null) {\n      this._identityChangesTail._nextIdentityChange = null;\n    }\n  }\n\n  /** @internal */\n  _reinsertAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.remove(record);\n    }\n    const prev = record._prevRemoved;\n    const next = record._nextRemoved;\n\n    if (prev === null) {\n      this._removalsHead = next;\n    } else {\n      prev._nextRemoved = next;\n    }\n    if (next === null) {\n      this._removalsTail = prev;\n    } else {\n      next._prevRemoved = prev;\n    }\n\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n\n  /** @internal */\n  _moveAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    this._unlink(record);\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n\n  /** @internal */\n  _addAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    this._insertAfter(record, prevRecord, index);\n\n    if (this._additionsTail === null) {\n      // TODO(vicb):\n      // assert(this._additionsHead === null);\n      this._additionsTail = this._additionsHead = record;\n    } else {\n      // TODO(vicb):\n      // assert(_additionsTail._nextAdded === null);\n      // assert(record._nextAdded === null);\n      this._additionsTail = this._additionsTail._nextAdded = record;\n    }\n    return record;\n  }\n\n  /** @internal */\n  _insertAfter(\n      record: IterableChangeRecord_<V>, prevRecord: IterableChangeRecord_<V>|null,\n      index: number): IterableChangeRecord_<V> {\n    // TODO(vicb):\n    // assert(record != prevRecord);\n    // assert(record._next === null);\n    // assert(record._prev === null);\n\n    const next: IterableChangeRecord_<V>|null =\n        prevRecord === null ? this._itHead : prevRecord._next;\n    // TODO(vicb):\n    // assert(next != record);\n    // assert(prevRecord != record);\n    record._next = next;\n    record._prev = prevRecord;\n    if (next === null) {\n      this._itTail = record;\n    } else {\n      next._prev = record;\n    }\n    if (prevRecord === null) {\n      this._itHead = record;\n    } else {\n      prevRecord._next = record;\n    }\n\n    if (this._linkedRecords === null) {\n      this._linkedRecords = new _DuplicateMap<V>();\n    }\n    this._linkedRecords.put(record);\n\n    record.currentIndex = index;\n    return record;\n  }\n\n  /** @internal */\n  _remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    return this._addToRemovals(this._unlink(record));\n  }\n\n  /** @internal */\n  _unlink(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    if (this._linkedRecords !== null) {\n      this._linkedRecords.remove(record);\n    }\n\n    const prev = record._prev;\n    const next = record._next;\n\n    // TODO(vicb):\n    // assert((record._prev = null) === null);\n    // assert((record._next = null) === null);\n\n    if (prev === null) {\n      this._itHead = next;\n    } else {\n      prev._next = next;\n    }\n    if (next === null) {\n      this._itTail = prev;\n    } else {\n      next._prev = prev;\n    }\n\n    return record;\n  }\n\n  /** @internal */\n  _addToMoves(record: IterableChangeRecord_<V>, toIndex: number): IterableChangeRecord_<V> {\n    // TODO(vicb):\n    // assert(record._nextMoved === null);\n\n    if (record.previousIndex === toIndex) {\n      return record;\n    }\n\n    if (this._movesTail === null) {\n      // TODO(vicb):\n      // assert(_movesHead === null);\n      this._movesTail = this._movesHead = record;\n    } else {\n      // TODO(vicb):\n      // assert(_movesTail._nextMoved === null);\n      this._movesTail = this._movesTail._nextMoved = record;\n    }\n\n    return record;\n  }\n\n  private _addToRemovals(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    if (this._unlinkedRecords === null) {\n      this._unlinkedRecords = new _DuplicateMap<V>();\n    }\n    this._unlinkedRecords.put(record);\n    record.currentIndex = null;\n    record._nextRemoved = null;\n\n    if (this._removalsTail === null) {\n      // TODO(vicb):\n      // assert(_removalsHead === null);\n      this._removalsTail = this._removalsHead = record;\n      record._prevRemoved = null;\n    } else {\n      // TODO(vicb):\n      // assert(_removalsTail._nextRemoved === null);\n      // assert(record._nextRemoved === null);\n      record._prevRemoved = this._removalsTail;\n      this._removalsTail = this._removalsTail._nextRemoved = record;\n    }\n    return record;\n  }\n\n  /** @internal */\n  _addIdentityChange(record: IterableChangeRecord_<V>, item: V) {\n    record.item = item;\n    if (this._identityChangesTail === null) {\n      this._identityChangesTail = this._identityChangesHead = record;\n    } else {\n      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\n    }\n    return record;\n  }\n}\n\nexport class IterableChangeRecord_<V> implements IterableChangeRecord<V> {\n  currentIndex: number|null = null;\n  previousIndex: number|null = null;\n\n  /** @internal */\n  _nextPrevious: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prev: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _next: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prevDup: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextDup: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _prevRemoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextRemoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextAdded: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextMoved: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _nextIdentityChange: IterableChangeRecord_<V>|null = null;\n\n\n  constructor(public item: V, public trackById: any) {}\n}\n\n// A linked list of IterableChangeRecords with the same IterableChangeRecord_.item\nclass _DuplicateItemRecordList<V> {\n  /** @internal */\n  _head: IterableChangeRecord_<V>|null = null;\n  /** @internal */\n  _tail: IterableChangeRecord_<V>|null = null;\n\n  /**\n   * Append the record to the list of duplicates.\n   *\n   * Note: by design all records in the list of duplicates hold the same value in record.item.\n   */\n  add(record: IterableChangeRecord_<V>): void {\n    if (this._head === null) {\n      this._head = this._tail = record;\n      record._nextDup = null;\n      record._prevDup = null;\n    } else {\n      // TODO(vicb):\n      // assert(record.item ==  _head.item ||\n      //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\n      this._tail!._nextDup = record;\n      record._prevDup = this._tail;\n      record._nextDup = null;\n      this._tail = record;\n    }\n  }\n\n  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\n  // IterableChangeRecord_.currentIndex >= atOrAfterIndex\n  get(trackById: any, atOrAfterIndex: number|null): IterableChangeRecord_<V>|null {\n    let record: IterableChangeRecord_<V>|null;\n    for (record = this._head; record !== null; record = record._nextDup) {\n      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex!) &&\n          Object.is(record.trackById, trackById)) {\n        return record;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Remove one {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * Returns whether the list of duplicates is empty.\n   */\n  remove(record: IterableChangeRecord_<V>): boolean {\n    // TODO(vicb):\n    // assert(() {\n    //  // verify that the record being removed is in the list.\n    //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {\n    //    if (identical(cursor, record)) return true;\n    //  }\n    //  return false;\n    //});\n\n    const prev: IterableChangeRecord_<V>|null = record._prevDup;\n    const next: IterableChangeRecord_<V>|null = record._nextDup;\n    if (prev === null) {\n      this._head = next;\n    } else {\n      prev._nextDup = next;\n    }\n    if (next === null) {\n      this._tail = prev;\n    } else {\n      next._prevDup = prev;\n    }\n    return this._head === null;\n  }\n}\n\nclass _DuplicateMap<V> {\n  map = new Map<any, _DuplicateItemRecordList<V>>();\n\n  put(record: IterableChangeRecord_<V>) {\n    const key = record.trackById;\n\n    let duplicates = this.map.get(key);\n    if (!duplicates) {\n      duplicates = new _DuplicateItemRecordList<V>();\n      this.map.set(key, duplicates);\n    }\n    duplicates.add(record);\n  }\n\n  /**\n   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\n   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\n   *\n   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\n   * have any more `a`s needs to return the second `a`.\n   */\n  get(trackById: any, atOrAfterIndex: number|null): IterableChangeRecord_<V>|null {\n    const key = trackById;\n    const recordList = this.map.get(key);\n    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\n  }\n\n  /**\n   * Removes a {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * The list of duplicates also is removed from the map if it gets empty.\n   */\n  remove(record: IterableChangeRecord_<V>): IterableChangeRecord_<V> {\n    const key = record.trackById;\n    const recordList: _DuplicateItemRecordList<V> = this.map.get(key)!;\n    // Remove the list of duplicates when it gets empty\n    if (recordList.remove(record)) {\n      this.map.delete(key);\n    }\n    return record;\n  }\n\n  get isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n  clear() {\n    this.map.clear();\n  }\n}\n\nfunction getPreviousIndex(item: any, addRemoveOffset: number, moveOffsets: number[]|null): number {\n  const previousIndex = item.previousIndex;\n  if (previousIndex === null) return previousIndex;\n  let moveOffset = 0;\n  if (moveOffsets && previousIndex < moveOffsets.length) {\n    moveOffset = moveOffsets[previousIndex];\n  }\n  return previousIndex + addRemoveOffset + moveOffset;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {stringify} from '../../util/stringify';\nimport {isJsObject} from '../change_detection_util';\nimport {KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory} from './keyvalue_differs';\n\n\nexport class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {\n  constructor() {}\n  supports(obj: any): boolean {\n    return obj instanceof Map || isJsObject(obj);\n  }\n\n  create<K, V>(): KeyValueDiffer<K, V> {\n    return new DefaultKeyValueDiffer<K, V>();\n  }\n}\n\nexport class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {\n  private _records = new Map<K, KeyValueChangeRecord_<K, V>>();\n  private _mapHead: KeyValueChangeRecord_<K, V>|null = null;\n  // _appendAfter is used in the check loop\n  private _appendAfter: KeyValueChangeRecord_<K, V>|null = null;\n  private _previousMapHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _changesHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _changesTail: KeyValueChangeRecord_<K, V>|null = null;\n  private _additionsHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _additionsTail: KeyValueChangeRecord_<K, V>|null = null;\n  private _removalsHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _removalsTail: KeyValueChangeRecord_<K, V>|null = null;\n\n  get isDirty(): boolean {\n    return this._additionsHead !== null || this._changesHead !== null ||\n        this._removalsHead !== null;\n  }\n\n  forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._mapHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._changesHead; record !== null; record = record._nextChanged) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  diff(map?: Map<any, any>|{[k: string]: any}|null): any {\n    if (!map) {\n      map = new Map();\n    } else if (!(map instanceof Map || isJsObject(map))) {\n      throw new Error(\n          `Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);\n    }\n\n    return this.check(map) ? this : null;\n  }\n\n  onDestroy() {}\n\n  /**\n   * Check the current state of the map vs the previous.\n   * The algorithm is optimised for when the keys do no change.\n   */\n  check(map: Map<any, any>|{[k: string]: any}): boolean {\n    this._reset();\n\n    let insertBefore = this._mapHead;\n    this._appendAfter = null;\n\n    this._forEach(map, (value: any, key: any) => {\n      if (insertBefore && insertBefore.key === key) {\n        this._maybeAddToChanges(insertBefore, value);\n        this._appendAfter = insertBefore;\n        insertBefore = insertBefore._next;\n      } else {\n        const record = this._getOrCreateRecordForKey(key, value);\n        insertBefore = this._insertBeforeOrAppend(insertBefore, record);\n      }\n    });\n\n    // Items remaining at the end of the list have been deleted\n    if (insertBefore) {\n      if (insertBefore._prev) {\n        insertBefore._prev._next = null;\n      }\n\n      this._removalsHead = insertBefore;\n\n      for (let record: KeyValueChangeRecord_<K, V>|null = insertBefore; record !== null;\n           record = record._nextRemoved) {\n        if (record === this._mapHead) {\n          this._mapHead = null;\n        }\n        this._records.delete(record.key);\n        record._nextRemoved = record._next;\n        record.previousValue = record.currentValue;\n        record.currentValue = null;\n        record._prev = null;\n        record._next = null;\n      }\n    }\n\n    // Make sure tails have no next records from previous runs\n    if (this._changesTail) this._changesTail._nextChanged = null;\n    if (this._additionsTail) this._additionsTail._nextAdded = null;\n\n    return this.isDirty;\n  }\n\n  /**\n   * Inserts a record before `before` or append at the end of the list when `before` is null.\n   *\n   * Notes:\n   * - This method appends at `this._appendAfter`,\n   * - This method updates `this._appendAfter`,\n   * - The return value is the new value for the insertion pointer.\n   */\n  private _insertBeforeOrAppend(\n      before: KeyValueChangeRecord_<K, V>|null,\n      record: KeyValueChangeRecord_<K, V>): KeyValueChangeRecord_<K, V>|null {\n    if (before) {\n      const prev = before._prev;\n      record._next = before;\n      record._prev = prev;\n      before._prev = record;\n      if (prev) {\n        prev._next = record;\n      }\n      if (before === this._mapHead) {\n        this._mapHead = record;\n      }\n\n      this._appendAfter = before;\n      return before;\n    }\n\n    if (this._appendAfter) {\n      this._appendAfter._next = record;\n      record._prev = this._appendAfter;\n    } else {\n      this._mapHead = record;\n    }\n\n    this._appendAfter = record;\n    return null;\n  }\n\n  private _getOrCreateRecordForKey(key: K, value: V): KeyValueChangeRecord_<K, V> {\n    if (this._records.has(key)) {\n      const record = this._records.get(key)!;\n      this._maybeAddToChanges(record, value);\n      const prev = record._prev;\n      const next = record._next;\n      if (prev) {\n        prev._next = next;\n      }\n      if (next) {\n        next._prev = prev;\n      }\n      record._next = null;\n      record._prev = null;\n\n      return record;\n    }\n\n    const record = new KeyValueChangeRecord_<K, V>(key);\n    this._records.set(key, record);\n    record.currentValue = value;\n    this._addToAdditions(record);\n    return record;\n  }\n\n  /** @internal */\n  _reset() {\n    if (this.isDirty) {\n      let record: KeyValueChangeRecord_<K, V>|null;\n      // let `_previousMapHead` contain the state of the map before the changes\n      this._previousMapHead = this._mapHead;\n      for (record = this._previousMapHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      // Update `record.previousValue` with the value of the item before the changes\n      // We need to update all changed items (that's those which have been added and changed)\n      for (record = this._changesHead; record !== null; record = record._nextChanged) {\n        record.previousValue = record.currentValue;\n      }\n      for (record = this._additionsHead; record != null; record = record._nextAdded) {\n        record.previousValue = record.currentValue;\n      }\n\n      this._changesHead = this._changesTail = null;\n      this._additionsHead = this._additionsTail = null;\n      this._removalsHead = null;\n    }\n  }\n\n  // Add the record or a given key to the list of changes only when the value has actually changed\n  private _maybeAddToChanges(record: KeyValueChangeRecord_<K, V>, newValue: any): void {\n    if (!Object.is(newValue, record.currentValue)) {\n      record.previousValue = record.currentValue;\n      record.currentValue = newValue;\n      this._addToChanges(record);\n    }\n  }\n\n  private _addToAdditions(record: KeyValueChangeRecord_<K, V>) {\n    if (this._additionsHead === null) {\n      this._additionsHead = this._additionsTail = record;\n    } else {\n      this._additionsTail!._nextAdded = record;\n      this._additionsTail = record;\n    }\n  }\n\n  private _addToChanges(record: KeyValueChangeRecord_<K, V>) {\n    if (this._changesHead === null) {\n      this._changesHead = this._changesTail = record;\n    } else {\n      this._changesTail!._nextChanged = record;\n      this._changesTail = record;\n    }\n  }\n\n  /** @internal */\n  private _forEach<K, V>(obj: Map<K, V>|{[k: string]: V}, fn: (v: V, k: any) => void) {\n    if (obj instanceof Map) {\n      obj.forEach(fn);\n    } else {\n      Object.keys(obj).forEach(k => fn(obj[k], k));\n    }\n  }\n}\n\nclass KeyValueChangeRecord_<K, V> implements KeyValueChangeRecord<K, V> {\n  previousValue: V|null = null;\n  currentValue: V|null = null;\n\n  /** @internal */\n  _nextPrevious: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _next: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _prev: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextAdded: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextRemoved: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextChanged: KeyValueChangeRecord_<K, V>|null = null;\n\n  constructor(public key: K) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵɵdefineInjectable} from '../../di/interface/defs';\nimport {StaticProvider} from '../../di/interface/provider';\nimport {Optional, SkipSelf} from '../../di/metadata';\nimport {DefaultIterableDifferFactory} from '../differs/default_iterable_differ';\n\n\n\n/**\n * A type describing supported iterable types.\n *\n * @publicApi\n */\nexport type NgIterable<T> = Array<T>|Iterable<T>;\n\n/**\n * A strategy for tracking changes over time to an iterable. Used by {@link NgForOf} to\n * respond to changes in an iterable by effecting equivalent changes in the DOM.\n *\n * @publicApi\n */\nexport interface IterableDiffer<V> {\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: NgIterable<V>|undefined|null): IterableChanges<V>|null;\n}\n\n/**\n * An object describing the changes in the `Iterable` collection since last time\n * `IterableDiffer#diff()` was invoked.\n *\n * @publicApi\n */\nexport interface IterableChanges<V> {\n  /**\n   * Iterate over all changes. `IterableChangeRecord` will contain information about changes\n   * to each item.\n   */\n  forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /**\n   * Iterate over a set of operations which when applied to the original `Iterable` will produce the\n   * new `Iterable`.\n   *\n   * NOTE: These are not necessarily the actual operations which were applied to the original\n   * `Iterable`, rather these are a set of computed operations which may not be the same as the\n   * ones applied.\n   *\n   * @param record A change which needs to be applied\n   * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the\n   *        original `Iterable` location, where as `previousIndex` refers to the transient location\n   *        of the item, after applying the operations up to this point.\n   * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the\n   *        original `Iterable` location, where as `currentIndex` refers to the transient location\n   *        of the item, after applying the operations up to this point.\n   */\n  forEachOperation(\n      fn:\n          (record: IterableChangeRecord<V>, previousIndex: number|null,\n           currentIndex: number|null) => void): void;\n\n  /**\n   * Iterate over changes in the order of original `Iterable` showing where the original items\n   * have moved.\n   */\n  forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all added items. */\n  forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all moved items. */\n  forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /** Iterate over all removed items. */\n  forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;\n\n  /**\n   * Iterate over all items which had their identity (as computed by the `TrackByFunction`)\n   * changed.\n   */\n  forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;\n}\n\n/**\n * Record representing the item change information.\n *\n * @publicApi\n */\nexport interface IterableChangeRecord<V> {\n  /** Current index of the item in `Iterable` or null if removed. */\n  readonly currentIndex: number|null;\n\n  /** Previous index of the item in `Iterable` or null if added. */\n  readonly previousIndex: number|null;\n\n  /** The item. */\n  readonly item: V;\n\n  /** Track by identity as computed by the `TrackByFunction`. */\n  readonly trackById: any;\n}\n\n/**\n * An optional function passed into the `NgForOf` directive that defines how to track\n * changes for items in an iterable.\n * The function takes the iteration index and item ID.\n * When supplied, Angular tracks changes by the return value of the function.\n *\n * @publicApi\n */\nexport interface TrackByFunction<T> {\n  (index: number, item: T): any;\n}\n\n/**\n * Provides a factory for {@link IterableDiffer}.\n *\n * @publicApi\n */\nexport interface IterableDifferFactory {\n  supports(objects: any): boolean;\n  create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;\n}\n\nexport function defaultIterableDiffersFactory() {\n  return new IterableDiffers([new DefaultIterableDifferFactory()]);\n}\n\n/**\n * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.\n *\n * @publicApi\n */\nexport class IterableDiffers {\n  /** @nocollapse */\n  static ɵprov = ɵɵdefineInjectable(\n      {token: IterableDiffers, providedIn: 'root', factory: defaultIterableDiffersFactory});\n\n  /**\n   * @deprecated v4.0.0 - Should be private\n   */\n  factories: IterableDifferFactory[];\n  constructor(factories: IterableDifferFactory[]) {\n    this.factories = factories;\n  }\n\n  static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers {\n    if (parent != null) {\n      const copied = parent.factories.slice();\n      factories = factories.concat(copied);\n    }\n\n    return new IterableDiffers(factories);\n  }\n\n  /**\n   * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n   * inherited {@link IterableDiffers} instance with the provided factories and return a new\n   * {@link IterableDiffers} instance.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example shows how to extend an existing list of factories,\n   * which will only be applied to the injector for this component and its children.\n   * This step is all that's required to make a new {@link IterableDiffer} available.\n   *\n   * ```\n   * @Component({\n   *   viewProviders: [\n   *     IterableDiffers.extend([new ImmutableListDiffer()])\n   *   ]\n   * })\n   * ```\n   */\n  static extend(factories: IterableDifferFactory[]): StaticProvider {\n    return {\n      provide: IterableDiffers,\n      useFactory: (parent: IterableDiffers|null) => {\n        // if parent is null, it means that we are in the root injector and we have just overridden\n        // the default injection mechanism for IterableDiffers, in such a case just assume\n        // `defaultIterableDiffersFactory`.\n        return IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[IterableDiffers, new SkipSelf(), new Optional()]]\n    };\n  }\n\n  find(iterable: any): IterableDifferFactory {\n    const factory = this.factories.find(f => f.supports(iterable));\n    if (factory != null) {\n      return factory;\n    } else {\n      throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${\n          getTypeNameForDebugging(iterable)}'`);\n    }\n  }\n}\n\nexport function getTypeNameForDebugging(type: any): string {\n  return type['name'] || typeof type;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Optional, SkipSelf, StaticProvider, ɵɵdefineInjectable} from '../../di';\nimport {DefaultKeyValueDifferFactory} from './default_keyvalue_differ';\n\n\n/**\n * A differ that tracks changes made to an object over time.\n *\n * @publicApi\n */\nexport interface KeyValueDiffer<K, V> {\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: Map<K, V>): KeyValueChanges<K, V>|null;\n\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: {[key: string]: V}): KeyValueChanges<string, V>|null;\n  // TODO(TS2.1): diff<KP extends string>(this: KeyValueDiffer<KP, V>, object: Record<KP, V>):\n  // KeyValueDiffer<KP, V>;\n}\n\n/**\n * An object describing the changes in the `Map` or `{[k:string]: string}` since last time\n * `KeyValueDiffer#diff()` was invoked.\n *\n * @publicApi\n */\nexport interface KeyValueChanges<K, V> {\n  /**\n   * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes\n   * to each item.\n   */\n  forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over changes in the order of original Map showing where the original items\n   * have moved.\n   */\n  forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all keys for which values have changed.\n   */\n  forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all added items.\n   */\n  forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all removed items.\n   */\n  forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n}\n\n/**\n * Record representing the item change information.\n *\n * @publicApi\n */\nexport interface KeyValueChangeRecord<K, V> {\n  /**\n   * Current key in the Map.\n   */\n  readonly key: K;\n\n  /**\n   * Current value for the key or `null` if removed.\n   */\n  readonly currentValue: V|null;\n\n  /**\n   * Previous value for the key or `null` if added.\n   */\n  readonly previousValue: V|null;\n}\n\n/**\n * Provides a factory for {@link KeyValueDiffer}.\n *\n * @publicApi\n */\nexport interface KeyValueDifferFactory {\n  /**\n   * Test to see if the differ knows how to diff this kind of object.\n   */\n  supports(objects: any): boolean;\n\n  /**\n   * Create a `KeyValueDiffer`.\n   */\n  create<K, V>(): KeyValueDiffer<K, V>;\n}\n\nexport function defaultKeyValueDiffersFactory() {\n  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);\n}\n\n/**\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\n *\n * @publicApi\n */\nexport class KeyValueDiffers {\n  /** @nocollapse */\n  static ɵprov = ɵɵdefineInjectable(\n      {token: KeyValueDiffers, providedIn: 'root', factory: defaultKeyValueDiffersFactory});\n\n  /**\n   * @deprecated v4.0.0 - Should be private.\n   */\n  factories: KeyValueDifferFactory[];\n\n  constructor(factories: KeyValueDifferFactory[]) {\n    this.factories = factories;\n  }\n\n  static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers {\n    if (parent) {\n      const copied = parent.factories.slice();\n      factories = factories.concat(copied);\n    }\n    return new KeyValueDiffers(factories);\n  }\n\n  /**\n   * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n   * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n   * {@link KeyValueDiffers} instance.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example shows how to extend an existing list of factories,\n   * which will only be applied to the injector for this component and its children.\n   * This step is all that's required to make a new {@link KeyValueDiffer} available.\n   *\n   * ```\n   * @Component({\n   *   viewProviders: [\n   *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n   *   ]\n   * })\n   * ```\n   */\n  static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider {\n    return {\n      provide: KeyValueDiffers,\n      useFactory: (parent: KeyValueDiffers) => {\n        // if parent is null, it means that we are in the root injector and we have just overridden\n        // the default injection mechanism for KeyValueDiffers, in such a case just assume\n        // `defaultKeyValueDiffersFactory`.\n        return KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]\n    };\n  }\n\n  find(kv: any): KeyValueDifferFactory {\n    const factory = this.factories.find(f => f.supports(kv));\n    if (factory) {\n      return factory;\n    }\n    throw new Error(`Cannot find a differ supporting object '${kv}'`);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from '../util/assert';\n\nimport {icuContainerIterate} from './i18n/i18n_tree_shaking';\nimport {CONTAINER_HEADER_OFFSET} from './interfaces/container';\nimport {TElementNode, TIcuContainerNode, TNode, TNodeType} from './interfaces/node';\nimport {RNode} from './interfaces/renderer_dom';\nimport {isLContainer} from './interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, LView, T_HOST, TVIEW, TView} from './interfaces/view';\nimport {assertTNodeType} from './node_assert';\nimport {getLViewParent} from './util/view_traversal_utils';\nimport {unwrapRNode} from './util/view_utils';\n\n\n\nexport function collectNativeNodes(\n    tView: TView, lView: LView, tNode: TNode|null, result: any[],\n    isProjection: boolean = false): any[] {\n  while (tNode !== null) {\n    ngDevMode &&\n        assertTNodeType(\n            tNode,\n            TNodeType.AnyRNode | TNodeType.AnyContainer | TNodeType.Projection | TNodeType.Icu);\n\n    const lNode = lView[tNode.index];\n    if (lNode !== null) {\n      result.push(unwrapRNode(lNode));\n    }\n\n    // A given lNode can represent either a native node or a LContainer (when it is a host of a\n    // ViewContainerRef). When we find a LContainer we need to descend into it to collect root nodes\n    // from the views in this container.\n    if (isLContainer(lNode)) {\n      for (let i = CONTAINER_HEADER_OFFSET; i < lNode.length; i++) {\n        const lViewInAContainer = lNode[i];\n        const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n        if (lViewFirstChildTNode !== null) {\n          collectNativeNodes(\n              lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n        }\n      }\n    }\n\n    const tNodeType = tNode.type;\n    if (tNodeType & TNodeType.ElementContainer) {\n      collectNativeNodes(tView, lView, tNode.child, result);\n    } else if (tNodeType & TNodeType.Icu) {\n      const nextRNode = icuContainerIterate(tNode as TIcuContainerNode, lView);\n      let rNode: RNode|null;\n      while (rNode = nextRNode()) {\n        result.push(rNode);\n      }\n    } else if (tNodeType & TNodeType.Projection) {\n      const componentView = lView[DECLARATION_COMPONENT_VIEW];\n      const componentHost = componentView[T_HOST] as TElementNode;\n      const slotIdx = tNode.projection as number;\n      ngDevMode &&\n          assertDefined(\n              componentHost.projection,\n              'Components with projection nodes (<ng-content>) must have projection slots defined.');\n\n      const nodesInSlot = componentHost.projection![slotIdx];\n      if (Array.isArray(nodesInSlot)) {\n        result.push(...nodesInSlot);\n      } else {\n        const parentView = getLViewParent(componentView)!;\n        ngDevMode &&\n            assertDefined(\n                parentView,\n                'Component views should always have a parent view (component\\'s host view)');\n        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, InternalViewRef as viewEngine_InternalViewRef, ViewRefTracker} from '../linker/view_ref';\nimport {collectNativeNodes} from './collect_native_nodes';\nimport {checkNoChangesInRootView, checkNoChangesInternal, detectChangesInRootView, detectChangesInternal, markViewDirty, storeCleanupWithContext} from './instructions/shared';\nimport {CONTEXT, FLAGS, LView, LViewFlags, TVIEW} from './interfaces/view';\nimport {destroyLView, renderDetachView} from './node_manipulation';\n\n\n\n// Needed due to tsickle downleveling where multiple `implements` with classes creates\n// multiple @extends in Closure annotations, which is illegal. This workaround fixes\n// the multiple @extends by making the annotation @implements instead\nexport interface viewEngine_ChangeDetectorRef_interface extends viewEngine_ChangeDetectorRef {}\n\nexport class ViewRef<T> implements viewEngine_EmbeddedViewRef<T>, viewEngine_InternalViewRef,\n                                   viewEngine_ChangeDetectorRef_interface {\n  private _appRef: ViewRefTracker|null = null;\n  private _viewContainerRef: viewEngine_ViewContainerRef|null = null;\n\n  get rootNodes(): any[] {\n    const lView = this._lView;\n    const tView = lView[TVIEW];\n    return collectNativeNodes(tView, lView, tView.firstChild, []);\n  }\n\n  constructor(\n      /**\n       * This represents `LView` associated with the component when ViewRef is a ChangeDetectorRef.\n       *\n       * When ViewRef is created for a dynamic component, this also represents the `LView` for the\n       * component.\n       *\n       * For a \"regular\" ViewRef created for an embedded view, this is the `LView` for the embedded\n       * view.\n       *\n       * @internal\n       */\n      public _lView: LView,\n\n      /**\n       * This represents the `LView` associated with the point where `ChangeDetectorRef` was\n       * requested.\n       *\n       * This may be different from `_lView` if the `_cdRefInjectingView` is an embedded view.\n       */\n      private _cdRefInjectingView?: LView) {}\n\n  get context(): T {\n    return this._lView[CONTEXT] as T;\n  }\n\n  get destroyed(): boolean {\n    return (this._lView[FLAGS] & LViewFlags.Destroyed) === LViewFlags.Destroyed;\n  }\n\n  destroy(): void {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._viewContainerRef) {\n      const index = this._viewContainerRef.indexOf(this);\n\n      if (index > -1) {\n        this._viewContainerRef.detach(index);\n      }\n\n      this._viewContainerRef = null;\n    }\n    destroyLView(this._lView[TVIEW], this._lView);\n  }\n\n  onDestroy(callback: Function) {\n    storeCleanupWithContext(this._lView[TVIEW], this._lView, null, callback);\n  }\n\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * It also triggers change detection by calling `scheduleTick` internally, which coalesces\n   * multiple `markForCheck` calls to into one change detection run.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Component({\n   *   selector: 'my-app',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck(): void {\n    markViewDirty(this._cdRefInjectingView || this._lView);\n  }\n\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach(): void {\n    this._lView[FLAGS] &= ~LViewFlags.Attached;\n  }\n\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```typescript\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'my-app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach(): void {\n    this._lView[FLAGS] |= LViewFlags.Attached;\n  }\n\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach detach} for more information.\n   */\n  detectChanges(): void {\n    detectChangesInternal(this._lView[TVIEW], this._lView, this.context);\n  }\n\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges(): void {\n    checkNoChangesInternal(this._lView[TVIEW], this._lView, this.context);\n  }\n\n  attachToViewContainerRef(vcRef: viewEngine_ViewContainerRef) {\n    if (this._appRef) {\n      throw new Error('This view is already attached directly to the ApplicationRef!');\n    }\n    this._viewContainerRef = vcRef;\n  }\n\n  detachFromAppRef() {\n    this._appRef = null;\n    renderDetachView(this._lView[TVIEW], this._lView);\n  }\n\n  attachToAppRef(appRef: ViewRefTracker) {\n    if (this._viewContainerRef) {\n      throw new Error('This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n}\n\n/** @internal */\nexport class RootViewRef<T> extends ViewRef<T> {\n  constructor(public _view: LView) {\n    super(_view);\n  }\n\n  detectChanges(): void {\n    detectChangesInRootView(this._view);\n  }\n\n  checkNoChanges(): void {\n    checkNoChangesInRootView(this._view);\n  }\n\n  get context(): T {\n    return null!;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DefaultIterableDifferFactory} from './differs/default_iterable_differ';\nimport {DefaultKeyValueDifferFactory} from './differs/default_keyvalue_differ';\nimport {IterableDifferFactory, IterableDiffers} from './differs/iterable_differs';\nimport {KeyValueDifferFactory, KeyValueDiffers} from './differs/keyvalue_differs';\n\nexport {SimpleChange, SimpleChanges} from '../interface/simple_change';\nexport {devModeEqual, WrappedValue} from './change_detection_util';\nexport {ChangeDetectorRef} from './change_detector_ref';\nexport {ChangeDetectionStrategy, ChangeDetectorStatus, isDefaultChangeDetectionStrategy} from './constants';\nexport {DefaultIterableDifferFactory} from './differs/default_iterable_differ';\nexport {DefaultIterableDiffer} from './differs/default_iterable_differ';\nexport {DefaultKeyValueDifferFactory} from './differs/default_keyvalue_differ';\nexport {IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, NgIterable, TrackByFunction} from './differs/iterable_differs';\nexport {KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers} from './differs/keyvalue_differs';\nexport {PipeTransform} from './pipe_transform';\n\n\n\n/**\n * Structural diffing for `Object`s and `Map`s.\n */\nconst keyValDiff: KeyValueDifferFactory[] = [new DefaultKeyValueDifferFactory()];\n\n/**\n * Structural diffing for `Iterable` types such as `Array`s.\n */\nconst iterableDiff: IterableDifferFactory[] = [new DefaultIterableDifferFactory()];\n\nexport const defaultIterableDiffers = new IterableDiffers(iterableDiff);\n\nexport const defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertLContainer} from '../render3/assert';\nimport {createLView, renderView} from '../render3/instructions/shared';\nimport {TContainerNode, TNode, TNodeType} from '../render3/interfaces/node';\nimport {DECLARATION_LCONTAINER, LView, LViewFlags, QUERIES, TView} from '../render3/interfaces/view';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {ViewRef as R3_ViewRef} from '../render3/view_ref';\nimport {assertDefined} from '../util/assert';\nimport {noop} from '../util/noop';\nimport {createElementRef, ElementRef} from './element_ref';\nimport {EmbeddedViewRef} from './view_ref';\n\n\n\nexport const SWITCH_TEMPLATE_REF_FACTORY__POST_R3__ = injectTemplateRef;\nconst SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__ = noop;\nconst SWITCH_TEMPLATE_REF_FACTORY: typeof injectTemplateRef = SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__;\n\n/**\n * Represents an embedded template that can be used to instantiate embedded views.\n * To instantiate embedded views based on a template, use the `ViewContainerRef`\n * method `createEmbeddedView()`.\n *\n * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`\n * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view\n * is injected into the constructor of the directive,\n * using the `TemplateRef` token.\n *\n * You can also use a `Query` to find a `TemplateRef` associated with\n * a component or a directive.\n *\n * @see `ViewContainerRef`\n * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)\n *\n * @publicApi\n */\nexport abstract class TemplateRef<C> {\n  /**\n   * The anchor element in the parent view for this embedded view.\n   *\n   * The data-binding and injection contexts of embedded views created from this `TemplateRef`\n   * inherit from the contexts of this location.\n   *\n   * Typically new embedded views are attached to the view container of this location, but in\n   * advanced use-cases, the view can be attached to a different container while keeping the\n   * data-binding and injection context from the original location.\n   *\n   */\n  // TODO(i): rename to anchor or location\n  abstract get elementRef(): ElementRef;\n\n  /**\n   * Instantiates an embedded view based on this template,\n   * and attaches it to the view container.\n   * @param context The data-binding context of the embedded view, as declared\n   * in the `<ng-template>` usage.\n   * @returns The new embedded view object.\n   */\n  abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => TemplateRef<any>| null = SWITCH_TEMPLATE_REF_FACTORY;\n}\n\nconst ViewEngineTemplateRef = TemplateRef;\n\nconst R3TemplateRef = class TemplateRef<T> extends ViewEngineTemplateRef<T> {\n  constructor(\n      private _declarationLView: LView, private _declarationTContainer: TContainerNode,\n      public elementRef: ElementRef) {\n    super();\n  }\n\n  createEmbeddedView(context: T): EmbeddedViewRef<T> {\n    const embeddedTView = this._declarationTContainer.tViews as TView;\n    const embeddedLView = createLView(\n        this._declarationLView, embeddedTView, context, LViewFlags.CheckAlways, null,\n        embeddedTView.declTNode, null, null, null, null);\n\n    const declarationLContainer = this._declarationLView[this._declarationTContainer.index];\n    ngDevMode && assertLContainer(declarationLContainer);\n    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n\n    const declarationViewLQueries = this._declarationLView[QUERIES];\n    if (declarationViewLQueries !== null) {\n      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n    }\n\n    renderView(embeddedTView, embeddedLView, context);\n\n    return new R3_ViewRef<T>(embeddedLView);\n  }\n};\n\n/**\n * Creates a TemplateRef given a node.\n *\n * @returns The TemplateRef instance to use\n */\nexport function injectTemplateRef<T>(): TemplateRef<T>|null {\n  return createTemplateRef<T>(getCurrentTNode()!, getLView());\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector.\n *\n * @param hostTNode The node on which a TemplateRef is requested\n * @param hostLView The `LView` to which the node belongs\n * @returns The TemplateRef instance or null if we can't create a TemplateRef on a given node type\n */\nexport function createTemplateRef<T>(hostTNode: TNode, hostLView: LView): TemplateRef<T>|null {\n  if (hostTNode.type & TNodeType.Container) {\n    ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n    return new R3TemplateRef(\n        hostLView, hostTNode as TContainerNode, createElementRef(hostTNode, hostLView));\n  }\n  return null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {Type} from '../interface/type';\n\nimport {ComponentFactoryResolver} from './component_factory_resolver';\n\n\n/**\n * Represents an instance of an `NgModule` created by an `NgModuleFactory`.\n * Provides access to the `NgModule` instance and related objects.\n *\n * @publicApi\n */\nexport abstract class NgModuleRef<T> {\n  /**\n   * The injector that contains all of the providers of the `NgModule`.\n   */\n  abstract get injector(): Injector;\n\n  /**\n   * The resolver that can retrieve the component factories\n   * declared in the `entryComponents` property of the module.\n   */\n  abstract get componentFactoryResolver(): ComponentFactoryResolver;\n\n  /**\n   * The `NgModule` instance.\n   */\n  abstract get instance(): T;\n\n  /**\n   * Destroys the module instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Registers a callback to be executed when the module is destroyed.\n   */\n  abstract onDestroy(callback: () => void): void;\n}\n\nexport interface InternalNgModuleRef<T> extends NgModuleRef<T> {\n  // Note: we are using the prefix _ as NgModuleData is an NgModuleRef and therefore directly\n  // exposed to the user.\n  _bootstrapComponents: Type<any>[];\n}\n\n/**\n * @publicApi\n */\nexport abstract class NgModuleFactory<T> {\n  abstract get moduleType(): Type<T>;\n  abstract create(parentInjector: Injector|null): NgModuleRef<T>;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {assertNodeInjector} from '../render3/assert';\nimport {getParentInjectorLocation, NodeInjector} from '../render3/di';\nimport {addToViewTree, createLContainer} from '../render3/instructions/shared';\nimport {CONTAINER_HEADER_OFFSET, LContainer, NATIVE, VIEW_REFS} from '../render3/interfaces/container';\nimport {NodeInjectorOffset} from '../render3/interfaces/injector';\nimport {TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNodeType} from '../render3/interfaces/node';\nimport {RComment, RElement} from '../render3/interfaces/renderer_dom';\nimport {isLContainer} from '../render3/interfaces/type_checks';\nimport {LView, PARENT, RENDERER, T_HOST, TVIEW} from '../render3/interfaces/view';\nimport {assertTNodeType} from '../render3/node_assert';\nimport {addViewToContainer, destroyLView, detachView, getBeforeNodeForView, insertView, nativeInsertBefore, nativeNextSibling, nativeParentNode} from '../render3/node_manipulation';\nimport {getCurrentTNode, getLView} from '../render3/state';\nimport {getParentInjectorIndex, getParentInjectorView, hasParentInjector} from '../render3/util/injector_utils';\nimport {getNativeByTNode, unwrapRNode, viewAttachedToContainer} from '../render3/util/view_utils';\nimport {ViewRef as R3ViewRef} from '../render3/view_ref';\nimport {addToArray, removeFromArray} from '../util/array_utils';\nimport {assertEqual, assertGreaterThan, assertLessThan} from '../util/assert';\nimport {noop} from '../util/noop';\nimport {ComponentFactory, ComponentRef} from './component_factory';\nimport {createElementRef, ElementRef} from './element_ref';\nimport {NgModuleRef} from './ng_module_factory';\nimport {TemplateRef} from './template_ref';\nimport {EmbeddedViewRef, ViewRef} from './view_ref';\n\n\nexport const SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__ = injectViewContainerRef;\nconst SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__ = noop as typeof injectViewContainerRef;\nconst SWITCH_VIEW_CONTAINER_REF_FACTORY: typeof injectViewContainerRef =\n    SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__;\n\n/**\n * Represents a container where one or more views can be attached to a component.\n *\n * Can contain *host views* (created by instantiating a\n * component with the `createComponent()` method), and *embedded views*\n * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).\n *\n * A view container instance can contain other view containers,\n * creating a [view hierarchy](guide/glossary#view-tree).\n *\n * @see `ComponentRef`\n * @see `EmbeddedViewRef`\n *\n * @publicApi\n */\nexport abstract class ViewContainerRef {\n  /**\n   * Anchor element that specifies the location of this container in the containing view.\n   * Each view container can have only one anchor element, and each anchor element\n   * can have only a single view container.\n   *\n   * Root elements of views attached to this container become siblings of the anchor element in\n   * the rendered view.\n   *\n   * Access the `ViewContainerRef` of an element by placing a `Directive` injected\n   * with `ViewContainerRef` on the element, or use a `ViewChild` query.\n   *\n   * <!-- TODO: rename to anchorElement -->\n   */\n  abstract get element(): ElementRef;\n\n  /**\n   * The [dependency injector](guide/glossary#injector) for this view container.\n   */\n  abstract get injector(): Injector;\n\n  /** @deprecated No replacement */\n  abstract get parentInjector(): Injector;\n\n  /**\n   * Destroys all views in this container.\n   */\n  abstract clear(): void;\n\n  /**\n   * Retrieves a view from this container.\n   * @param index The 0-based index of the view to retrieve.\n   * @returns The `ViewRef` instance, or null if the index is out of range.\n   */\n  abstract get(index: number): ViewRef|null;\n\n  /**\n   * Reports how many views are currently attached to this container.\n   * @returns The number of views.\n   */\n  abstract get length(): number;\n\n  /**\n   * Instantiates an embedded view and inserts it\n   * into this container.\n   * @param templateRef The HTML template that defines the view.\n   * @param index The 0-based index at which to insert the new view into this container.\n   * If not specified, appends the new view as the last entry.\n   *\n   * @returns The `ViewRef` instance for the newly created view.\n   */\n  abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number):\n      EmbeddedViewRef<C>;\n\n  /**\n   * Instantiates a single component and inserts its host view into this container.\n   *\n   * @param componentFactory The factory to use.\n   * @param index The index at which to insert the new component's host view into this container.\n   * If not specified, appends the new view as the last entry.\n   * @param injector The injector to use as the parent for the new component.\n   * @param projectableNodes\n   * @param ngModule\n   *\n   * @returns The new component instance, containing the host view.\n   *\n   */\n  abstract createComponent<C>(\n      componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n      projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>;\n\n  /**\n   * Inserts a view into this container.\n   * @param viewRef The view to insert.\n   * @param index The 0-based index at which to insert the view.\n   * If not specified, appends the new view as the last entry.\n   * @returns The inserted `ViewRef` instance.\n   *\n   */\n  abstract insert(viewRef: ViewRef, index?: number): ViewRef;\n\n  /**\n   * Moves a view to a new location in this container.\n   * @param viewRef The view to move.\n   * @param index The 0-based index of the new location.\n   * @returns The moved `ViewRef` instance.\n   */\n  abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;\n\n  /**\n   * Returns the index of a view within the current container.\n   * @param viewRef The view to query.\n   * @returns The 0-based index of the view's position in this container,\n   * or `-1` if this container doesn't contain the view.\n   */\n  abstract indexOf(viewRef: ViewRef): number;\n\n  /**\n   * Destroys a view attached to this container\n   * @param index The 0-based index of the view to destroy.\n   * If not specified, the last view in the container is removed.\n   */\n  abstract remove(index?: number): void;\n\n  /**\n   * Detaches a view from this container without destroying it.\n   * Use along with `insert()` to move a view within the current container.\n   * @param index The 0-based index of the view to detach.\n   * If not specified, the last view in the container is detached.\n   */\n  abstract detach(index?: number): ViewRef|null;\n\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__: () => ViewContainerRef = SWITCH_VIEW_CONTAINER_REF_FACTORY;\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function injectViewContainerRef(): ViewContainerRef {\n  const previousTNode = getCurrentTNode() as TElementNode | TElementContainerNode | TContainerNode;\n  return createContainerRef(previousTNode, getLView());\n}\n\nconst VE_ViewContainerRef = ViewContainerRef;\n\nconst R3ViewContainerRef = class ViewContainerRef extends VE_ViewContainerRef {\n  constructor(\n      private _lContainer: LContainer,\n      private _hostTNode: TElementNode|TContainerNode|TElementContainerNode,\n      private _hostLView: LView) {\n    super();\n  }\n\n  get element(): ElementRef {\n    return createElementRef(this._hostTNode, this._hostLView);\n  }\n\n  get injector(): Injector {\n    return new NodeInjector(this._hostTNode, this._hostLView);\n  }\n\n  /** @deprecated No replacement */\n  get parentInjector(): Injector {\n    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);\n    if (hasParentInjector(parentLocation)) {\n      const parentView = getParentInjectorView(parentLocation, this._hostLView);\n      const injectorIndex = getParentInjectorIndex(parentLocation);\n      ngDevMode && assertNodeInjector(parentView, injectorIndex);\n      const parentTNode =\n          parentView[TVIEW].data[injectorIndex + NodeInjectorOffset.TNODE] as TElementNode;\n      return new NodeInjector(parentTNode, parentView);\n    } else {\n      return new NodeInjector(null, this._hostLView);\n    }\n  }\n\n  clear(): void {\n    while (this.length > 0) {\n      this.remove(this.length - 1);\n    }\n  }\n\n  get(index: number): ViewRef|null {\n    const viewRefs = getViewRefs(this._lContainer);\n    return viewRefs !== null && viewRefs[index] || null;\n  }\n\n  get length(): number {\n    return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n\n  createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number):\n      EmbeddedViewRef<C> {\n    const viewRef = templateRef.createEmbeddedView(context || <any>{});\n    this.insert(viewRef, index);\n    return viewRef;\n  }\n\n  createComponent<C>(\n      componentFactory: ComponentFactory<C>, index?: number|undefined,\n      injector?: Injector|undefined, projectableNodes?: any[][]|undefined,\n      ngModuleRef?: NgModuleRef<any>|undefined): ComponentRef<C> {\n    const contextInjector = injector || this.parentInjector;\n    if (!ngModuleRef && (componentFactory as any).ngModule == null && contextInjector) {\n      // DO NOT REFACTOR. The code here used to have a `value || undefined` expression\n      // which seems to cause internal google apps to fail. This is documented in the\n      // following internal bug issue: go/b/142967802\n      const result = contextInjector.get(NgModuleRef, null);\n      if (result) {\n        ngModuleRef = result;\n      }\n    }\n\n    const componentRef =\n        componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\n    this.insert(componentRef.hostView, index);\n    return componentRef;\n  }\n\n  insert(viewRef: ViewRef, index?: number): ViewRef {\n    const lView = (viewRef as R3ViewRef<any>)._lView!;\n    const tView = lView[TVIEW];\n\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n    }\n\n    if (viewAttachedToContainer(lView)) {\n      // If view is already attached, detach it first so we clean up references appropriately.\n\n      const prevIdx = this.indexOf(viewRef);\n\n      // A view might be attached either to this or a different container. The `prevIdx` for\n      // those cases will be:\n      // equal to -1 for views attached to this ViewContainerRef\n      // >= 0 for views attached to a different ViewContainerRef\n      if (prevIdx !== -1) {\n        this.detach(prevIdx);\n      } else {\n        const prevLContainer = lView[PARENT] as LContainer;\n        ngDevMode &&\n            assertEqual(\n                isLContainer(prevLContainer), true,\n                'An attached view should have its PARENT point to a container.');\n\n\n        // We need to re-create a R3ViewContainerRef instance since those are not stored on\n        // LView (nor anywhere else).\n        const prevVCRef = new R3ViewContainerRef(\n            prevLContainer, prevLContainer[T_HOST] as TDirectiveHostNode, prevLContainer[PARENT]);\n\n        prevVCRef.detach(prevVCRef.indexOf(viewRef));\n      }\n    }\n\n    // Logical operation of adding `LView` to `LContainer`\n    const adjustedIdx = this._adjustIndex(index);\n    const lContainer = this._lContainer;\n    insertView(tView, lView, lContainer, adjustedIdx);\n\n    // Physical operation of adding the DOM nodes.\n    const beforeNode = getBeforeNodeForView(adjustedIdx, lContainer);\n    const renderer = lView[RENDERER];\n    const parentRNode = nativeParentNode(renderer, lContainer[NATIVE] as RElement | RComment);\n    if (parentRNode !== null) {\n      addViewToContainer(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);\n    }\n\n    (viewRef as R3ViewRef<any>).attachToViewContainerRef(this);\n    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);\n\n    return viewRef;\n  }\n\n  move(viewRef: ViewRef, newIndex: number): ViewRef {\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error('Cannot move a destroyed View in a ViewContainer!');\n    }\n    return this.insert(viewRef, newIndex);\n  }\n\n  indexOf(viewRef: ViewRef): number {\n    const viewRefsArr = getViewRefs(this._lContainer);\n    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n  }\n\n  remove(index?: number): void {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const detachedView = detachView(this._lContainer, adjustedIdx);\n\n    if (detachedView) {\n      // Before destroying the view, remove it from the container's array of `ViewRef`s.\n      // This ensures the view container length is updated before calling\n      // `destroyLView`, which could recursively call view container methods that\n      // rely on an accurate container length.\n      // (e.g. a method on this view container being called by a child directive's OnDestroy\n      // lifecycle hook)\n      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);\n      destroyLView(detachedView[TVIEW], detachedView);\n    }\n  }\n\n  detach(index?: number): ViewRef|null {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const view = detachView(this._lContainer, adjustedIdx);\n\n    const wasDetached =\n        view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;\n    return wasDetached ? new R3ViewRef(view!) : null;\n  }\n\n  private _adjustIndex(index?: number, shift: number = 0) {\n    if (index == null) {\n      return this.length + shift;\n    }\n    if (ngDevMode) {\n      assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);\n      // +1 because it's legal to insert at the end.\n      assertLessThan(index, this.length + 1 + shift, 'index');\n    }\n    return index;\n  }\n};\n\nfunction getViewRefs(lContainer: LContainer): ViewRef[]|null {\n  return lContainer[VIEW_REFS] as ViewRef[];\n}\n\nfunction getOrCreateViewRefs(lContainer: LContainer): ViewRef[] {\n  return (lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = [])) as ViewRef[];\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector.\n *\n * @param ViewContainerRefToken The ViewContainerRef type\n * @param ElementRefToken The ElementRef type\n * @param hostTNode The node that is requesting a ViewContainerRef\n * @param hostLView The view to which the node belongs\n * @returns The ViewContainerRef instance to use\n */\nexport function createContainerRef(\n    hostTNode: TElementNode|TContainerNode|TElementContainerNode,\n    hostLView: LView): ViewContainerRef {\n  ngDevMode && assertTNodeType(hostTNode, TNodeType.AnyContainer | TNodeType.AnyRNode);\n\n  let lContainer: LContainer;\n  const slotValue = hostLView[hostTNode.index];\n  if (isLContainer(slotValue)) {\n    // If the host is a container, we don't need to create a new LContainer\n    lContainer = slotValue;\n  } else {\n    let commentNode: RComment;\n    // If the host is an element container, the native host element is guaranteed to be a\n    // comment and we can reuse that comment as anchor element for the new LContainer.\n    // The comment node in question is already part of the DOM structure so we don't need to append\n    // it again.\n    if (hostTNode.type & TNodeType.ElementContainer) {\n      commentNode = unwrapRNode(slotValue) as RComment;\n    } else {\n      // If the host is a regular element, we have to insert a comment node manually which will\n      // be used as an anchor when inserting elements. In this specific case we use low-level DOM\n      // manipulation to insert it.\n      const renderer = hostLView[RENDERER];\n      ngDevMode && ngDevMode.rendererCreateComment++;\n      commentNode = renderer.createComment(ngDevMode ? 'container' : '');\n\n      const hostNative = getNativeByTNode(hostTNode, hostLView)!;\n      const parentOfHostNative = nativeParentNode(renderer, hostNative);\n      nativeInsertBefore(\n          renderer, parentOfHostNative!, commentNode, nativeNextSibling(renderer, hostNative),\n          false);\n    }\n\n    hostLView[hostTNode.index] = lContainer =\n        createLContainer(slotValue, hostLView, commentNode, hostTNode);\n\n    addToViewTree(hostLView, lContainer);\n  }\n\n  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef, SimpleChange, SimpleChanges, WrappedValue} from '../change_detection/change_detection';\nimport {INJECTOR, Injector, resolveForwardRef} from '../di';\nimport {ElementRef} from '../linker/element_ref';\nimport {TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef} from '../linker/view_container_ref';\nimport {Renderer2} from '../render/api';\nimport {isObservable} from '../util/lang';\nimport {stringify} from '../util/stringify';\n\nimport {createChangeDetectorRef, createInjector} from './refs';\nimport {asElementData, asProviderData, BindingDef, BindingFlags, DepDef, DepFlags, NodeDef, NodeFlags, OutputDef, OutputType, ProviderData, QueryValueType, Services, shouldCallLifecycleInitHook, ViewData, ViewFlags, ViewState} from './types';\nimport {calcBindingFlags, checkBinding, dispatchEvent, isComponentView, splitDepsDsl, splitMatchedQueriesDsl, tokenKey, viewParentEl} from './util';\n\nconst Renderer2TokenKey = tokenKey(Renderer2);\nconst ElementRefTokenKey = tokenKey(ElementRef);\nconst ViewContainerRefTokenKey = tokenKey(ViewContainerRef);\nconst TemplateRefTokenKey = tokenKey(TemplateRef);\nconst ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);\nconst InjectorRefTokenKey = tokenKey(Injector);\nconst INJECTORRefTokenKey = tokenKey(INJECTOR);\n\nexport function directiveDef(\n    checkIndex: number, flags: NodeFlags, matchedQueries: null|[string | number, QueryValueType][],\n    childCount: number, ctor: any, deps: ([DepFlags, any]|any)[],\n    props?: null|{[name: string]: [number, string]},\n    outputs?: null|{[name: string]: string}): NodeDef {\n  const bindings: BindingDef[] = [];\n  if (props) {\n    for (let prop in props) {\n      const [bindingIndex, nonMinifiedName] = props[prop];\n      bindings[bindingIndex] = {\n        flags: BindingFlags.TypeProperty,\n        name: prop,\n        nonMinifiedName,\n        ns: null,\n        securityContext: null,\n        suffix: null\n      };\n    }\n  }\n  const outputDefs: OutputDef[] = [];\n  if (outputs) {\n    for (let propName in outputs) {\n      outputDefs.push(\n          {type: OutputType.DirectiveOutput, propName, target: null, eventName: outputs[propName]});\n    }\n  }\n  flags |= NodeFlags.TypeDirective;\n  return _def(\n      checkIndex, flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);\n}\n\nexport function pipeDef(flags: NodeFlags, ctor: any, deps: ([DepFlags, any]|any)[]): NodeDef {\n  flags |= NodeFlags.TypePipe;\n  return _def(-1, flags, null, 0, ctor, ctor, deps);\n}\n\nexport function providerDef(\n    flags: NodeFlags, matchedQueries: null|[string | number, QueryValueType][], token: any,\n    value: any, deps: ([DepFlags, any]|any)[]): NodeDef {\n  return _def(-1, flags, matchedQueries, 0, token, value, deps);\n}\n\nexport function _def(\n    checkIndex: number, flags: NodeFlags, matchedQueriesDsl: [string|number, QueryValueType][]|null,\n    childCount: number, token: any, value: any, deps: ([DepFlags, any]|any)[],\n    bindings?: BindingDef[], outputs?: OutputDef[]): NodeDef {\n  const {matchedQueries, references, matchedQueryIds} = splitMatchedQueriesDsl(matchedQueriesDsl);\n  if (!outputs) {\n    outputs = [];\n  }\n  if (!bindings) {\n    bindings = [];\n  }\n  // Need to resolve forwardRefs as e.g. for `useValue` we\n  // lowered the expression and then stopped evaluating it,\n  // i.e. also didn't unwrap it.\n  value = resolveForwardRef(value);\n\n  const depDefs = splitDepsDsl(deps, stringify(token));\n\n  return {\n    // will bet set by the view definition\n    nodeIndex: -1,\n    parent: null,\n    renderParent: null,\n    bindingIndex: -1,\n    outputIndex: -1,\n    // regular values\n    checkIndex,\n    flags,\n    childFlags: 0,\n    directChildFlags: 0,\n    childMatchedQueries: 0,\n    matchedQueries,\n    matchedQueryIds,\n    references,\n    ngContentIndex: -1,\n    childCount,\n    bindings,\n    bindingFlags: calcBindingFlags(bindings),\n    outputs,\n    element: null,\n    provider: {token, value, deps: depDefs},\n    text: null,\n    query: null,\n    ngContent: null\n  };\n}\n\nexport function createProviderInstance(view: ViewData, def: NodeDef): any {\n  return _createProviderInstance(view, def);\n}\n\nexport function createPipeInstance(view: ViewData, def: NodeDef): any {\n  // deps are looked up from component.\n  let compView = view;\n  while (compView.parent && !isComponentView(compView)) {\n    compView = compView.parent;\n  }\n  // pipes can see the private services of the component\n  const allowPrivateServices = true;\n  // pipes are always eager and classes!\n  return createClass(\n      compView.parent!, viewParentEl(compView)!, allowPrivateServices, def.provider!.value,\n      def.provider!.deps);\n}\n\nexport function createDirectiveInstance(view: ViewData, def: NodeDef): any {\n  // components can see other private services, other directives can't.\n  const allowPrivateServices = (def.flags & NodeFlags.Component) > 0;\n  // directives are always eager and classes!\n  const instance =\n      createClass(view, def.parent!, allowPrivateServices, def.provider!.value, def.provider!.deps);\n  if (def.outputs.length) {\n    for (let i = 0; i < def.outputs.length; i++) {\n      const output = def.outputs[i];\n      const outputObservable = instance[output.propName!];\n      if (isObservable(outputObservable)) {\n        const subscription = outputObservable.subscribe(\n            eventHandlerClosure(view, def.parent!.nodeIndex, output.eventName));\n        view.disposables![def.outputIndex + i] = subscription.unsubscribe.bind(subscription);\n      } else {\n        throw new Error(\n            `@Output ${output.propName} not initialized in '${instance.constructor.name}'.`);\n      }\n    }\n  }\n  return instance;\n}\n\nfunction eventHandlerClosure(view: ViewData, index: number, eventName: string) {\n  return (event: any) => dispatchEvent(view, index, eventName, event);\n}\n\nexport function checkAndUpdateDirectiveInline(\n    view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any,\n    v7: any, v8: any, v9: any): boolean {\n  const providerData = asProviderData(view, def.nodeIndex);\n  const directive = providerData.instance;\n  let changed = false;\n  let changes: SimpleChanges = undefined!;\n  const bindLen = def.bindings.length;\n  if (bindLen > 0 && checkBinding(view, def, 0, v0)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 0, v0, changes);\n  }\n  if (bindLen > 1 && checkBinding(view, def, 1, v1)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 1, v1, changes);\n  }\n  if (bindLen > 2 && checkBinding(view, def, 2, v2)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 2, v2, changes);\n  }\n  if (bindLen > 3 && checkBinding(view, def, 3, v3)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 3, v3, changes);\n  }\n  if (bindLen > 4 && checkBinding(view, def, 4, v4)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 4, v4, changes);\n  }\n  if (bindLen > 5 && checkBinding(view, def, 5, v5)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 5, v5, changes);\n  }\n  if (bindLen > 6 && checkBinding(view, def, 6, v6)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 6, v6, changes);\n  }\n  if (bindLen > 7 && checkBinding(view, def, 7, v7)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 7, v7, changes);\n  }\n  if (bindLen > 8 && checkBinding(view, def, 8, v8)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 8, v8, changes);\n  }\n  if (bindLen > 9 && checkBinding(view, def, 9, v9)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 9, v9, changes);\n  }\n  if (changes) {\n    directive.ngOnChanges(changes);\n  }\n  if ((def.flags & NodeFlags.OnInit) &&\n      shouldCallLifecycleInitHook(view, ViewState.InitState_CallingOnInit, def.nodeIndex)) {\n    directive.ngOnInit();\n  }\n  if (def.flags & NodeFlags.DoCheck) {\n    directive.ngDoCheck();\n  }\n  return changed;\n}\n\nexport function checkAndUpdateDirectiveDynamic(\n    view: ViewData, def: NodeDef, values: any[]): boolean {\n  const providerData = asProviderData(view, def.nodeIndex);\n  const directive = providerData.instance;\n  let changed = false;\n  let changes: SimpleChanges = undefined!;\n  for (let i = 0; i < values.length; i++) {\n    if (checkBinding(view, def, i, values[i])) {\n      changed = true;\n      changes = updateProp(view, providerData, def, i, values[i], changes);\n    }\n  }\n  if (changes) {\n    directive.ngOnChanges(changes);\n  }\n  if ((def.flags & NodeFlags.OnInit) &&\n      shouldCallLifecycleInitHook(view, ViewState.InitState_CallingOnInit, def.nodeIndex)) {\n    directive.ngOnInit();\n  }\n  if (def.flags & NodeFlags.DoCheck) {\n    directive.ngDoCheck();\n  }\n  return changed;\n}\n\nfunction _createProviderInstance(view: ViewData, def: NodeDef): any {\n  // private services can see other private services\n  const allowPrivateServices = (def.flags & NodeFlags.PrivateProvider) > 0;\n  const providerDef = def.provider;\n  switch (def.flags & NodeFlags.Types) {\n    case NodeFlags.TypeClassProvider:\n      return createClass(\n          view, def.parent!, allowPrivateServices, providerDef!.value, providerDef!.deps);\n    case NodeFlags.TypeFactoryProvider:\n      return callFactory(\n          view, def.parent!, allowPrivateServices, providerDef!.value, providerDef!.deps);\n    case NodeFlags.TypeUseExistingProvider:\n      return resolveDep(view, def.parent!, allowPrivateServices, providerDef!.deps[0]);\n    case NodeFlags.TypeValueProvider:\n      return providerDef!.value;\n  }\n}\n\nfunction createClass(\n    view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, ctor: any, deps: DepDef[]): any {\n  const len = deps.length;\n  switch (len) {\n    case 0:\n      return new ctor();\n    case 1:\n      return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));\n    case 2:\n      return new ctor(\n          resolveDep(view, elDef, allowPrivateServices, deps[0]),\n          resolveDep(view, elDef, allowPrivateServices, deps[1]));\n    case 3:\n      return new ctor(\n          resolveDep(view, elDef, allowPrivateServices, deps[0]),\n          resolveDep(view, elDef, allowPrivateServices, deps[1]),\n          resolveDep(view, elDef, allowPrivateServices, deps[2]));\n    default:\n      const depValues = [];\n      for (let i = 0; i < len; i++) {\n        depValues.push(resolveDep(view, elDef, allowPrivateServices, deps[i]));\n      }\n      return new ctor(...depValues);\n  }\n}\n\nfunction callFactory(\n    view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, factory: any,\n    deps: DepDef[]): any {\n  const len = deps.length;\n  switch (len) {\n    case 0:\n      return factory();\n    case 1:\n      return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));\n    case 2:\n      return factory(\n          resolveDep(view, elDef, allowPrivateServices, deps[0]),\n          resolveDep(view, elDef, allowPrivateServices, deps[1]));\n    case 3:\n      return factory(\n          resolveDep(view, elDef, allowPrivateServices, deps[0]),\n          resolveDep(view, elDef, allowPrivateServices, deps[1]),\n          resolveDep(view, elDef, allowPrivateServices, deps[2]));\n    default:\n      const depValues = [];\n      for (let i = 0; i < len; i++) {\n        depValues.push(resolveDep(view, elDef, allowPrivateServices, deps[i]));\n      }\n      return factory(...depValues);\n  }\n}\n\n// This default value is when checking the hierarchy for a token.\n//\n// It means both:\n// - the token is not provided by the current injector,\n// - only the element injectors should be checked (ie do not check module injectors\n//\n//          mod1\n//         /\n//       el1   mod2\n//         \\  /\n//         el2\n//\n// When requesting el2.injector.get(token), we should check in the following order and return the\n// first found value:\n// - el2.injector.get(token, default)\n// - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module\n// - mod2.injector.get(token, default)\nexport const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\n\nexport function resolveDep(\n    view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef,\n    notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {\n  if (depDef.flags & DepFlags.Value) {\n    return depDef.token;\n  }\n  const startView = view;\n  if (depDef.flags & DepFlags.Optional) {\n    notFoundValue = null;\n  }\n  const tokenKey = depDef.tokenKey;\n\n  if (tokenKey === ChangeDetectorRefTokenKey) {\n    // directives on the same element as a component should be able to control the change detector\n    // of that component as well.\n    allowPrivateServices = !!(elDef && elDef.element!.componentView);\n  }\n\n  if (elDef && (depDef.flags & DepFlags.SkipSelf)) {\n    allowPrivateServices = false;\n    elDef = elDef.parent!;\n  }\n\n  let searchView: ViewData|null = view;\n  while (searchView) {\n    if (elDef) {\n      switch (tokenKey) {\n        case Renderer2TokenKey: {\n          const compView = findCompView(searchView, elDef, allowPrivateServices);\n          return compView.renderer;\n        }\n        case ElementRefTokenKey:\n          return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);\n        case ViewContainerRefTokenKey:\n          return asElementData(searchView, elDef.nodeIndex).viewContainer;\n        case TemplateRefTokenKey: {\n          if (elDef.element!.template) {\n            return asElementData(searchView, elDef.nodeIndex).template;\n          }\n          break;\n        }\n        case ChangeDetectorRefTokenKey: {\n          let cdView = findCompView(searchView, elDef, allowPrivateServices);\n          return createChangeDetectorRef(cdView);\n        }\n        case InjectorRefTokenKey:\n        case INJECTORRefTokenKey:\n          return createInjector(searchView, elDef);\n        default:\n          const providerDef =\n              (allowPrivateServices ? elDef.element!.allProviders :\n                                      elDef.element!.publicProviders)![tokenKey];\n          if (providerDef) {\n            let providerData = asProviderData(searchView, providerDef.nodeIndex);\n            if (!providerData) {\n              providerData = {instance: _createProviderInstance(searchView, providerDef)};\n              searchView.nodes[providerDef.nodeIndex] = providerData as any;\n            }\n            return providerData.instance;\n          }\n      }\n    }\n\n    allowPrivateServices = isComponentView(searchView);\n    elDef = viewParentEl(searchView)!;\n    searchView = searchView.parent!;\n\n    if (depDef.flags & DepFlags.Self) {\n      searchView = null;\n    }\n  }\n\n  const value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);\n\n  if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n      notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n    // Return the value from the root element injector when\n    // - it provides it\n    //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n    // - the module injector should not be checked\n    //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n    return value;\n  }\n\n  return startView.root.ngModule.injector.get(depDef.token, notFoundValue);\n}\n\nfunction findCompView(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean) {\n  let compView: ViewData;\n  if (allowPrivateServices) {\n    compView = asElementData(view, elDef.nodeIndex).componentView;\n  } else {\n    compView = view;\n    while (compView.parent && !isComponentView(compView)) {\n      compView = compView.parent;\n    }\n  }\n  return compView;\n}\n\nfunction updateProp(\n    view: ViewData, providerData: ProviderData, def: NodeDef, bindingIdx: number, value: any,\n    changes: SimpleChanges): SimpleChanges {\n  if (def.flags & NodeFlags.Component) {\n    const compView = asElementData(view, def.parent!.nodeIndex).componentView;\n    if (compView.def.flags & ViewFlags.OnPush) {\n      compView.state |= ViewState.ChecksEnabled;\n    }\n  }\n  const binding = def.bindings[bindingIdx];\n  const propName = binding.name!;\n  // Note: This is still safe with Closure Compiler as\n  // the user passed in the property name as an object has to `providerDef`,\n  // so Closure Compiler will have renamed the property correctly already.\n  providerData.instance[propName] = value;\n  if (def.flags & NodeFlags.OnChanges) {\n    changes = changes || {};\n    const oldValue = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);\n    const binding = def.bindings[bindingIdx];\n    changes[binding.nonMinifiedName!] =\n        new SimpleChange(oldValue, value, (view.state & ViewState.FirstCheck) !== 0);\n  }\n  view.oldValues[def.bindingIndex + bindingIdx] = value;\n  return changes;\n}\n\n// This function calls the ngAfterContentCheck, ngAfterContentInit,\n// ngAfterViewCheck, and ngAfterViewInit lifecycle hooks (depending on the node\n// flags in lifecycle). Unlike ngDoCheck, ngOnChanges and ngOnInit, which are\n// called during a pre-order traversal of the view tree (that is calling the\n// parent hooks before the child hooks) these events are sent in using a\n// post-order traversal of the tree (children before parents). This changes the\n// meaning of initIndex in the view state. For ngOnInit, initIndex tracks the\n// expected nodeIndex which a ngOnInit should be called. When sending\n// ngAfterContentInit and ngAfterViewInit it is the expected count of\n// ngAfterContentInit or ngAfterViewInit methods that have been called. This\n// ensure that despite being called recursively or after picking up after an\n// exception, the ngAfterContentInit or ngAfterViewInit will be called on the\n// correct nodes. Consider for example, the following (where E is an element\n// and D is a directive)\n//  Tree:       pre-order index  post-order index\n//    E1        0                6\n//      E2      1                1\n//       D3     2                0\n//      E4      3                5\n//       E5     4                4\n//        E6    5                2\n//        E7    6                3\n// As can be seen, the post-order index has an unclear relationship to the\n// pre-order index (postOrderIndex === preOrderIndex - parentCount +\n// childCount). Since number of calls to ngAfterContentInit and ngAfterViewInit\n// are stable (will be the same for the same view regardless of exceptions or\n// recursion) we just need to count them which will roughly correspond to the\n// post-order index (it skips elements and directives that do not have\n// lifecycle hooks).\n//\n// For example, if an exception is raised in the E6.onAfterViewInit() the\n// initIndex is left at 3 (by shouldCallLifecycleInitHook() which set it to\n// initIndex + 1). When checkAndUpdateView() is called again D3, E2 and E6 will\n// not have their ngAfterViewInit() called but, starting with E7, the rest of\n// the view will begin getting ngAfterViewInit() called until a check and\n// pass is complete.\n//\n// This algorthim also handles recursion. Consider if E4's ngAfterViewInit()\n// indirectly calls E1's ChangeDetectorRef.detectChanges(). The expected\n// initIndex is set to 6, the recusive checkAndUpdateView() starts walk again.\n// D3, E2, E6, E7, E5 and E4 are skipped, ngAfterViewInit() is called on E1.\n// When the recursion returns the initIndex will be 7 so E1 is skipped as it\n// has already been called in the recursively called checkAnUpdateView().\nexport function callLifecycleHooksChildrenFirst(view: ViewData, lifecycles: NodeFlags) {\n  if (!(view.def.nodeFlags & lifecycles)) {\n    return;\n  }\n  const nodes = view.def.nodes;\n  let initIndex = 0;\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeDef = nodes[i];\n    let parent = nodeDef.parent;\n    if (!parent && nodeDef.flags & lifecycles) {\n      // matching root node (e.g. a pipe)\n      callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);\n    }\n    if ((nodeDef.childFlags & lifecycles) === 0) {\n      // no child matches one of the lifecycles\n      i += nodeDef.childCount;\n    }\n    while (parent && (parent.flags & NodeFlags.TypeElement) &&\n           i === parent.nodeIndex + parent.childCount) {\n      // last child of an element\n      if (parent.directChildFlags & lifecycles) {\n        initIndex = callElementProvidersLifecycles(view, parent, lifecycles, initIndex);\n      }\n      parent = parent.parent;\n    }\n  }\n}\n\nfunction callElementProvidersLifecycles(\n    view: ViewData, elDef: NodeDef, lifecycles: NodeFlags, initIndex: number): number {\n  for (let i = elDef.nodeIndex + 1; i <= elDef.nodeIndex + elDef.childCount; i++) {\n    const nodeDef = view.def.nodes[i];\n    if (nodeDef.flags & lifecycles) {\n      callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);\n    }\n    // only visit direct children\n    i += nodeDef.childCount;\n  }\n  return initIndex;\n}\n\nfunction callProviderLifecycles(\n    view: ViewData, index: number, lifecycles: NodeFlags, initIndex: number) {\n  const providerData = asProviderData(view, index);\n  if (!providerData) {\n    return;\n  }\n  const provider = providerData.instance;\n  if (!provider) {\n    return;\n  }\n  Services.setCurrentNode(view, index);\n  if (lifecycles & NodeFlags.AfterContentInit &&\n      shouldCallLifecycleInitHook(view, ViewState.InitState_CallingAfterContentInit, initIndex)) {\n    provider.ngAfterContentInit();\n  }\n  if (lifecycles & NodeFlags.AfterContentChecked) {\n    provider.ngAfterContentChecked();\n  }\n  if (lifecycles & NodeFlags.AfterViewInit &&\n      shouldCallLifecycleInitHook(view, ViewState.InitState_CallingAfterViewInit, initIndex)) {\n    provider.ngAfterViewInit();\n  }\n  if (lifecycles & NodeFlags.AfterViewChecked) {\n    provider.ngAfterViewChecked();\n  }\n  if (lifecycles & NodeFlags.OnDestroy) {\n    provider.ngOnDestroy();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef as ViewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {InjectFlags} from '../di/interface/injector';\nimport {AbstractType, Type} from '../interface/type';\nimport {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\nimport {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {createElementRef, ElementRef as viewEngine_ElementRef} from '../linker/element_ref';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {RendererFactory2} from '../render/api';\nimport {Sanitizer} from '../sanitization/sanitizer';\nimport {VERSION} from '../version';\nimport {NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR} from '../view/provider';\nimport {assertComponentType} from './assert';\nimport {createRootComponent, createRootComponentView, createRootContext, LifecycleHooksFeature} from './component';\nimport {getComponentDef} from './definition';\nimport {NodeInjector} from './di';\nimport {createLView, createTView, locateHostElement, renderView} from './instructions/shared';\nimport {ComponentDef} from './interfaces/definition';\nimport {TContainerNode, TElementContainerNode, TElementNode, TNode} from './interfaces/node';\nimport {domRendererFactory3, RendererFactory3} from './interfaces/renderer';\nimport {RNode} from './interfaces/renderer_dom';\nimport {HEADER_OFFSET, LView, LViewFlags, TViewType} from './interfaces/view';\nimport {MATH_ML_NAMESPACE, SVG_NAMESPACE} from './namespaces';\nimport {createElementNode, writeDirectClass} from './node_manipulation';\nimport {extractAttrsAndClassesFromSelector, stringifyCSSSelectorList} from './node_selector_matcher';\nimport {enterView, leaveView} from './state';\nimport {setUpAttributes} from './util/attrs_utils';\nimport {defaultScheduler} from './util/misc_utils';\nimport {getTNode} from './util/view_utils';\nimport {RootViewRef, ViewRef} from './view_ref';\n\nexport class ComponentFactoryResolver extends viewEngine_ComponentFactoryResolver {\n  /**\n   * @param ngModule The NgModuleRef to which all resolved factories are bound.\n   */\n  constructor(private ngModule?: viewEngine_NgModuleRef<any>) {\n    super();\n  }\n\n  resolveComponentFactory<T>(component: Type<T>): viewEngine_ComponentFactory<T> {\n    ngDevMode && assertComponentType(component);\n    const componentDef = getComponentDef(component)!;\n    return new ComponentFactory(componentDef, this.ngModule);\n  }\n}\n\nfunction toRefArray(map: {[key: string]: string}): {propName: string; templateName: string;}[] {\n  const array: {propName: string; templateName: string;}[] = [];\n  for (let nonMinified in map) {\n    if (map.hasOwnProperty(nonMinified)) {\n      const minified = map[nonMinified];\n      array.push({propName: minified, templateName: nonMinified});\n    }\n  }\n  return array;\n}\n\nfunction getNamespace(elementName: string): string|null {\n  const name = elementName.toLowerCase();\n  return name === 'svg' ? SVG_NAMESPACE : (name === 'math' ? MATH_ML_NAMESPACE : null);\n}\n\n/**\n * A change detection scheduler token for {@link RootContext}. This token is the default value used\n * for the default `RootContext` found in the {@link ROOT_CONTEXT} token.\n */\nexport const SCHEDULER = new InjectionToken<((fn: () => void) => void)>('SCHEDULER_TOKEN', {\n  providedIn: 'root',\n  factory: () => defaultScheduler,\n});\n\nfunction createChainedInjector(rootViewInjector: Injector, moduleInjector: Injector): Injector {\n  return {\n    get: <T>(\n        token: Type<T>|AbstractType<T>|InjectionToken<T>, notFoundValue?: T,\n        flags?: InjectFlags): T => {\n      const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as T, flags);\n\n      if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ||\n          notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n        // Return the value from the root element injector when\n        // - it provides it\n        //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n        // - the module injector should not be checked\n        //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)\n        return value;\n      }\n\n      return moduleInjector.get(token, notFoundValue, flags);\n    }\n  };\n}\n\n/**\n * Render3 implementation of {@link viewEngine_ComponentFactory}.\n */\nexport class ComponentFactory<T> extends viewEngine_ComponentFactory<T> {\n  selector: string;\n  componentType: Type<any>;\n  ngContentSelectors: string[];\n  isBoundToModule: boolean;\n\n  get inputs(): {propName: string; templateName: string;}[] {\n    return toRefArray(this.componentDef.inputs);\n  }\n\n  get outputs(): {propName: string; templateName: string;}[] {\n    return toRefArray(this.componentDef.outputs);\n  }\n\n  /**\n   * @param componentDef The component definition.\n   * @param ngModule The NgModuleRef to which the factory is bound.\n   */\n  constructor(\n      private componentDef: ComponentDef<any>, private ngModule?: viewEngine_NgModuleRef<any>) {\n    super();\n    this.componentType = componentDef.type;\n    this.selector = stringifyCSSSelectorList(componentDef.selectors);\n    this.ngContentSelectors =\n        componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];\n    this.isBoundToModule = !!ngModule;\n  }\n\n  create(\n      injector: Injector, projectableNodes?: any[][]|undefined, rootSelectorOrNode?: any,\n      ngModule?: viewEngine_NgModuleRef<any>|undefined): viewEngine_ComponentRef<T> {\n    ngModule = ngModule || this.ngModule;\n\n    const rootViewInjector =\n        ngModule ? createChainedInjector(injector, ngModule.injector) : injector;\n\n    const rendererFactory =\n        rootViewInjector.get(RendererFactory2, domRendererFactory3) as RendererFactory3;\n    const sanitizer = rootViewInjector.get(Sanitizer, null);\n\n    const hostRenderer = rendererFactory.createRenderer(null, this.componentDef);\n    // Determine a tag name used for creating host elements when this component is created\n    // dynamically. Default to 'div' if this component did not specify any tag name in its selector.\n    const elementName = this.componentDef.selectors[0][0] as string || 'div';\n    const hostRNode = rootSelectorOrNode ?\n        locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) :\n        createElementNode(\n            rendererFactory.createRenderer(null, this.componentDef), elementName,\n            getNamespace(elementName));\n\n    const rootFlags = this.componentDef.onPush ? LViewFlags.Dirty | LViewFlags.IsRoot :\n                                                 LViewFlags.CheckAlways | LViewFlags.IsRoot;\n    const rootContext = createRootContext();\n\n    // Create the root view. Uses empty TView and ContentTemplate.\n    const rootTView = createTView(TViewType.Root, null, null, 1, 0, null, null, null, null, null);\n    const rootLView = createLView(\n        null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer,\n        sanitizer, rootViewInjector);\n\n    // rootView is the parent when bootstrapping\n    // TODO(misko): it looks like we are entering view here but we don't really need to as\n    // `renderView` does that. However as the code is written it is needed because\n    // `createRootComponentView` and `createRootComponent` both read global state. Fixing those\n    // issues would allow us to drop this.\n    enterView(rootLView);\n\n    let component: T;\n    let tElementNode: TElementNode;\n\n    try {\n      const componentView = createRootComponentView(\n          hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);\n      if (hostRNode) {\n        if (rootSelectorOrNode) {\n          setUpAttributes(hostRenderer, hostRNode, ['ng-version', VERSION.full]);\n        } else {\n          // If host element is created as a part of this function call (i.e. `rootSelectorOrNode`\n          // is not defined), also apply attributes and classes extracted from component selector.\n          // Extract attributes and classes from the first selector only to match VE behavior.\n          const {attrs, classes} =\n              extractAttrsAndClassesFromSelector(this.componentDef.selectors[0]);\n          if (attrs) {\n            setUpAttributes(hostRenderer, hostRNode, attrs);\n          }\n          if (classes && classes.length > 0) {\n            writeDirectClass(hostRenderer, hostRNode, classes.join(' '));\n          }\n        }\n      }\n\n      tElementNode = getTNode(rootTView, HEADER_OFFSET) as TElementNode;\n\n      if (projectableNodes !== undefined) {\n        const projection: (TNode|RNode[]|null)[] = tElementNode.projection = [];\n        for (let i = 0; i < this.ngContentSelectors.length; i++) {\n          const nodesforSlot = projectableNodes[i];\n          // Projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade\n          // case). Here we do normalize passed data structure to be an array of arrays to avoid\n          // complex checks down the line.\n          // We also normalize the length of the passed in projectable nodes (to match the number of\n          // <ng-container> slots defined by a component).\n          projection.push(nodesforSlot != null ? Array.from(nodesforSlot) : null);\n        }\n      }\n\n      // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and\n      // executed here?\n      // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref\n      component = createRootComponent(\n          componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);\n\n      renderView(rootTView, rootLView, null);\n    } finally {\n      leaveView();\n    }\n\n    return new ComponentRef(\n        this.componentType, component, createElementRef(tElementNode, rootLView), rootLView,\n        tElementNode);\n  }\n}\n\nconst componentFactoryResolver: ComponentFactoryResolver = new ComponentFactoryResolver();\n\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\nexport function injectComponentFactoryResolver(): viewEngine_ComponentFactoryResolver {\n  return componentFactoryResolver;\n}\n\n/**\n * Represents an instance of a Component created via a {@link ComponentFactory}.\n *\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}\n * method.\n *\n */\nexport class ComponentRef<T> extends viewEngine_ComponentRef<T> {\n  instance: T;\n  hostView: ViewRef<T>;\n  changeDetectorRef: ViewEngine_ChangeDetectorRef;\n  componentType: Type<T>;\n\n  constructor(\n      componentType: Type<T>, instance: T, public location: viewEngine_ElementRef,\n      private _rootLView: LView,\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode) {\n    super();\n    this.instance = instance;\n    this.hostView = this.changeDetectorRef = new RootViewRef<T>(_rootLView);\n    this.componentType = componentType;\n  }\n\n  get injector(): Injector {\n    return new NodeInjector(this._tNode, this._rootLView);\n  }\n\n  destroy(): void {\n    this.hostView.destroy();\n  }\n\n  onDestroy(callback: () => void): void {\n    this.hostView.onDestroy(callback);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nexport const MATH_ML_NAMESPACE = 'http://www.w3.org/1998/MathML/';\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type} from '../interface/type';\nimport {NgModuleType} from '../metadata/ng_module_def';\nimport {autoRegisterModuleById, getNgModuleDef} from '../render3/definition';\nimport {maybeUnwrapFn} from '../render3/util/misc_utils';\nimport {stringify} from '../util/stringify';\n\nimport {NgModuleFactory} from './ng_module_factory';\n\n\n/**\n * Map of module-id to the corresponding NgModule.\n * - In pre Ivy we track NgModuleFactory,\n * - In post Ivy we track the NgModuleType\n */\nconst modules = new Map<string, NgModuleFactory<any>|NgModuleType>();\n\n/**\n * Registers a loaded module. Should only be called from generated NgModuleFactory code.\n * @publicApi\n */\nexport function registerModuleFactory(id: string, factory: NgModuleFactory<any>) {\n  const existing = modules.get(id) as NgModuleFactory<any>;\n  assertSameOrNotExisting(id, existing && existing.moduleType, factory.moduleType);\n  modules.set(id, factory);\n}\n\nfunction assertSameOrNotExisting(id: string, type: Type<any>|null, incoming: Type<any>): void {\n  if (type && type !== incoming) {\n    throw new Error(\n        `Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\n\nexport function registerNgModuleType(ngModuleType: NgModuleType): void {\n  const visited = new Set<NgModuleType>();\n  recurse(ngModuleType);\n  function recurse(ngModuleType: NgModuleType): void {\n    // The imports array of an NgModule must refer to other NgModules,\n    // so an error is thrown if no module definition is available.\n    const def = getNgModuleDef(ngModuleType, /* throwNotFound */ true);\n    const id = def.id;\n    if (id !== null) {\n      const existing = modules.get(id) as NgModuleType | null;\n      assertSameOrNotExisting(id, existing, ngModuleType);\n      modules.set(id, ngModuleType);\n    }\n\n    const imports = maybeUnwrapFn(def.imports) as NgModuleType[];\n    for (const i of imports) {\n      if (!visited.has(i)) {\n        visited.add(i);\n        recurse(i);\n      }\n    }\n  }\n}\n\nexport function clearModulesForTest(): void {\n  modules.clear();\n}\n\nexport function getRegisteredNgModuleType(id: string) {\n  return modules.get(id) || autoRegisterModuleById[id];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {INJECTOR} from '../di/injector_token';\nimport {InjectFlags} from '../di/interface/injector';\nimport {createInjectorWithoutInjectorInstances, R3Injector} from '../di/r3_injector';\nimport {Type} from '../interface/type';\nimport {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {InternalNgModuleRef, NgModuleFactory as viewEngine_NgModuleFactory, NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {registerNgModuleType} from '../linker/ng_module_factory_registration';\nimport {NgModuleType} from '../metadata/ng_module_def';\nimport {assertDefined} from '../util/assert';\nimport {stringify} from '../util/stringify';\n\nimport {ComponentFactoryResolver} from './component_ref';\nimport {getNgLocaleIdDef, getNgModuleDef} from './definition';\nimport {setLocaleId} from './i18n/i18n_locale_id';\nimport {maybeUnwrapFn} from './util/misc_utils';\n\nexport class NgModuleRef<T> extends viewEngine_NgModuleRef<T> implements InternalNgModuleRef<T> {\n  // tslint:disable-next-line:require-internal-with-underscore\n  _bootstrapComponents: Type<any>[] = [];\n  // tslint:disable-next-line:require-internal-with-underscore\n  _r3Injector: R3Injector;\n  injector: Injector = this;\n  instance: T;\n  destroyCbs: (() => void)[]|null = [];\n\n  // When bootstrapping a module we have a dependency graph that looks like this:\n  // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the\n  // module being resolved tries to inject the ComponentFactoryResolver, it'll create a\n  // circular dependency which will result in a runtime error, because the injector doesn't\n  // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves\n  // and providing it, rather than letting the injector resolve it.\n  readonly componentFactoryResolver: ComponentFactoryResolver = new ComponentFactoryResolver(this);\n\n  constructor(ngModuleType: Type<T>, public _parent: Injector|null) {\n    super();\n    const ngModuleDef = getNgModuleDef(ngModuleType);\n    ngDevMode &&\n        assertDefined(\n            ngModuleDef,\n            `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);\n\n    const ngLocaleIdDef = getNgLocaleIdDef(ngModuleType);\n    ngLocaleIdDef && setLocaleId(ngLocaleIdDef);\n    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef!.bootstrap);\n    this._r3Injector = createInjectorWithoutInjectorInstances(\n                           ngModuleType, _parent,\n                           [\n                             {provide: viewEngine_NgModuleRef, useValue: this}, {\n                               provide: viewEngine_ComponentFactoryResolver,\n                               useValue: this.componentFactoryResolver\n                             }\n                           ],\n                           stringify(ngModuleType)) as R3Injector;\n\n    // We need to resolve the injector types separately from the injector creation, because\n    // the module might be trying to use this ref in its contructor for DI which will cause a\n    // circular error that will eventually error out, because the injector isn't created yet.\n    this._r3Injector._resolveInjectorDefTypes();\n    this.instance = this.get(ngModuleType);\n  }\n\n  get(token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND,\n      injectFlags: InjectFlags = InjectFlags.Default): any {\n    if (token === Injector || token === viewEngine_NgModuleRef || token === INJECTOR) {\n      return this;\n    }\n    return this._r3Injector.get(token, notFoundValue, injectFlags);\n  }\n\n  destroy(): void {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    const injector = this._r3Injector;\n    !injector.destroyed && injector.destroy();\n    this.destroyCbs!.forEach(fn => fn());\n    this.destroyCbs = null;\n  }\n  onDestroy(callback: () => void): void {\n    ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');\n    this.destroyCbs!.push(callback);\n  }\n}\n\nexport class NgModuleFactory<T> extends viewEngine_NgModuleFactory<T> {\n  constructor(public moduleType: Type<T>) {\n    super();\n\n    const ngModuleDef = getNgModuleDef(moduleType);\n    if (ngModuleDef !== null) {\n      // Register the NgModule with Angular's module registry. The location (and hence timing) of\n      // this call is critical to ensure this works correctly (modules get registered when expected)\n      // without bloating bundles (modules are registered when otherwise not referenced).\n      //\n      // In View Engine, registration occurs in the .ngfactory.js file as a side effect. This has\n      // several practical consequences:\n      //\n      // - If an .ngfactory file is not imported from, the module won't be registered (and can be\n      //   tree shaken).\n      // - If an .ngfactory file is imported from, the module will be registered even if an instance\n      //   is not actually created (via `create` below).\n      // - Since an .ngfactory file in View Engine references the .ngfactory files of the NgModule's\n      //   imports,\n      //\n      // In Ivy, things are a bit different. .ngfactory files still exist for compatibility, but are\n      // not a required API to use - there are other ways to obtain an NgModuleFactory for a given\n      // NgModule. Thus, relying on a side effect in the .ngfactory file is not sufficient. Instead,\n      // the side effect of registration is added here, in the constructor of NgModuleFactory,\n      // ensuring no matter how a factory is created, the module is registered correctly.\n      //\n      // An alternative would be to include the registration side effect inline following the actual\n      // NgModule definition. This also has the correct timing, but breaks tree-shaking - modules\n      // will be registered and retained even if they're otherwise never referenced.\n      registerNgModuleType(moduleType as NgModuleType);\n    }\n  }\n\n  create(parentInjector: Injector|null): viewEngine_NgModuleRef<T> {\n    return new NgModuleRef(this.moduleType, parentInjector);\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","let _enable_super_gross_mode_that_will_cause_bad_things = false;\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like what Promise contructor should used to create Promises\n */\nexport const config = {\n  /**\n   * The promise constructor used by default for methods such as\n   * {@link toPromise} and {@link forEach}\n   */\n  Promise: undefined as PromiseConstructorLike,\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME\n   * FOR MIGRATION REASONS.\n   */\n  set useDeprecatedSynchronousErrorHandling(value: boolean) {\n    if (value) {\n      const error = new Error();\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n      console.log('RxJS: Back to a better error behavior. Thank you. <3');\n    }\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  },\n};\n","import { Observer } from './types';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete(): void { /*noop*/ }\n};\n","export function isObject(x: any): x is Object {\n  return x !== null && typeof x === 'object';\n}\n","export interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  new(errors: any[]): UnsubscriptionError;\n}\n\nconst UnsubscriptionErrorImpl = (() => {\n  function UnsubscriptionErrorImpl(this: any, errors: any[]) {\n    Error.call(this);\n    this.message = errors ?\n      `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n    return this;\n  }\n\n  UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);\n\n  return UnsubscriptionErrorImpl;\n})();\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = UnsubscriptionErrorImpl as any;","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic } from './types';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY: Subscription = (function(empty: any) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  /** @internal */\n  protected _parentOrParents: Subscription | Subscription[] = null;\n  /** @internal */\n  private _subscriptions: SubscriptionLike[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parentOrParents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parentOrParents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    if (_parentOrParents instanceof Subscription) {\n      _parentOrParents.remove(this);\n    } else if (_parentOrParents !== null) {\n      for (let index = 0; index < _parentOrParents.length; ++index) {\n        const parent = _parentOrParents[index];\n        parent.remove(this);\n      }\n    }\n\n    if (isFunction(_unsubscribe)) {\n      try {\n        _unsubscribe.call(this);\n      } catch (e) {\n        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n      let index = -1;\n      let len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          try {\n            sub.unsubscribe();\n          } catch (e) {\n            errors = errors || [];\n            if (e instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));\n            } else {\n              errors.push(e);\n            }\n          }\n        }\n      }\n    }\n\n    if (errors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription. Can also be used to add a child subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * When a parent subscription is unsubscribed, any child subscriptions that were added to it are also unsubscribed.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    let subscription = (<Subscription>teardown);\n\n    if (!(<any>teardown)) {\n      return Subscription.EMPTY;\n    }\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void)>teardown);\n      case 'object':\n        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          // This also covers the case where `subscription` is `Subscription.EMPTY`, which is always in `closed` state.\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (!(subscription instanceof Subscription)) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default: {\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n      }\n    }\n\n    // Add `this` as parent of `subscription` if that's not already the case.\n    let { _parentOrParents } = subscription;\n    if (_parentOrParents === null) {\n      // If we don't have a parent, then set `subscription._parents` to\n      // the `this`, which is the common case that we optimize for.\n      subscription._parentOrParents = this;\n    } else if (_parentOrParents instanceof Subscription) {\n      if (_parentOrParents === this) {\n        // The `subscription` already has `this` as a parent.\n        return subscription;\n      }\n      // If there's already one parent, but not multiple, allocate an\n      // Array to store the rest of the parent Subscriptions.\n      subscription._parentOrParents = [_parentOrParents, this];\n    } else if (_parentOrParents.indexOf(this) === -1) {\n      // Only add `this` to the _parentOrParents list if it's not already there.\n      _parentOrParents.push(this);\n    } else {\n      // The `subscription` already has `this` as a parent.\n      return subscription;\n    }\n\n    // Optimize for the common case when adding the first subscription.\n    const subscriptions = this._subscriptions;\n    if (subscriptions === null) {\n      this._subscriptions = [subscription];\n    } else {\n      subscriptions.push(subscription);\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","/** @deprecated do not use, this is no longer checked by RxJS internals */\nexport const rxSubscriber = (() =>\n  typeof Symbol === 'function'\n    ? Symbol('rxSubscriber')\n    : '@@rxSubscriber_' + Math.random())();\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Observer, PartialObserver, TeardownLogic } from './types';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  /** @internal */ syncErrorValue: any = null;\n  /** @internal */ syncErrorThrown: boolean = false;\n  /** @internal */ syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any> | Subscriber<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = destinationOrNext;\n            destinationOrNext.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _unsubscribeAndRecycle(): Subscriber<T> {\n    const {  _parentOrParents } = this;\n    this._parentOrParents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parentOrParents = _parentOrParents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      const { useDeprecatedSynchronousErrorHandling } = config;\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>, fn4: UnaryFunction<C, D>, fn5: UnaryFunction<D, E>, fn6: UnaryFunction<E, F>, fn7: UnaryFunction<F, G>, fn8: UnaryFunction<G, H>, fn9: UnaryFunction<H, I>, ...fns: UnaryFunction<any, any>[]): UnaryFunction<T, {}>;\n/* tslint:enable:max-line-length */\n\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, PartialObserver, Subscribable } from './types';\nimport { canReportError } from './util/canReportError';\nimport { toSubscriber } from './util/toSubscriber';\nimport { iif } from './observable/iif';\nimport { throwError } from './observable/throwError';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  /** Internal implementation detail, do not use directly. */\n  public _isScalar: boolean = false;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  source: Observable<any>;\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   * @nocollapse\n   * @deprecated use new Observable() instead\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  /** @deprecated Use an observer instead of a complete callback */\n  subscribe(next: null | undefined, error: null | undefined, complete: () => void): Subscription;\n  /** @deprecated Use an observer instead of an error callback */\n  subscribe(next: null | undefined, error: (error: any) => void, complete?: () => void): Subscription;\n  /** @deprecated Use an observer instead of a complete callback */\n  subscribe(next: (value: T) => void, error: null | undefined, complete: () => void): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * ## Example\n   * ### Subscribe with an Observer\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Subscribe with functions\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   * ```\n   *\n   * ### Cancel a subscription\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * );\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      sink.add(operator.call(sink, this.source));\n    } else {\n      sink.add(\n        this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n        this._subscribe(sink) :\n        this._trySubscribe(sink)\n      );\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a ReferenceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    }) as Promise<void>;\n  }\n\n  /** @internal This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    const { source } = this;\n    return source && source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words. Deprecated in\n  // favor of iif and throwError functions.\n  /**\n   * @nocollapse\n   * @deprecated In favor of iif creation function: import { iif } from 'rxjs';\n   */\n  static if: typeof iif;\n  /**\n   * @nocollapse\n   * @deprecated In favor of throwError creation function: import { throwError } from 'rxjs';\n   */\n  static throw: typeof throwError;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<{}>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ### Example\n   * ```ts\n   * import { interval } from 'rxjs';\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  if (!promiseCtor) {\n    promiseCtor = config.Promise || Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nimport { PartialObserver } from '../types';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { Subscriber } from '../Subscriber';\nimport { Subject } from '../Subject';\n\n/**\n * Determines whether the ErrorObserver is closed or stopped or has a\n * destination that is closed or stopped - in which case errors will\n * need to be reported via a different mechanism.\n * @param observer the observer\n */\nexport function canReportError(observer: Subscriber<any> | Subject<any>): boolean {\n  while (observer) {\n    const { closed, destination, isStopped } = observer as any;\n    if (closed || isStopped) {\n      return false;\n    } else if (destination && destination instanceof Subscriber) {\n      observer = destination;\n    } else {\n      observer = null;\n    }\n  }\n  return true;\n}\n","export interface ObjectUnsubscribedError extends Error {\n}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  new(): ObjectUnsubscribedError;\n}\n\nconst ObjectUnsubscribedErrorImpl = (() => {\n  function ObjectUnsubscribedErrorImpl(this: any) {\n    Error.call(this);\n    this.message = 'object unsubscribed';\n    this.name = 'ObjectUnsubscribedError';\n    return this;\n  }\n\n  ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);\n\n  return ObjectUnsubscribedErrorImpl;\n})();\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = ObjectUnsubscribedErrorImpl as any;","import { Subject } from './Subject';\nimport { Observer } from './types';\nimport { Subscription } from './Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class SubjectSubscription<T> extends Subscription {\n  closed: boolean = false;\n\n  constructor(public subject: Subject<T>, public subscriber: Observer<T>) {\n    super();\n  }\n\n  unsubscribe() {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const subject = this.subject;\n    const observers = subject.observers;\n\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    const subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  }\n}\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\n\n/**\n * @class SubjectSubscriber<T>\n */\nexport class SubjectSubscriber<T> extends Subscriber<T> {\n  constructor(protected destination: Subject<T>) {\n    super(destination);\n  }\n}\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n *\n * @class Subject<T>\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n\n  [rxSubscriberSymbol]() {\n    return new SubjectSubscriber(this);\n  }\n\n  observers: Observer<T>[] = [];\n\n  closed = false;\n\n  isStopped = false;\n\n  hasError = false;\n\n  thrownError: any = null;\n\n  constructor() {\n    super();\n  }\n\n  /**@nocollapse\n   * @deprecated use new Subject() instead\n  */\n  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  }\n\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = <any>operator;\n    return <any>subject;\n  }\n\n  next(value?: T) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    if (!this.isStopped) {\n      const { observers } = this;\n      const len = observers.length;\n      const copy = observers.slice();\n      for (let i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  }\n\n  error(err: any) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n    this.observers.length = 0;\n  }\n\n  complete() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n    this.isStopped = true;\n    const { observers } = this;\n    const len = observers.length;\n    const copy = observers.slice();\n    for (let i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n    this.observers.length = 0;\n  }\n\n  unsubscribe() {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return super._trySubscribe(subscriber);\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create customize Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable = new Observable<T>();\n    (<any>observable).source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(protected destination?: Observer<T>, source?: Observable<T>) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    const { destination } = this;\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  }\n\n  error(err: any) {\n    const { destination } = this;\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  }\n\n  complete() {\n    const { destination } = this;\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>): Subscription {\n    const { source } = this;\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  }\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, TeardownLogic } from '../types';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the *publish* operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval } from 'rxjs';\n * import { tap, publish, refCount } from 'rxjs/operators';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap((num) => console.log(`refCount ${num}`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap((num) => console.log(`publish ${num}`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the publish operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  } as MonoTypeOperatorFunction<T>;\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // )\n    // .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { TeardownLogic } from '../types';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  protected _subject: Subject<T>;\n  protected _refCount: number = 0;\n  protected _connection: Subscription;\n  /** @internal */\n  _isComplete = false;\n\n  constructor(public source: Observable<T>,\n              protected subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated This is an internal implementation detail, do not use. */\n  _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = (() => {\n  const connectableProto = <any>ConnectableObservable.prototype;\n  return {\n    operator: { value: null as null },\n    _refCount: { value: 0, writable: true },\n    _subject: { value: null as null, writable: true },\n    _connection: { value: null as null, writable: true },\n    _subscribe: { value: connectableProto._subscribe },\n    _isComplete: { value: connectableProto._isComplete, writable: true },\n    getSubject: { value: connectableProto.getSubject },\n    connect: { value: connectableProto.connect },\n    refCount: { value: connectableProto.refCount }\n  };\n})();\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  protected _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  protected _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // range(0, 10).pipe(\n    //   publish(),\n    //   refCount(),\n    //   take(5),\n    // ).subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n","import { SchedulerLike } from '../types';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { Subscriber } from '../Subscriber';\n\n/**\n * Subscribes to an ArrayLike with a subscriber\n * @param array The array or array-like to subscribe to\n */\nexport const subscribeToArray = <T>(array: ArrayLike<T>) => (subscriber: Subscriber<T>) => {\n  for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n    subscriber.next(array[i]);\n  }\n  subscriber.complete();\n};\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { subscribeToArray } from '../util/subscribeToArray';\nimport { scheduleArray } from '../scheduled/scheduleArray';\n\nexport function fromArray<T>(input: ArrayLike<T>, scheduler?: SchedulerLike) {\n  if (!scheduler) {\n    return new Observable<T>(subscribeToArray(input));\n  } else {\n    return scheduleArray(input, scheduler);\n  }\n}\n","import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { Subscription } from '../Subscription';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>(subscriber => {\n    const sub = new Subscription();\n    let i = 0;\n    sub.add(scheduler.schedule(function () {\n      if (i === input.length) {\n        subscriber.complete();\n        return;\n      }\n      subscriber.next(input[i++]);\n      if (!subscriber.closed) {\n        sub.add(this.schedule());\n      }\n    }));\n    return sub;\n  });\n}\n","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n * Map every click to the clientX position of that click\n * ```ts\n * import { fromEvent } from 'rxjs';\n * import { map } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: R;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, public outerValue: T, public outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n\n/**\n * @deprecated use {@link iterator} instead\n */\nexport const $$iterator = iterator;\n","import { ObservableInput } from '../types';\nimport { subscribeToArray } from './subscribeToArray';\nimport { subscribeToPromise } from './subscribeToPromise';\nimport { subscribeToIterable } from './subscribeToIterable';\nimport { subscribeToObservable } from './subscribeToObservable';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { Subscription } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\nexport const subscribeTo = <T>(result: ObservableInput<T>): (subscriber: Subscriber<T>) => Subscription | void => {\n  if (!!result && typeof result[Symbol_observable] === 'function') {\n    return subscribeToObservable(result as any);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result as Promise<any>);\n  } else if (!!result && typeof result[Symbol_iterator] === 'function') {\n    return subscribeToIterable(result as any);\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n","import { Subscriber } from '../Subscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\n/**\n * Subscribes to an object that implements Symbol.observable with the given\n * Subscriber.\n * @param obj An object that implements Symbol.observable\n */\nexport const subscribeToObservable = <T>(obj: any) => (subscriber: Subscriber<T>) => {\n  const obs = obj[Symbol_observable]();\n  if (typeof obs.subscribe !== 'function') {\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  } else {\n    return obs.subscribe(subscriber);\n  }\n};\n","import { Subscriber } from '../Subscriber';\nimport { hostReportError } from './hostReportError';\n\nexport const subscribeToPromise = <T>(promise: PromiseLike<T>) => (subscriber: Subscriber<T>) => {\n  promise.then(\n    (value) => {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    },\n    (err: any) => subscriber.error(err)\n  )\n  .then(null, hostReportError);\n  return subscriber;\n};\n","import { Subscriber } from '../Subscriber';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\n\nexport const subscribeToIterable = <T>(iterable: Iterable<T>) => (subscriber: Subscriber<T>) => {\n  const iterator = iterable[Symbol_iterator]();\n  do {\n    const item = iterator.next();\n    if (item.done) {\n      subscriber.complete();\n      break;\n    }\n    subscriber.next(item.value);\n    if (subscriber.closed) {\n      break;\n    }\n  } while (true);\n\n  // Finalize the iterator if it happens to be a Generator\n  if (typeof iterator.return === 'function') {\n    subscriber.add(() => {\n      if (iterator.return) {\n        iterator.return();\n      }\n    });\n  }\n\n  return subscriber;\n};\n","import { Observable } from '../Observable';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { from } from '../observable/from';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, concurrent?: number): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined, concurrent?: number): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated resultSelector no longer supported, use inner map instead */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R, concurrent?: number): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n * Map and flatten each letter to an Observable ticking every 1 second\n * ```ts\n * import { of, interval } from 'rxjs';\n * import { mergeMap, map } from 'rxjs/operators';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x+i))),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a,b,c with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional deprecated `resultSelector`) to each item\n * emitted by the source Observable and merging the results of the Observables\n * obtained from this transformation.\n * @method mergeMap\n * @owner Observable\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Number.POSITIVE_INFINITY\n): OperatorFunction<T, ObservedValueOf<O>|R> {\n  if (typeof resultSelector === 'function') {\n    // DEPRECATED PATH\n    return (source: Observable<T>) => source.pipe(\n      mergeMap((a, i) => from(project(a, i)).pipe(\n        map((b: any, ii: number) => resultSelector(a, b, i, ii)),\n      ), concurrent)\n    );\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return (source: Observable<T>) => source.lift(new MergeMapOperator(project, concurrent));\n}\n\nexport class MergeMapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n  }\n\n  call(observer: Subscriber<R>, source: any): any {\n    return source.subscribe(new MergeMapSubscriber(\n      observer, this.project, this.concurrent\n    ));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class MergeMapSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private hasCompleted: boolean = false;\n  private buffer: T[] = [];\n  private active: number = 0;\n  protected index: number = 0;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => ObservableInput<R>,\n              private concurrent: number = Number.POSITIVE_INFINITY) {\n    super(destination);\n  }\n\n  protected _next(value: T): void {\n    if (this.active < this.concurrent) {\n      this._tryNext(value);\n    } else {\n      this.buffer.push(value);\n    }\n  }\n\n  protected _tryNext(value: T) {\n    let result: ObservableInput<R>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.active++;\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(ish: ObservableInput<R>, value: T, index: number): void {\n    const innerSubscriber = new InnerSubscriber(this, value, index);\n    const destination = this.destination as Subscription;\n    destination.add(innerSubscriber);\n    const innerSubscription = subscribeToResult<T, R>(this, ish, undefined, undefined, innerSubscriber);\n    // The returned subscription will usually be the subscriber that was\n    // passed. However, interop subscribers will be wrapped and for\n    // unsubscriptions to chain correctly, the wrapper needs to be added, too.\n    if (innerSubscription !== innerSubscriber) {\n      destination.add(innerSubscription);\n    }\n  }\n\n  protected _complete(): void {\n    this.hasCompleted = true;\n    if (this.active === 0 && this.buffer.length === 0) {\n      this.destination.complete();\n    }\n    this.unsubscribe();\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    const buffer = this.buffer;\n    this.remove(innerSub);\n    this.active--;\n    if (buffer.length > 0) {\n      this._next(buffer.shift());\n    } else if (this.active === 0 && this.hasCompleted) {\n      this.destination.complete();\n    }\n  }\n}\n","import { Observable } from '../Observable';\nimport { subscribeTo } from '../util/subscribeTo';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated use {@link scheduled} instead. */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * ### Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * ---\n *\n * ### Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * ---\n *\n * ### With async scheduler\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // start\n * // end\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param {ObservableInput<T>} A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param {SchedulerLike} An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return {Observable<T>}\n * @name from\n * @owner Observable\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  if (!scheduler) {\n    if (input instanceof Observable) {\n      return input;\n    }\n    return new Observable<T>(subscribeTo(input));\n  } else {\n    return scheduled(input, scheduler);\n  }\n}\n","import { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { Subscriber } from '../Subscriber';\nimport { subscribeTo } from './subscribeTo';\nimport { Observable } from '../Observable';\n\nexport function subscribeToResult<T, R>(\n  outerSubscriber: OuterSubscriber<T, R>,\n  result: any,\n  outerValue: undefined,\n  outerIndex: undefined,\n  innerSubscriber: InnerSubscriber<T, R>\n): Subscription | undefined;\n\nexport function subscribeToResult<T, R>(\n  outerSubscriber: OuterSubscriber<T, R>,\n  result: any,\n  outerValue?: T,\n  outerIndex?: number\n): Subscription | undefined;\n\nexport function subscribeToResult<T, R>(\n  outerSubscriber: OuterSubscriber<T, R>,\n  result: any,\n  outerValue?: T,\n  outerIndex?: number,\n  innerSubscriber: Subscriber<R> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex)\n): Subscription | undefined {\n  if (innerSubscriber.closed) {\n    return undefined;\n  }\n  if (result instanceof Observable) {\n    return result.subscribe(innerSubscriber);\n  }\n  return subscribeTo(result)(innerSubscriber) as Subscription;\n}\n","\nimport { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { map, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map((ev) => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n * ```ts\n * import { fromEvent, interval } from 'rxjs';\n * import { take, map, mergeAll } from 'rxjs/operators';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map((ev) => interval(1000).pipe(take(10))),\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nexport function mergeAll<T>(concurrent: number = Number.POSITIVE_INFINITY): OperatorFunction<ObservableInput<T>, T> {\n  return mergeMap(identity, concurrent);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"rxjs\" />\n\nimport {Subject, Subscription} from 'rxjs';\n\n/**\n * Use in components with the `@Output` directive to emit custom events\n * synchronously or asynchronously, and register handlers for those events\n * by subscribing to an instance.\n *\n * @usageNotes\n *\n * Extends\n * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)\n * for Angular by adding the `emit()` method.\n *\n * In the following example, a component defines two output properties\n * that create event emitters. When the title is clicked, the emitter\n * emits an open or close event to toggle the current visibility state.\n *\n * ```html\n * @Component({\n *   selector: 'zippy',\n *   template: `\n *   <div class=\"zippy\">\n *     <div (click)=\"toggle()\">Toggle</div>\n *     <div [hidden]=\"!visible\">\n *       <ng-content></ng-content>\n *     </div>\n *  </div>`})\n * export class Zippy {\n *   visible: boolean = true;\n *   @Output() open: EventEmitter<any> = new EventEmitter();\n *   @Output() close: EventEmitter<any> = new EventEmitter();\n *\n *   toggle() {\n *     this.visible = !this.visible;\n *     if (this.visible) {\n *       this.open.emit(null);\n *     } else {\n *       this.close.emit(null);\n *     }\n *   }\n * }\n * ```\n *\n * Access the event object with the `$event` argument passed to the output event\n * handler:\n *\n * ```html\n * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n * ```\n *\n * @see [Observables in Angular](guide/observables-in-angular)\n * @publicApi\n */\nexport interface EventEmitter<T> extends Subject<T> {\n  /**\n   * @internal\n   */\n  __isAsync: boolean;\n\n  /**\n   * Creates an instance of this class that can\n   * deliver events synchronously or asynchronously.\n   *\n   * @param [isAsync=false] When true, deliver events asynchronously.\n   *\n   */\n  new(isAsync?: boolean): EventEmitter<T>;\n\n  /**\n   * Emits an event containing a given value.\n   * @param value The value to emit.\n   */\n  emit(value?: T): void;\n  /**\n   * Registers handlers for events emitted by this instance.\n   * @param generatorOrNext When supplied, a custom handler for emitted events.\n   * @param error When supplied, a custom handler for an error notification\n   * from this emitter.\n   * @param complete When supplied, a custom handler for a completion\n   * notification from this emitter.\n   */\n  subscribe(generatorOrNext?: any, error?: any, complete?: any): Subscription;\n}\n\nclass EventEmitter_ extends Subject<any> {\n  __isAsync: boolean;  // tslint:disable-line\n\n  constructor(isAsync: boolean = false) {\n    super();\n    this.__isAsync = isAsync;\n  }\n\n  emit(value?: any) {\n    super.next(value);\n  }\n\n  subscribe(generatorOrNext?: any, error?: any, complete?: any): Subscription {\n    let schedulerFn: (t: any) => any;\n    let errorFn = (err: any): any => null;\n    let completeFn = (): any => null;\n\n    if (generatorOrNext && typeof generatorOrNext === 'object') {\n      schedulerFn = this.__isAsync ? (value: any) => {\n        setTimeout(() => generatorOrNext.next(value));\n      } : (value: any) => {\n        generatorOrNext.next(value);\n      };\n\n      if (generatorOrNext.error) {\n        errorFn = this.__isAsync ? (err) => {\n          setTimeout(() => generatorOrNext.error(err));\n        } : (err) => {\n          generatorOrNext.error(err);\n        };\n      }\n\n      if (generatorOrNext.complete) {\n        completeFn = this.__isAsync ? () => {\n          setTimeout(() => generatorOrNext.complete());\n        } : () => {\n          generatorOrNext.complete();\n        };\n      }\n    } else {\n      schedulerFn = this.__isAsync ? (value: any) => {\n        setTimeout(() => generatorOrNext(value));\n      } : (value: any) => {\n        generatorOrNext(value);\n      };\n\n      if (error) {\n        errorFn = this.__isAsync ? (err) => {\n          setTimeout(() => error(err));\n        } : (err) => {\n          error(err);\n        };\n      }\n\n      if (complete) {\n        completeFn = this.__isAsync ? () => {\n          setTimeout(() => complete());\n        } : () => {\n          complete();\n        };\n      }\n    }\n\n    const sink = super.subscribe(schedulerFn, errorFn, completeFn);\n\n    if (generatorOrNext instanceof Subscription) {\n      generatorOrNext.add(sink);\n    }\n\n    return sink;\n  }\n}\n\n/**\n * @publicApi\n */\nexport const EventEmitter: {\n  new (isAsync?: boolean): EventEmitter<any>; new<T>(isAsync?: boolean): EventEmitter<T>;\n  readonly prototype: EventEmitter<any>;\n} = EventEmitter_ as any;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, Injectable, InjectionToken, Optional} from './di';\nimport {isPromise} from './util/lang';\nimport {noop} from './util/noop';\n\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that you can use to provide\n * one or more initialization functions.\n *\n * The provided functions are injected at application startup and executed during\n * app initialization. If any of these functions returns a Promise, initialization\n * does not complete until the Promise is resolved.\n *\n * You can, for example, create a factory function that loads language data\n * or an external configuration, and provide that function to the `APP_INITIALIZER` token.\n * The function is executed during the application bootstrap process,\n * and the needed data is available on startup.\n *\n * @see `ApplicationInitStatus`\n *\n * @publicApi\n */\nexport const APP_INITIALIZER = new InjectionToken<Array<() => void>>('Application Initializer');\n\n/**\n * A class that reflects the state of running {@link APP_INITIALIZER} functions.\n *\n * @publicApi\n */\n@Injectable()\nexport class ApplicationInitStatus {\n  private resolve = noop;\n  private reject = noop;\n  private initialized = false;\n  public readonly donePromise: Promise<any>;\n  public readonly done = false;\n\n  constructor(@Inject(APP_INITIALIZER) @Optional() private appInits: (() => any)[]) {\n    this.donePromise = new Promise((res, rej) => {\n      this.resolve = res;\n      this.reject = rej;\n    });\n  }\n\n  /** @internal */\n  runInitializers() {\n    if (this.initialized) {\n      return;\n    }\n\n    const asyncInitPromises: Promise<any>[] = [];\n\n    const complete = () => {\n      (this as {done: boolean}).done = true;\n      this.resolve();\n    };\n\n    if (this.appInits) {\n      for (let i = 0; i < this.appInits.length; i++) {\n        const initResult = this.appInits[i]();\n        if (isPromise(initResult)) {\n          asyncInitPromises.push(initResult);\n        }\n      }\n    }\n\n    Promise.all(asyncInitPromises)\n        .then(() => {\n          complete();\n        })\n        .catch(e => {\n          this.reject(e);\n        });\n\n    if (asyncInitPromises.length === 0) {\n      complete();\n    }\n    this.initialized = true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from './di';\nimport {ComponentRef} from './linker/component_factory';\n\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") representing a unique string ID, used\n * primarily for prefixing application attributes and CSS styles when\n * {@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.\n *\n * BY default, the value is randomly generated and assigned to the application by Angular.\n * To provide a custom ID value, use a DI provider <!-- TODO: provider --> to configure\n * the root {@link Injector} that uses this token.\n *\n * @publicApi\n */\nexport const APP_ID = new InjectionToken<string>('AppId');\n\nexport function _appIdRandomProviderFactory() {\n  return `${_randomChar()}${_randomChar()}${_randomChar()}`;\n}\n\n/**\n * Providers that generate a random `APP_ID_TOKEN`.\n * @publicApi\n */\nexport const APP_ID_RANDOM_PROVIDER = {\n  provide: APP_ID,\n  useFactory: _appIdRandomProviderFactory,\n  deps: <any[]>[],\n};\n\nfunction _randomChar(): string {\n  return String.fromCharCode(97 + Math.floor(Math.random() * 25));\n}\n\n/**\n * A function that is executed when a platform is initialized.\n * @publicApi\n */\nexport const PLATFORM_INITIALIZER = new InjectionToken<Array<() => void>>('Platform Initializer');\n\n/**\n * A token that indicates an opaque platform ID.\n * @publicApi\n */\nexport const PLATFORM_ID = new InjectionToken<Object>('Platform ID');\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that provides a set of callbacks to\n * be called for every component that is bootstrapped.\n *\n * Each callback must take a `ComponentRef` instance and return nothing.\n *\n * `(componentRef: ComponentRef) => void`\n *\n * @publicApi\n */\nexport const APP_BOOTSTRAP_LISTENER =\n    new InjectionToken<Array<(compRef: ComponentRef<any>) => void>>('appBootstrapListener');\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates the root directory of\n * the application\n * @publicApi\n */\nexport const PACKAGE_ROOT_URL = new InjectionToken<string>('Application Packages Root URL');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../di/injection_token';\n\n/**\n * Provide this token to set the locale of your application.\n * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,\n * DecimalPipe and PercentPipe) and by ICU expressions.\n *\n * See the [i18n guide](guide/i18n#setting-up-locale) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { LOCALE_ID } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport const LOCALE_ID = new InjectionToken<string>('LocaleId');\n\n/**\n * Provide this token to set the default currency code your application uses for\n * CurrencyPipe when there is no currency code passed into it. This is only used by\n * CurrencyPipe and has no relation to locale currency. Defaults to USD if not configured.\n *\n * See the [i18n guide](guide/i18n#setting-up-locale) for more information.\n *\n * <div class=\"alert is-helpful\">\n *\n * **Deprecation notice:**\n *\n * The default currency code is currently always `USD` but this is deprecated from v9.\n *\n * **In v10 the default currency code will be taken from the current locale.**\n *\n * If you need the previous behavior then set it by creating a `DEFAULT_CURRENCY_CODE` provider in\n * your application `NgModule`:\n *\n * ```ts\n * {provide: DEFAULT_CURRENCY_CODE, useValue: 'USD'}\n * ```\n *\n * </div>\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: DEFAULT_CURRENCY_CODE, useValue: 'EUR' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport const DEFAULT_CURRENCY_CODE = new InjectionToken<string>('DefaultCurrencyCode');\n\n/**\n * Use this token at bootstrap to provide the content of your translation file (`xtb`,\n * `xlf` or `xlf2`) when you want to translate your application in another language.\n *\n * See the [i18n guide](guide/i18n#merge) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { TRANSLATIONS } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * // content of your translation file\n * const translations = '....';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: TRANSLATIONS, useValue: translations }]\n * });\n * ```\n *\n * @publicApi\n */\nexport const TRANSLATIONS = new InjectionToken<string>('Translations');\n\n/**\n * Provide this token at bootstrap to set the format of your {@link TRANSLATIONS}: `xtb`,\n * `xlf` or `xlf2`.\n *\n * See the [i18n guide](guide/i18n#merge) for more information.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * import { TRANSLATIONS_FORMAT } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]\n * });\n * ```\n *\n * @publicApi\n */\nexport const TRANSLATIONS_FORMAT = new InjectionToken<string>('TranslationsFormat');\n\n/**\n * Use this enum at bootstrap as an option of `bootstrapModule` to define the strategy\n * that the compiler should use in case of missing translations:\n * - Error: throw if you have missing translations.\n * - Warning (default): show a warning in the console and/or shell.\n * - Ignore: do nothing.\n *\n * See the [i18n guide](guide/i18n#missing-translation) for more information.\n *\n * @usageNotes\n * ### Example\n * ```typescript\n * import { MissingTranslationStrategy } from '@angular/core';\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n * import { AppModule } from './app/app.module';\n *\n * platformBrowserDynamic().bootstrapModule(AppModule, {\n *   missingTranslation: MissingTranslationStrategy.Error\n * });\n * ```\n *\n * @publicApi\n */\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../di/injectable';\nimport {InjectionToken} from '../di/injection_token';\nimport {StaticProvider} from '../di/interface/provider';\nimport {MissingTranslationStrategy} from '../i18n/tokens';\nimport {Type} from '../interface/type';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {ComponentFactory as ComponentFactoryR3} from '../render3/component_ref';\nimport {getComponentDef, getNgModuleDef} from '../render3/definition';\nimport {NgModuleFactory as NgModuleFactoryR3} from '../render3/ng_module_ref';\nimport {maybeUnwrapFn} from '../render3/util/misc_utils';\n\nimport {ComponentFactory} from './component_factory';\nimport {NgModuleFactory} from './ng_module_factory';\n\n\n\n/**\n * Combination of NgModuleFactory and ComponentFactorys.\n *\n * @publicApi\n */\nexport class ModuleWithComponentFactories<T> {\n  constructor(\n      public ngModuleFactory: NgModuleFactory<T>,\n      public componentFactories: ComponentFactory<any>[]) {}\n}\n\n\nfunction _throwError() {\n  throw new Error(`Runtime compiler is not loaded`);\n}\n\nconst Compiler_compileModuleSync__PRE_R3__: <T>(moduleType: Type<T>) => NgModuleFactory<T> =\n    _throwError as any;\nexport const Compiler_compileModuleSync__POST_R3__: <T>(moduleType: Type<T>) =>\n    NgModuleFactory<T> = function<T>(moduleType: Type<T>): NgModuleFactory<T> {\n  return new NgModuleFactoryR3(moduleType);\n};\nconst Compiler_compileModuleSync = Compiler_compileModuleSync__PRE_R3__;\n\nconst Compiler_compileModuleAsync__PRE_R3__: <T>(moduleType: Type<T>) =>\n    Promise<NgModuleFactory<T>> = _throwError as any;\nexport const Compiler_compileModuleAsync__POST_R3__: <T>(moduleType: Type<T>) =>\n    Promise<NgModuleFactory<T>> = function<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>> {\n  return Promise.resolve(Compiler_compileModuleSync__POST_R3__(moduleType));\n};\nconst Compiler_compileModuleAsync = Compiler_compileModuleAsync__PRE_R3__;\n\nconst Compiler_compileModuleAndAllComponentsSync__PRE_R3__: <T>(moduleType: Type<T>) =>\n    ModuleWithComponentFactories<T> = _throwError as any;\nexport const Compiler_compileModuleAndAllComponentsSync__POST_R3__: <T>(moduleType: Type<T>) =>\n    ModuleWithComponentFactories<T> = function<T>(moduleType: Type<T>):\n        ModuleWithComponentFactories<T> {\n  const ngModuleFactory = Compiler_compileModuleSync__POST_R3__(moduleType);\n  const moduleDef = getNgModuleDef(moduleType)!;\n  const componentFactories =\n      maybeUnwrapFn(moduleDef.declarations)\n          .reduce((factories: ComponentFactory<any>[], declaration: Type<any>) => {\n            const componentDef = getComponentDef(declaration);\n            componentDef && factories.push(new ComponentFactoryR3(componentDef));\n            return factories;\n          }, [] as ComponentFactory<any>[]);\n  return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n};\nconst Compiler_compileModuleAndAllComponentsSync =\n    Compiler_compileModuleAndAllComponentsSync__PRE_R3__;\n\nconst Compiler_compileModuleAndAllComponentsAsync__PRE_R3__: <T>(moduleType: Type<T>) =>\n    Promise<ModuleWithComponentFactories<T>> = _throwError as any;\nexport const Compiler_compileModuleAndAllComponentsAsync__POST_R3__: <T>(moduleType: Type<T>) =>\n    Promise<ModuleWithComponentFactories<T>> = function<T>(moduleType: Type<T>):\n        Promise<ModuleWithComponentFactories<T>> {\n  return Promise.resolve(Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType));\n};\nconst Compiler_compileModuleAndAllComponentsAsync =\n    Compiler_compileModuleAndAllComponentsAsync__PRE_R3__;\n\n/**\n * Low-level service for running the angular compiler during runtime\n * to create {@link ComponentFactory}s, which\n * can later be used to create and render a Component instance.\n *\n * Each `@NgModule` provides an own `Compiler` to its injector,\n * that will use the directives/pipes of the ng module for compilation\n * of components.\n *\n * @publicApi\n */\n@Injectable()\nexport class Compiler {\n  /**\n   * Compiles the given NgModule and all of its components. All templates of the components listed\n   * in `entryComponents` have to be inlined.\n   */\n  compileModuleSync: <T>(moduleType: Type<T>) => NgModuleFactory<T> = Compiler_compileModuleSync;\n\n  /**\n   * Compiles the given NgModule and all of its components\n   */\n  compileModuleAsync:\n      <T>(moduleType: Type<T>) => Promise<NgModuleFactory<T>> = Compiler_compileModuleAsync;\n\n  /**\n   * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.\n   */\n  compileModuleAndAllComponentsSync: <T>(moduleType: Type<T>) => ModuleWithComponentFactories<T> =\n      Compiler_compileModuleAndAllComponentsSync;\n\n  /**\n   * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.\n   */\n  compileModuleAndAllComponentsAsync: <T>(moduleType: Type<T>) =>\n      Promise<ModuleWithComponentFactories<T>> = Compiler_compileModuleAndAllComponentsAsync;\n\n  /**\n   * Clears all caches.\n   */\n  clearCache(): void {}\n\n  /**\n   * Clears the cache for the given component/ngModule.\n   */\n  clearCacheFor(type: Type<any>) {}\n\n  /**\n   * Returns the id for a given NgModule, if one is defined and known to the compiler.\n   */\n  getModuleId(moduleType: Type<any>): string|undefined {\n    return undefined;\n  }\n}\n\n/**\n * Options for creating a compiler\n *\n * @publicApi\n */\nexport type CompilerOptions = {\n  useJit?: boolean,\n  defaultEncapsulation?: ViewEncapsulation,\n  providers?: StaticProvider[],\n  missingTranslation?: MissingTranslationStrategy,\n  preserveWhitespaces?: boolean,\n};\n\n/**\n * Token to provide CompilerOptions in the platform injector.\n *\n * @publicApi\n */\nexport const COMPILER_OPTIONS = new InjectionToken<CompilerOptions[]>('compilerOptions');\n\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\nexport abstract class CompilerFactory {\n  abstract createCompiler(options?: CompilerOptions[]): Compiler;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst promise: Promise<any> = (() => Promise.resolve(0))();\n\ndeclare const Zone: any;\n\nexport function scheduleMicroTask(fn: Function) {\n  if (typeof Zone === 'undefined') {\n    // use promise to schedule microTask instead of use Zone\n    promise.then(() => {\n      fn && fn.apply(null, null);\n    });\n  } else {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '../event_emitter';\nimport {global} from '../util/global';\nimport {noop} from '../util/noop';\nimport {getNativeRequestAnimationFrame} from '../util/raf';\n\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport class NgZone {\n  readonly hasPendingMacrotasks: boolean = false;\n  readonly hasPendingMicrotasks: boolean = false;\n\n  /**\n   * Whether there are no outstanding microtasks or macrotasks.\n   */\n  readonly isStable: boolean = true;\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  readonly onUnstable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when there is no more microtasks enqueued in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  readonly onStable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies that an error has been delivered.\n   */\n  readonly onError: EventEmitter<any> = new EventEmitter(false);\n\n\n  constructor({\n    enableLongStackTrace = false,\n    shouldCoalesceEventChangeDetection = false,\n    shouldCoalesceRunChangeDetection = false\n  }) {\n    if (typeof Zone == 'undefined') {\n      throw new Error(`In this configuration Angular requires Zone.js`);\n    }\n\n    Zone.assertZonePatched();\n    const self = this as any as NgZonePrivate;\n    self._nesting = 0;\n\n    self._outer = self._inner = Zone.current;\n\n    if ((Zone as any)['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new ((Zone as any)['TaskTrackingZoneSpec'] as any));\n    }\n\n    if (enableLongStackTrace && (Zone as any)['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['longStackTraceZoneSpec']);\n    }\n    // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be\n    // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.\n    self.shouldCoalesceEventChangeDetection =\n        !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n    self.lastRequestAnimationFrameId = -1;\n    self.nativeRequestAnimationFrame = getNativeRequestAnimationFrame().nativeRequestAnimationFrame;\n    forkInnerZoneWithAngularBehavior(self);\n  }\n\n  static isInAngularZone(): boolean {\n    return Zone.current.get('isAngularZone') === true;\n  }\n\n  static assertInAngularZone(): void {\n    if (!NgZone.isInAngularZone()) {\n      throw new Error('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n\n  static assertNotInAngularZone(): void {\n    if (NgZone.isInAngularZone()) {\n      throw new Error('Expected to not be in Angular Zone, but it is!');\n    }\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.run(fn, applyThis, applyArgs);\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n   * returned by the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T {\n    const zone = (this as any as NgZonePrivate)._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs);\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.runGuarded(fn, applyThis, applyArgs);\n  }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n   * work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return (this as any as NgZonePrivate)._outer.run(fn);\n  }\n}\n\nconst EMPTY_PAYLOAD = {};\n\ninterface NgZonePrivate extends NgZone {\n  _outer: Zone;\n  _inner: Zone;\n  _nesting: number;\n  _hasPendingMicrotasks: boolean;\n\n  hasPendingMacrotasks: boolean;\n  hasPendingMicrotasks: boolean;\n  lastRequestAnimationFrameId: number;\n  isStable: boolean;\n  /**\n   * Optionally specify coalescing event change detections or not.\n   * Consider the following case.\n   *\n   * <div (click)=\"doSomething()\">\n   *   <button (click)=\"doSomethingElse()\"></button>\n   * </div>\n   *\n   * When button is clicked, because of the event bubbling, both\n   * event handlers will be called and 2 change detections will be\n   * triggered. We can coalesce such kind of events to trigger\n   * change detection only once.\n   *\n   * By default, this option will be false. So the events will not be\n   * coalesced and the change detection will be triggered multiple times.\n   * And if this option be set to true, the change detection will be\n   * triggered async by scheduling it in an animation frame. So in the case above,\n   * the change detection will only be trigged once.\n   */\n  shouldCoalesceEventChangeDetection: boolean;\n  /**\n   * Optionally specify if `NgZone#run()` method invocations should be coalesced\n   * into a single change detection.\n   *\n   * Consider the following case.\n   *\n   * for (let i = 0; i < 10; i ++) {\n   *   ngZone.run(() => {\n   *     // do something\n   *   });\n   * }\n   *\n   * This case triggers the change detection multiple times.\n   * With ngZoneRunCoalescing options, all change detections in an event loops trigger only once.\n   * In addition, the change detection executes in requestAnimation.\n   *\n   */\n  shouldCoalesceRunChangeDetection: boolean;\n\n  nativeRequestAnimationFrame: (callback: FrameRequestCallback) => number;\n\n  // Cache a  \"fake\" top eventTask so you don't need to schedule a new task every\n  // time you run a `checkStable`.\n  fakeTopEventTask: Task;\n}\n\nfunction checkStable(zone: NgZonePrivate) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\n\nfunction delayChangeDetectionForEvents(zone: NgZonePrivate) {\n  if (zone.lastRequestAnimationFrameId !== -1) {\n    return;\n  }\n  zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(global, () => {\n    // This is a work around for https://github.com/angular/angular/issues/36839.\n    // The core issue is that when event coalescing is enabled it is possible for microtasks\n    // to get flushed too early (As is the case with `Promise.then`) between the\n    // coalescing eventTasks.\n    //\n    // To workaround this we schedule a \"fake\" eventTask before we process the\n    // coalescing eventTasks. The benefit of this is that the \"fake\" container eventTask\n    //  will prevent the microtasks queue from getting drained in between the coalescing\n    // eventTask execution.\n    if (!zone.fakeTopEventTask) {\n      zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', () => {\n        zone.lastRequestAnimationFrameId = -1;\n        updateMicroTaskStatus(zone);\n        checkStable(zone);\n      }, undefined, () => {}, () => {});\n    }\n    zone.fakeTopEventTask.invoke();\n  });\n  updateMicroTaskStatus(zone);\n}\n\nfunction forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n  const delayChangeDetectionForEventsDelegate = () => {\n    delayChangeDetectionForEvents(zone);\n  };\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: <any>{'isAngularZone': true},\n    onInvokeTask:\n        (delegate: ZoneDelegate, current: Zone, target: Zone, task: Task, applyThis: any,\n         applyArgs: any): any => {\n          try {\n            onEnter(zone);\n            return delegate.invokeTask(target, task, applyThis, applyArgs);\n          } finally {\n            if ((zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask') ||\n                zone.shouldCoalesceRunChangeDetection) {\n              delayChangeDetectionForEventsDelegate();\n            }\n            onLeave(zone);\n          }\n        },\n\n    onInvoke:\n        (delegate: ZoneDelegate, current: Zone, target: Zone, callback: Function, applyThis: any,\n         applyArgs?: any[], source?: string): any => {\n          try {\n            onEnter(zone);\n            return delegate.invoke(target, callback, applyThis, applyArgs, source);\n          } finally {\n            if (zone.shouldCoalesceRunChangeDetection) {\n              delayChangeDetectionForEventsDelegate();\n            }\n            onLeave(zone);\n          }\n        },\n\n    onHasTask:\n        (delegate: ZoneDelegate, current: Zone, target: Zone, hasTaskState: HasTaskState) => {\n          delegate.hasTask(target, hasTaskState);\n          if (current === target) {\n            // We are only interested in hasTask events which originate from our zone\n            // (A child hasTask event is not interesting to us)\n            if (hasTaskState.change == 'microTask') {\n              zone._hasPendingMicrotasks = hasTaskState.microTask;\n              updateMicroTaskStatus(zone);\n              checkStable(zone);\n            } else if (hasTaskState.change == 'macroTask') {\n              zone.hasPendingMacrotasks = hasTaskState.macroTask;\n            }\n          }\n        },\n\n    onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\n\nfunction updateMicroTaskStatus(zone: NgZonePrivate) {\n  if (zone._hasPendingMicrotasks ||\n      ((zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) &&\n       zone.lastRequestAnimationFrameId !== -1)) {\n    zone.hasPendingMicrotasks = true;\n  } else {\n    zone.hasPendingMicrotasks = false;\n  }\n}\n\nfunction onEnter(zone: NgZonePrivate) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\n\nfunction onLeave(zone: NgZonePrivate) {\n  zone._nesting--;\n  checkStable(zone);\n}\n\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nexport class NoopNgZone implements NgZone {\n  readonly hasPendingMicrotasks: boolean = false;\n  readonly hasPendingMacrotasks: boolean = false;\n  readonly isStable: boolean = true;\n  readonly onUnstable: EventEmitter<any> = new EventEmitter();\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter();\n  readonly onStable: EventEmitter<any> = new EventEmitter();\n  readonly onError: EventEmitter<any> = new EventEmitter();\n\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n\n  runGuarded<T>(fn: (...args: any[]) => any, applyThis?: any, applyArgs?: any): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return fn();\n  }\n\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any, name?: string): T {\n    return fn.apply(applyThis, applyArgs);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {global} from './global';\n\nexport function getNativeRequestAnimationFrame() {\n  let nativeRequestAnimationFrame: (callback: FrameRequestCallback) => number =\n      global['requestAnimationFrame'];\n  let nativeCancelAnimationFrame: (handle: number) => void = global['cancelAnimationFrame'];\n  if (typeof Zone !== 'undefined' && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {\n    // use unpatched version of requestAnimationFrame(native delegate) if possible\n    // to avoid another Change detection\n    const unpatchedRequestAnimationFrame =\n        (nativeRequestAnimationFrame as any)[(Zone as any).__symbol__('OriginalDelegate')];\n    if (unpatchedRequestAnimationFrame) {\n      nativeRequestAnimationFrame = unpatchedRequestAnimationFrame;\n    }\n    const unpatchedCancelAnimationFrame =\n        (nativeCancelAnimationFrame as any)[(Zone as any).__symbol__('OriginalDelegate')];\n    if (unpatchedCancelAnimationFrame) {\n      nativeCancelAnimationFrame = unpatchedCancelAnimationFrame;\n    }\n  }\n  return {nativeRequestAnimationFrame, nativeCancelAnimationFrame};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../di';\nimport {scheduleMicroTask} from '../util/microtask';\nimport {NgZone} from '../zone/ng_zone';\n\n/**\n * Testability API.\n * `declare` keyword causes tsickle to generate externs, so these methods are\n * not renamed by Closure Compiler.\n * @publicApi\n */\nexport declare interface PublicTestability {\n  isStable(): boolean;\n  whenStable(callback: Function, timeout?: number, updateCallback?: Function): void;\n  findProviders(using: any, provider: string, exactMatch: boolean): any[];\n}\n\n// Angular internal, not intended for public API.\nexport interface PendingMacrotask {\n  source: string;\n  creationLocation: Error;\n  runCount?: number;\n  data?: TaskData;\n}\n\nexport interface TaskData {\n  target?: XMLHttpRequest;\n  delay?: number;\n  isPeriodic?: boolean;\n}\n\n// Angular internal, not intended for public API.\nexport type DoneCallback = (didWork: boolean, tasks?: PendingMacrotask[]) => void;\nexport type UpdateCallback = (tasks: PendingMacrotask[]) => boolean;\n\ninterface WaitCallback {\n  // Needs to be 'any' - setTimeout returns a number according to ES6, but\n  // on NodeJS it returns a Timer.\n  timeoutId: any;\n  doneCb: DoneCallback;\n  updateCb?: UpdateCallback;\n}\n\n/**\n * The Testability service provides testing hooks that can be accessed from\n * the browser and by services such as Protractor. Each bootstrapped Angular\n * application on the page will have an instance of Testability.\n * @publicApi\n */\n@Injectable()\nexport class Testability implements PublicTestability {\n  private _pendingCount: number = 0;\n  private _isZoneStable: boolean = true;\n  /**\n   * Whether any work was done since the last 'whenStable' callback. This is\n   * useful to detect if this could have potentially destabilized another\n   * component while it is stabilizing.\n   * @internal\n   */\n  private _didWork: boolean = false;\n  private _callbacks: WaitCallback[] = [];\n\n  private taskTrackingZone: {macroTasks: Task[]}|null = null;\n\n  constructor(private _ngZone: NgZone) {\n    this._watchAngularEvents();\n    _ngZone.run(() => {\n      this.taskTrackingZone =\n          typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');\n    });\n  }\n\n  private _watchAngularEvents(): void {\n    this._ngZone.onUnstable.subscribe({\n      next: () => {\n        this._didWork = true;\n        this._isZoneStable = false;\n      }\n    });\n\n    this._ngZone.runOutsideAngular(() => {\n      this._ngZone.onStable.subscribe({\n        next: () => {\n          NgZone.assertNotInAngularZone();\n          scheduleMicroTask(() => {\n            this._isZoneStable = true;\n            this._runCallbacksIfReady();\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Increases the number of pending request\n   * @deprecated pending requests are now tracked with zones.\n   */\n  increasePendingRequestCount(): number {\n    this._pendingCount += 1;\n    this._didWork = true;\n    return this._pendingCount;\n  }\n\n  /**\n   * Decreases the number of pending request\n   * @deprecated pending requests are now tracked with zones\n   */\n  decreasePendingRequestCount(): number {\n    this._pendingCount -= 1;\n    if (this._pendingCount < 0) {\n      throw new Error('pending async requests below zero');\n    }\n    this._runCallbacksIfReady();\n    return this._pendingCount;\n  }\n\n  /**\n   * Whether an associated application is stable\n   */\n  isStable(): boolean {\n    return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;\n  }\n\n  private _runCallbacksIfReady(): void {\n    if (this.isStable()) {\n      // Schedules the call backs in a new frame so that it is always async.\n      scheduleMicroTask(() => {\n        while (this._callbacks.length !== 0) {\n          let cb = this._callbacks.pop()!;\n          clearTimeout(cb.timeoutId);\n          cb.doneCb(this._didWork);\n        }\n        this._didWork = false;\n      });\n    } else {\n      // Still not stable, send updates.\n      let pending = this.getPendingTasks();\n      this._callbacks = this._callbacks.filter((cb) => {\n        if (cb.updateCb && cb.updateCb(pending)) {\n          clearTimeout(cb.timeoutId);\n          return false;\n        }\n\n        return true;\n      });\n\n      this._didWork = true;\n    }\n  }\n\n  private getPendingTasks(): PendingMacrotask[] {\n    if (!this.taskTrackingZone) {\n      return [];\n    }\n\n    // Copy the tasks data so that we don't leak tasks.\n    return this.taskTrackingZone.macroTasks.map((t: Task) => {\n      return {\n        source: t.source,\n        // From TaskTrackingZone:\n        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40\n        creationLocation: (t as any).creationLocation as Error,\n        data: t.data\n      };\n    });\n  }\n\n  private addCallback(cb: DoneCallback, timeout?: number, updateCb?: UpdateCallback) {\n    let timeoutId: any = -1;\n    if (timeout && timeout > 0) {\n      timeoutId = setTimeout(() => {\n        this._callbacks = this._callbacks.filter((cb) => cb.timeoutId !== timeoutId);\n        cb(this._didWork, this.getPendingTasks());\n      }, timeout);\n    }\n    this._callbacks.push(<WaitCallback>{doneCb: cb, timeoutId: timeoutId, updateCb: updateCb});\n  }\n\n  /**\n   * Wait for the application to be stable with a timeout. If the timeout is reached before that\n   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\n   *\n   * @param doneCb The callback to invoke when Angular is stable or the timeout expires\n   *    whichever comes first.\n   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\n   *    specified, whenStable() will wait forever.\n   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\n   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\n   *    and no further updates will be issued.\n   */\n  whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void {\n    if (updateCb && !this.taskTrackingZone) {\n      throw new Error(\n          'Task tracking zone is required when passing an update callback to ' +\n          'whenStable(). Is \"zone.js/dist/task-tracking.js\" loaded?');\n    }\n    // These arguments are 'Function' above to keep the public API simple.\n    this.addCallback(doneCb as DoneCallback, timeout, updateCb as UpdateCallback);\n    this._runCallbacksIfReady();\n  }\n\n  /**\n   * Get the number of pending requests\n   * @deprecated pending requests are now tracked with zones\n   */\n  getPendingRequestCount(): number {\n    return this._pendingCount;\n  }\n\n  /**\n   * Find providers by name\n   * @param using The root element to search from\n   * @param provider The name of binding variable\n   * @param exactMatch Whether using exactMatch\n   */\n  findProviders(using: any, provider: string, exactMatch: boolean): any[] {\n    // TODO(juliemr): implement.\n    return [];\n  }\n}\n\n/**\n * A global registry of {@link Testability} instances for specific elements.\n * @publicApi\n */\n@Injectable()\nexport class TestabilityRegistry {\n  /** @internal */\n  _applications = new Map<any, Testability>();\n\n  constructor() {\n    _testabilityGetter.addToWindow(this);\n  }\n\n  /**\n   * Registers an application with a testability hook so that it can be tracked\n   * @param token token of application, root element\n   * @param testability Testability hook\n   */\n  registerApplication(token: any, testability: Testability) {\n    this._applications.set(token, testability);\n  }\n\n  /**\n   * Unregisters an application.\n   * @param token token of application, root element\n   */\n  unregisterApplication(token: any) {\n    this._applications.delete(token);\n  }\n\n  /**\n   * Unregisters all applications\n   */\n  unregisterAllApplications() {\n    this._applications.clear();\n  }\n\n  /**\n   * Get a testability hook associated with the application\n   * @param elem root element\n   */\n  getTestability(elem: any): Testability|null {\n    return this._applications.get(elem) || null;\n  }\n\n  /**\n   * Get all registered testabilities\n   */\n  getAllTestabilities(): Testability[] {\n    return Array.from(this._applications.values());\n  }\n\n  /**\n   * Get all registered applications(root elements)\n   */\n  getAllRootElements(): any[] {\n    return Array.from(this._applications.keys());\n  }\n\n  /**\n   * Find testability of a node in the Tree\n   * @param elem node\n   * @param findInAncestors whether finding testability in ancestors if testability was not found in\n   * current node\n   */\n  findTestabilityInTree(elem: Node, findInAncestors: boolean = true): Testability|null {\n    return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\n  }\n}\n\n/**\n * Adapter interface for retrieving the `Testability` service associated for a\n * particular context.\n *\n * @publicApi\n */\nexport interface GetTestability {\n  addToWindow(registry: TestabilityRegistry): void;\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null;\n}\n\nclass _NoopGetTestability implements GetTestability {\n  addToWindow(registry: TestabilityRegistry): void {}\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null {\n    return null;\n  }\n}\n\n/**\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\n * @publicApi\n */\nexport function setTestabilityGetter(getter: GetTestability): void {\n  _testabilityGetter = getter;\n}\n\nlet _testabilityGetter: GetTestability = new _NoopGetTestability();\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.\n *\n * For more information on how to run and debug tests with either Ivy or View Engine (legacy),\n * please see [BAZEL.md](./docs/BAZEL.md).\n */\n\nlet _devMode: boolean = true;\nlet _runModeLocked: boolean = false;\n\n\n/**\n * Returns whether Angular is in development mode. After called once,\n * the value is locked and won't change any more.\n *\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\n *\n * @publicApi\n */\nexport function isDevMode(): boolean {\n  _runModeLocked = true;\n  return _devMode;\n}\n\n/**\n * Disable Angular's development mode, which turns off assertions and other\n * checks within the framework.\n *\n * One important assertion this disables verifies that a change detection pass\n * does not result in additional changes to any bindings (also known as\n * unidirectional data flow).\n *\n * @publicApi\n */\nexport function enableProdMode(): void {\n  if (_runModeLocked) {\n    throw new Error('Cannot enable prod mode after platform setup.');\n  }\n  _devMode = false;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './util/ng_jit_mode';\n\nimport {merge, Observable, Observer, Subscription} from 'rxjs';\nimport {share} from 'rxjs/operators';\n\nimport {ApplicationInitStatus} from './application_init';\nimport {APP_BOOTSTRAP_LISTENER, PLATFORM_INITIALIZER} from './application_tokens';\nimport {getCompilerFacade} from './compiler/compiler_facade';\nimport {Console} from './console';\nimport {Injectable} from './di/injectable';\nimport {InjectionToken} from './di/injection_token';\nimport {Injector} from './di/injector';\nimport {StaticProvider} from './di/interface/provider';\nimport {INJECTOR_SCOPE} from './di/scope';\nimport {ErrorHandler} from './error_handler';\nimport {DEFAULT_LOCALE_ID} from './i18n/localization';\nimport {LOCALE_ID} from './i18n/tokens';\nimport {Type} from './interface/type';\nimport {ivyEnabled} from './ivy_switch';\nimport {COMPILER_OPTIONS, CompilerFactory, CompilerOptions} from './linker/compiler';\nimport {ComponentFactory, ComponentRef} from './linker/component_factory';\nimport {ComponentFactoryBoundToModule, ComponentFactoryResolver} from './linker/component_factory_resolver';\nimport {InternalNgModuleRef, NgModuleFactory, NgModuleRef} from './linker/ng_module_factory';\nimport {InternalViewRef, ViewRef} from './linker/view_ref';\nimport {isComponentResourceResolutionQueueEmpty, resolveComponentResources} from './metadata/resource_loading';\nimport {assertNgModuleType} from './render3/assert';\nimport {ComponentFactory as R3ComponentFactory} from './render3/component_ref';\nimport {setLocaleId} from './render3/i18n/i18n_locale_id';\nimport {setJitOptions} from './render3/jit/jit_options';\nimport {NgModuleFactory as R3NgModuleFactory} from './render3/ng_module_ref';\nimport {publishDefaultGlobalUtils as _publishDefaultGlobalUtils} from './render3/util/global_utils';\nimport {Testability, TestabilityRegistry} from './testability/testability';\nimport {isDevMode} from './util/is_dev_mode';\nimport {isPromise} from './util/lang';\nimport {scheduleMicroTask} from './util/microtask';\nimport {stringify} from './util/stringify';\nimport {NgZone, NoopNgZone} from './zone/ng_zone';\n\nlet _platform: PlatformRef;\n\nlet compileNgModuleFactory:\n    <M>(injector: Injector, options: CompilerOptions, moduleType: Type<M>) =>\n        Promise<NgModuleFactory<M>> = compileNgModuleFactory__PRE_R3__;\n\nfunction compileNgModuleFactory__PRE_R3__<M>(\n    injector: Injector, options: CompilerOptions,\n    moduleType: Type<M>): Promise<NgModuleFactory<M>> {\n  const compilerFactory: CompilerFactory = injector.get(CompilerFactory);\n  const compiler = compilerFactory.createCompiler([options]);\n  return compiler.compileModuleAsync(moduleType);\n}\n\nexport function compileNgModuleFactory__POST_R3__<M>(\n    injector: Injector, options: CompilerOptions,\n    moduleType: Type<M>): Promise<NgModuleFactory<M>> {\n  ngDevMode && assertNgModuleType(moduleType);\n\n  const moduleFactory = new R3NgModuleFactory(moduleType);\n\n  // All of the logic below is irrelevant for AOT-compiled code.\n  if (typeof ngJitMode !== 'undefined' && !ngJitMode) {\n    return Promise.resolve(moduleFactory);\n  }\n\n  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);\n\n  // Configure the compiler to use the provided options. This call may fail when multiple modules\n  // are bootstrapped with incompatible options, as a component can only be compiled according to\n  // a single set of options.\n  setJitOptions({\n    defaultEncapsulation: _lastDefined(compilerOptions.map(opts => opts.defaultEncapsulation)),\n    preserveWhitespaces: _lastDefined(compilerOptions.map(opts => opts.preserveWhitespaces)),\n  });\n\n  if (isComponentResourceResolutionQueueEmpty()) {\n    return Promise.resolve(moduleFactory);\n  }\n\n  const compilerProviders = _mergeArrays(compilerOptions.map(o => o.providers!));\n\n  // In case there are no compiler providers, we just return the module factory as\n  // there won't be any resource loader. This can happen with Ivy, because AOT compiled\n  // modules can be still passed through \"bootstrapModule\". In that case we shouldn't\n  // unnecessarily require the JIT compiler.\n  if (compilerProviders.length === 0) {\n    return Promise.resolve(moduleFactory);\n  }\n\n  const compiler = getCompilerFacade();\n  const compilerInjector = Injector.create({providers: compilerProviders});\n  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);\n  // The resource loader can also return a string while the \"resolveComponentResources\"\n  // always expects a promise. Therefore we need to wrap the returned value in a promise.\n  return resolveComponentResources(url => Promise.resolve(resourceLoader.get(url)))\n      .then(() => moduleFactory);\n}\n\n// the `window.ng` global utilities are only available in non-VE versions of\n// Angular. The function switch below will make sure that the code is not\n// included into Angular when PRE mode is active.\nexport function publishDefaultGlobalUtils__PRE_R3__() {}\nexport function publishDefaultGlobalUtils__POST_R3__() {\n  ngDevMode && _publishDefaultGlobalUtils();\n}\n\nlet publishDefaultGlobalUtils: () => any = publishDefaultGlobalUtils__PRE_R3__;\n\nlet isBoundToModule: <C>(cf: ComponentFactory<C>) => boolean = isBoundToModule__PRE_R3__;\n\nexport function isBoundToModule__PRE_R3__<C>(cf: ComponentFactory<C>): boolean {\n  return cf instanceof ComponentFactoryBoundToModule;\n}\n\nexport function isBoundToModule__POST_R3__<C>(cf: ComponentFactory<C>): boolean {\n  return (cf as R3ComponentFactory<C>).isBoundToModule;\n}\n\nexport const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken<boolean>('AllowMultipleToken');\n\n\n\n/**\n * A token for third-party components that can register themselves with NgProbe.\n *\n * @publicApi\n */\nexport class NgProbeToken {\n  constructor(public name: string, public token: any) {}\n}\n\n/**\n * Creates a platform.\n * Platforms must be created on launch using this function.\n *\n * @publicApi\n */\nexport function createPlatform(injector: Injector): PlatformRef {\n  if (_platform && !_platform.destroyed &&\n      !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\n    throw new Error(\n        'There can be only one platform. Destroy the previous one to create a new one.');\n  }\n  publishDefaultGlobalUtils();\n  _platform = injector.get(PlatformRef);\n  const inits = injector.get(PLATFORM_INITIALIZER, null);\n  if (inits) inits.forEach((init: any) => init());\n  return _platform;\n}\n\n/**\n * Creates a factory for a platform. Can be used to provide or override `Providers` specific to\n * your applciation's runtime needs, such as `PLATFORM_INITIALIZER` and `PLATFORM_ID`.\n * @param parentPlatformFactory Another platform factory to modify. Allows you to compose factories\n * to build up configurations that might be required by different libraries or parts of the\n * application.\n * @param name Identifies the new platform factory.\n * @param providers A set of dependency providers for platforms created with the new factory.\n *\n * @publicApi\n */\nexport function createPlatformFactory(\n    parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef)|null, name: string,\n    providers: StaticProvider[] = []): (extraProviders?: StaticProvider[]) => PlatformRef {\n  const desc = `Platform: ${name}`;\n  const marker = new InjectionToken(desc);\n  return (extraProviders: StaticProvider[] = []) => {\n    let platform = getPlatform();\n    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\n      if (parentPlatformFactory) {\n        parentPlatformFactory(\n            providers.concat(extraProviders).concat({provide: marker, useValue: true}));\n      } else {\n        const injectedProviders: StaticProvider[] =\n            providers.concat(extraProviders).concat({provide: marker, useValue: true}, {\n              provide: INJECTOR_SCOPE,\n              useValue: 'platform'\n            });\n        createPlatform(Injector.create({providers: injectedProviders, name: desc}));\n      }\n    }\n    return assertPlatform(marker);\n  };\n}\n\n/**\n * Checks that there is currently a platform that contains the given token as a provider.\n *\n * @publicApi\n */\nexport function assertPlatform(requiredToken: any): PlatformRef {\n  const platform = getPlatform();\n\n  if (!platform) {\n    throw new Error('No platform exists!');\n  }\n\n  if (!platform.injector.get(requiredToken, null)) {\n    throw new Error(\n        'A platform with a different configuration has been created. Please destroy it first.');\n  }\n\n  return platform;\n}\n\n/**\n * Destroys the current Angular platform and all Angular applications on the page.\n * Destroys all modules and listeners registered with the platform.\n *\n * @publicApi\n */\nexport function destroyPlatform(): void {\n  if (_platform && !_platform.destroyed) {\n    _platform.destroy();\n  }\n}\n\n/**\n * Returns the current platform.\n *\n * @publicApi\n */\nexport function getPlatform(): PlatformRef|null {\n  return _platform && !_platform.destroyed ? _platform : null;\n}\n\n/**\n * Provides additional options to the bootstraping process.\n *\n *\n */\nexport interface BootstrapOptions {\n  /**\n   * Optionally specify which `NgZone` should be used.\n   *\n   * - Provide your own `NgZone` instance.\n   * - `zone.js` - Use default `NgZone` which requires `Zone.js`.\n   * - `noop` - Use `NoopNgZone` which does nothing.\n   */\n  ngZone?: NgZone|'zone.js'|'noop';\n\n  /**\n   * Optionally specify coalescing event change detections or not.\n   * Consider the following case.\n   *\n   * <div (click)=\"doSomething()\">\n   *   <button (click)=\"doSomethingElse()\"></button>\n   * </div>\n   *\n   * When button is clicked, because of the event bubbling, both\n   * event handlers will be called and 2 change detections will be\n   * triggered. We can colesce such kind of events to only trigger\n   * change detection only once.\n   *\n   * By default, this option will be false. So the events will not be\n   * coalesced and the change detection will be triggered multiple times.\n   * And if this option be set to true, the change detection will be\n   * triggered async by scheduling a animation frame. So in the case above,\n   * the change detection will only be triggered once.\n   */\n  ngZoneEventCoalescing?: boolean;\n\n  /**\n   * Optionally specify if `NgZone#run()` method invocations should be coalesced\n   * into a single change detection.\n   *\n   * Consider the following case.\n   *\n   * for (let i = 0; i < 10; i ++) {\n   *   ngZone.run(() => {\n   *     // do something\n   *   });\n   * }\n   *\n   * This case triggers the change detection multiple times.\n   * With ngZoneRunCoalescing options, all change detections in an event loop trigger only once.\n   * In addition, the change detection executes in requestAnimation.\n   *\n   */\n  ngZoneRunCoalescing?: boolean;\n}\n\n/**\n * The Angular platform is the entry point for Angular on a web page.\n * Each page has exactly one platform. Services (such as reflection) which are common\n * to every Angular application running on the page are bound in its scope.\n * A page's platform is initialized implicitly when a platform is created using a platform\n * factory such as `PlatformBrowser`, or explicitly by calling the `createPlatform()` function.\n *\n * @publicApi\n */\n@Injectable()\nexport class PlatformRef {\n  private _modules: NgModuleRef<any>[] = [];\n  private _destroyListeners: Function[] = [];\n  private _destroyed: boolean = false;\n\n  /** @internal */\n  constructor(private _injector: Injector) {}\n\n  /**\n   * Creates an instance of an `@NgModule` for the given platform for offline compilation.\n   *\n   * @usageNotes\n   *\n   * The following example creates the NgModule for a browser platform.\n   *\n   * ```typescript\n   * my_module.ts:\n   *\n   * @NgModule({\n   *   imports: [BrowserModule]\n   * })\n   * class MyModule {}\n   *\n   * main.ts:\n   * import {MyModuleNgFactory} from './my_module.ngfactory';\n   * import {platformBrowser} from '@angular/platform-browser';\n   *\n   * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);\n   * ```\n   */\n  bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions):\n      Promise<NgModuleRef<M>> {\n    // Note: We need to create the NgZone _before_ we instantiate the module,\n    // as instantiating the module creates some providers eagerly.\n    // So we create a mini parent injector that just contains the new NgZone and\n    // pass that as parent to the NgModuleFactory.\n    const ngZoneOption = options ? options.ngZone : undefined;\n    const ngZoneEventCoalescing = (options && options.ngZoneEventCoalescing) || false;\n    const ngZoneRunCoalescing = (options && options.ngZoneRunCoalescing) || false;\n    const ngZone = getNgZone(ngZoneOption, {ngZoneEventCoalescing, ngZoneRunCoalescing});\n    const providers: StaticProvider[] = [{provide: NgZone, useValue: ngZone}];\n    // Note: Create ngZoneInjector within ngZone.run so that all of the instantiated services are\n    // created within the Angular zone\n    // Do not try to replace ngZone.run with ApplicationRef#run because ApplicationRef would then be\n    // created outside of the Angular zone.\n    return ngZone.run(() => {\n      const ngZoneInjector = Injector.create(\n          {providers: providers, parent: this.injector, name: moduleFactory.moduleType.name});\n      const moduleRef = <InternalNgModuleRef<M>>moduleFactory.create(ngZoneInjector);\n      const exceptionHandler: ErrorHandler|null = moduleRef.injector.get(ErrorHandler, null);\n      if (!exceptionHandler) {\n        throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');\n      }\n      ngZone!.runOutsideAngular(() => {\n        const subscription = ngZone!.onError.subscribe({\n          next: (error: any) => {\n            exceptionHandler.handleError(error);\n          }\n        });\n        moduleRef.onDestroy(() => {\n          remove(this._modules, moduleRef);\n          subscription.unsubscribe();\n        });\n      });\n      return _callAndReportToErrorHandler(exceptionHandler, ngZone!, () => {\n        const initStatus: ApplicationInitStatus = moduleRef.injector.get(ApplicationInitStatus);\n        initStatus.runInitializers();\n        return initStatus.donePromise.then(() => {\n          if (ivyEnabled) {\n            // If the `LOCALE_ID` provider is defined at bootstrap then we set the value for ivy\n            const localeId = moduleRef.injector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n            setLocaleId(localeId || DEFAULT_LOCALE_ID);\n          }\n          this._moduleDoBootstrap(moduleRef);\n          return moduleRef;\n        });\n      });\n    });\n  }\n\n  /**\n   * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * ```typescript\n   * @NgModule({\n   *   imports: [BrowserModule]\n   * })\n   * class MyModule {}\n   *\n   * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n   * ```\n   *\n   */\n  bootstrapModule<M>(\n      moduleType: Type<M>,\n      compilerOptions: (CompilerOptions&BootstrapOptions)|\n      Array<CompilerOptions&BootstrapOptions> = []): Promise<NgModuleRef<M>> {\n    const options = optionsReducer({}, compilerOptions);\n    return compileNgModuleFactory(this.injector, options, moduleType)\n        .then(moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));\n  }\n\n  private _moduleDoBootstrap(moduleRef: InternalNgModuleRef<any>): void {\n    const appRef = moduleRef.injector.get(ApplicationRef) as ApplicationRef;\n    if (moduleRef._bootstrapComponents.length > 0) {\n      moduleRef._bootstrapComponents.forEach(f => appRef.bootstrap(f));\n    } else if (moduleRef.instance.ngDoBootstrap) {\n      moduleRef.instance.ngDoBootstrap(appRef);\n    } else {\n      throw new Error(\n          `The module ${\n              stringify(\n                  moduleRef.instance\n                      .constructor)} was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ` +\n          `Please define one of these.`);\n    }\n    this._modules.push(moduleRef);\n  }\n\n  /**\n   * Registers a listener to be called when the platform is destroyed.\n   */\n  onDestroy(callback: () => void): void {\n    this._destroyListeners.push(callback);\n  }\n\n  /**\n   * Retrieves the platform {@link Injector}, which is the parent injector for\n   * every Angular application on the page and provides singleton providers.\n   */\n  get injector(): Injector {\n    return this._injector;\n  }\n\n  /**\n   * Destroys the current Angular platform and all Angular applications on the page.\n   * Destroys all modules and listeners registered with the platform.\n   */\n  destroy() {\n    if (this._destroyed) {\n      throw new Error('The platform has already been destroyed!');\n    }\n    this._modules.slice().forEach(module => module.destroy());\n    this._destroyListeners.forEach(listener => listener());\n    this._destroyed = true;\n  }\n\n  get destroyed() {\n    return this._destroyed;\n  }\n}\n\nfunction getNgZone(\n    ngZoneOption: NgZone|'zone.js'|'noop'|undefined,\n    extra?: {ngZoneEventCoalescing: boolean, ngZoneRunCoalescing: boolean}): NgZone {\n  let ngZone: NgZone;\n\n  if (ngZoneOption === 'noop') {\n    ngZone = new NoopNgZone();\n  } else {\n    ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) || new NgZone({\n               enableLongStackTrace: isDevMode(),\n               shouldCoalesceEventChangeDetection: !!extra?.ngZoneEventCoalescing,\n               shouldCoalesceRunChangeDetection: !!extra?.ngZoneRunCoalescing\n             });\n  }\n  return ngZone;\n}\n\nfunction _callAndReportToErrorHandler(\n    errorHandler: ErrorHandler, ngZone: NgZone, callback: () => any): any {\n  try {\n    const result = callback();\n    if (isPromise(result)) {\n      return result.catch((e: any) => {\n        ngZone.runOutsideAngular(() => errorHandler.handleError(e));\n        // rethrow as the exception handler might not do it\n        throw e;\n      });\n    }\n\n    return result;\n  } catch (e) {\n    ngZone.runOutsideAngular(() => errorHandler.handleError(e));\n    // rethrow as the exception handler might not do it\n    throw e;\n  }\n}\n\nfunction optionsReducer<T extends Object>(dst: any, objs: T|T[]): T {\n  if (Array.isArray(objs)) {\n    dst = objs.reduce(optionsReducer, dst);\n  } else {\n    dst = {...dst, ...(objs as any)};\n  }\n  return dst;\n}\n\n/**\n * A reference to an Angular application running on a page.\n *\n * @usageNotes\n *\n * {@a is-stable-examples}\n * ### isStable examples and caveats\n *\n * Note two important points about `isStable`, demonstrated in the examples below:\n * - the application will never be stable if you start any kind\n * of recurrent asynchronous task when the application starts\n * (for example for a polling process, started with a `setInterval`, a `setTimeout`\n * or using RxJS operators like `interval`);\n * - the `isStable` Observable runs outside of the Angular zone.\n *\n * Let's imagine that you start a recurrent task\n * (here incrementing a counter, using RxJS `interval`),\n * and at the same time subscribe to `isStable`.\n *\n * ```\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *      filter(stable => stable)\n *   ).subscribe(() => console.log('App is stable now');\n *   interval(1000).subscribe(counter => console.log(counter));\n * }\n * ```\n * In this example, `isStable` will never emit `true`,\n * and the trace \"App is stable now\" will never get logged.\n *\n * If you want to execute something when the app is stable,\n * you have to wait for the application to be stable\n * before starting your polling process.\n *\n * ```\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     tap(stable => console.log('App is stable now')),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => console.log(counter));\n * }\n * ```\n * In this example, the trace \"App is stable now\" will be logged\n * and then the counter starts incrementing every second.\n *\n * Note also that this Observable runs outside of the Angular zone,\n * which means that the code in the subscription\n * to this Observable will not trigger the change detection.\n *\n * Let's imagine that instead of logging the counter value,\n * you update a field of your component\n * and display it in its template.\n *\n * ```\n * constructor(appRef: ApplicationRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => this.value = counter);\n * }\n * ```\n * As the `isStable` Observable runs outside the zone,\n * the `value` field will be updated properly,\n * but the template will not be refreshed!\n *\n * You'll have to manually trigger the change detection to update the template.\n *\n * ```\n * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => {\n *     this.value = counter;\n *     cd.detectChanges();\n *   });\n * }\n * ```\n *\n * Or make the subscription callback run inside the zone.\n *\n * ```\n * constructor(appRef: ApplicationRef, zone: NgZone) {\n *   appRef.isStable.pipe(\n *     first(stable => stable),\n *     switchMap(() => interval(1000))\n *   ).subscribe(counter => zone.run(() => this.value = counter));\n * }\n * ```\n *\n * @publicApi\n */\n@Injectable()\nexport class ApplicationRef {\n  /** @internal */\n  private _bootstrapListeners: ((compRef: ComponentRef<any>) => void)[] = [];\n  private _views: InternalViewRef[] = [];\n  private _runningTick: boolean = false;\n  private _stable = true;\n  private _onMicrotaskEmptySubscription: Subscription;\n\n  /**\n   * Get a list of component types registered to this application.\n   * This list is populated even before the component is created.\n   */\n  public readonly componentTypes: Type<any>[] = [];\n\n  /**\n   * Get a list of components registered to this application.\n   */\n  public readonly components: ComponentRef<any>[] = [];\n\n  /**\n   * Returns an Observable that indicates when the application is stable or unstable.\n   *\n   * @see  [Usage notes](#is-stable-examples) for examples and caveats when using this API.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly isStable!: Observable<boolean>;\n\n  /** @internal */\n  constructor(\n      private _zone: NgZone, private _console: Console, private _injector: Injector,\n      private _exceptionHandler: ErrorHandler,\n      private _componentFactoryResolver: ComponentFactoryResolver,\n      private _initStatus: ApplicationInitStatus) {\n    this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({\n      next: () => {\n        this._zone.run(() => {\n          this.tick();\n        });\n      }\n    });\n\n    const isCurrentlyStable = new Observable<boolean>((observer: Observer<boolean>) => {\n      this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks &&\n          !this._zone.hasPendingMicrotasks;\n      this._zone.runOutsideAngular(() => {\n        observer.next(this._stable);\n        observer.complete();\n      });\n    });\n\n    const isStable = new Observable<boolean>((observer: Observer<boolean>) => {\n      // Create the subscription to onStable outside the Angular Zone so that\n      // the callback is run outside the Angular Zone.\n      let stableSub: Subscription;\n      this._zone.runOutsideAngular(() => {\n        stableSub = this._zone.onStable.subscribe(() => {\n          NgZone.assertNotInAngularZone();\n\n          // Check whether there are no pending macro/micro tasks in the next tick\n          // to allow for NgZone to update the state.\n          scheduleMicroTask(() => {\n            if (!this._stable && !this._zone.hasPendingMacrotasks &&\n                !this._zone.hasPendingMicrotasks) {\n              this._stable = true;\n              observer.next(true);\n            }\n          });\n        });\n      });\n\n      const unstableSub: Subscription = this._zone.onUnstable.subscribe(() => {\n        NgZone.assertInAngularZone();\n        if (this._stable) {\n          this._stable = false;\n          this._zone.runOutsideAngular(() => {\n            observer.next(false);\n          });\n        }\n      });\n\n      return () => {\n        stableSub.unsubscribe();\n        unstableSub.unsubscribe();\n      };\n    });\n\n    (this as {isStable: Observable<boolean>}).isStable =\n        merge(isCurrentlyStable, isStable.pipe(share()));\n  }\n\n  /**\n   * Bootstrap a new component at the root level of the application.\n   *\n   * @usageNotes\n   * ### Bootstrap process\n   *\n   * When bootstrapping a new root component into an application, Angular mounts the\n   * specified application component onto DOM elements identified by the componentType's\n   * selector and kicks off automatic change detection to finish initializing the component.\n   *\n   * Optionally, a component can be mounted onto a DOM element that does not match the\n   * componentType's selector.\n   *\n   * ### Example\n   * {@example core/ts/platform/platform.ts region='longform'}\n   */\n  bootstrap<C>(componentOrFactory: ComponentFactory<C>|Type<C>, rootSelectorOrNode?: string|any):\n      ComponentRef<C> {\n    if (!this._initStatus.done) {\n      throw new Error(\n          'Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');\n    }\n    let componentFactory: ComponentFactory<C>;\n    if (componentOrFactory instanceof ComponentFactory) {\n      componentFactory = componentOrFactory;\n    } else {\n      componentFactory =\n          this._componentFactoryResolver.resolveComponentFactory(componentOrFactory)!;\n    }\n    this.componentTypes.push(componentFactory.componentType);\n\n    // Create a factory associated with the current module if it's not bound to some other\n    const ngModule =\n        isBoundToModule(componentFactory) ? undefined : this._injector.get(NgModuleRef);\n    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;\n    const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);\n    const nativeElement = compRef.location.nativeElement;\n    const testability = compRef.injector.get(Testability, null);\n    const testabilityRegistry = testability && compRef.injector.get(TestabilityRegistry);\n    if (testability && testabilityRegistry) {\n      testabilityRegistry.registerApplication(nativeElement, testability);\n    }\n\n    compRef.onDestroy(() => {\n      this.detachView(compRef.hostView);\n      remove(this.components, compRef);\n      if (testabilityRegistry) {\n        testabilityRegistry.unregisterApplication(nativeElement);\n      }\n    });\n\n    this._loadComponent(compRef);\n    if (isDevMode()) {\n      this._console.log(\n          `Angular is running in development mode. Call enableProdMode() to enable production mode.`);\n    }\n    return compRef;\n  }\n\n  /**\n   * Invoke this method to explicitly process change detection and its side-effects.\n   *\n   * In development mode, `tick()` also performs a second change detection cycle to ensure that no\n   * further changes are detected. If additional changes are picked up during this second cycle,\n   * bindings in the app have side-effects that cannot be resolved in a single change detection\n   * pass.\n   * In this case, Angular throws an error, since an Angular application can only have one change\n   * detection pass during which all change detection must complete.\n   */\n  tick(): void {\n    if (this._runningTick) {\n      throw new Error('ApplicationRef.tick is called recursively');\n    }\n\n    try {\n      this._runningTick = true;\n      for (let view of this._views) {\n        view.detectChanges();\n      }\n      // Note that we have still left the `isDevMode()` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && isDevMode()) {\n        for (let view of this._views) {\n          view.checkNoChanges();\n        }\n      }\n    } catch (e) {\n      // Attention: Don't rethrow as it could cancel subscriptions to Observables!\n      this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e));\n    } finally {\n      this._runningTick = false;\n    }\n  }\n\n  /**\n   * Attaches a view so that it will be dirty checked.\n   * The view will be automatically detached when it is destroyed.\n   * This will throw if the view is already attached to a ViewContainer.\n   */\n  attachView(viewRef: ViewRef): void {\n    const view = (viewRef as InternalViewRef);\n    this._views.push(view);\n    view.attachToAppRef(this);\n  }\n\n  /**\n   * Detaches a view from dirty checking again.\n   */\n  detachView(viewRef: ViewRef): void {\n    const view = (viewRef as InternalViewRef);\n    remove(this._views, view);\n    view.detachFromAppRef();\n  }\n\n  private _loadComponent(componentRef: ComponentRef<any>): void {\n    this.attachView(componentRef.hostView);\n    this.tick();\n    this.components.push(componentRef);\n    // Get the listeners lazily to prevent DI cycles.\n    const listeners =\n        this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);\n    listeners.forEach((listener) => listener(componentRef));\n  }\n\n  /** @internal */\n  ngOnDestroy() {\n    this._views.slice().forEach((view) => view.destroy());\n    this._onMicrotaskEmptySubscription.unsubscribe();\n  }\n\n  /**\n   * Returns the number of attached views.\n   */\n  get viewCount() {\n    return this._views.length;\n  }\n}\n\nfunction remove<T>(list: T[], el: T): void {\n  const index = list.indexOf(el);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n}\n\nfunction _lastDefined<T>(args: T[]): T|undefined {\n  for (let i = args.length - 1; i >= 0; i--) {\n    if (args[i] !== undefined) {\n      return args[i];\n    }\n  }\n  return undefined;\n}\n\nfunction _mergeArrays(parts: any[][]): any[] {\n  const result: any[] = [];\n  parts.forEach((part) => part && result.push(...part));\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from './di';\n\n@Injectable()\nexport class Console {\n  log(message: string): void {\n    // tslint:disable-next-line:no-console\n    console.log(message);\n  }\n  // Note: for reporting errors use `DOM.logError()` as it is platform specific\n  warn(message: string): void {\n    // tslint:disable-next-line:no-console\n    console.warn(message);\n  }\n}\n","import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike} from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { mergeAll } from '../operators/mergeAll';\nimport { fromArray } from './fromArray';\n\n/* tslint:disable:max-line-length */\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T>(v1: ObservableInput<T>, scheduler: SchedulerLike): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T>(v1: ObservableInput<T>, concurrent: number, scheduler: SchedulerLike): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, scheduler: SchedulerLike): Observable<T | T2>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, scheduler: SchedulerLike): Observable<T | T2 | T3>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent: number, scheduler: SchedulerLike): Observable<T | T2 | T3 | T4 | T5 | T6>;\n\nexport function merge<T>(v1: ObservableInput<T>): Observable<T>;\nexport function merge<T>(v1: ObservableInput<T>, concurrent?: number): Observable<T>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>): Observable<T | T2>;\nexport function merge<T, T2>(v1: ObservableInput<T>, v2: ObservableInput<T2>, concurrent?: number): Observable<T | T2>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, concurrent?: number): Observable<T | T2 | T3>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, concurrent?: number): Observable<T | T2 | T3 | T4>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, concurrent?: number): Observable<T | T2 | T3 | T4 | T5>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T, T2, T3, T4, T5, T6>(v1: ObservableInput<T>, v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, concurrent?: number): Observable<T | T2 | T3 | T4 | T5 | T6>;\nexport function merge<T>(...observables: (ObservableInput<T> | number)[]): Observable<T>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T>(...observables: (ObservableInput<T> | SchedulerLike | number)[]): Observable<T>;\nexport function merge<T, R>(...observables: (ObservableInput<any> | number)[]): Observable<R>;\n/** @deprecated use {@link scheduled} and {@link mergeAll} (e.g. `scheduled([ob1, ob2, ob3], scheduled).pipe(mergeAll())*/\nexport function merge<T, R>(...observables: (ObservableInput<any> | SchedulerLike | number)[]): Observable<R>;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n * ### Merge together two Observables: 1s interval and clicks\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * ### Merge together 3 Observables, but only 2 run concurrently\n * ```ts\n * import { merge, interval } from 'rxjs';\n * import { take } from 'rxjs/operators';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits it's max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits it's max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param {...ObservableInput} observables Input Observables to merge together.\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n * Observables being subscribed to concurrently.\n * @param {SchedulerLike} [scheduler=null] The {@link SchedulerLike} to use for managing\n * concurrency of input Observables.\n * @return {Observable} an Observable that emits items that are the result of\n * every input Observable.\n * @static true\n * @name merge\n * @owner Observable\n */\nexport function merge<T, R>(...observables: Array<ObservableInput<any> | SchedulerLike | number>): Observable<R> {\n let concurrent = Number.POSITIVE_INFINITY;\n let scheduler: SchedulerLike = null;\n  let last: any = observables[observables.length - 1];\n  if (isScheduler(last)) {\n    scheduler = <SchedulerLike>observables.pop();\n    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n      concurrent = <number>observables.pop();\n    }\n  } else if (typeof last === 'number') {\n    concurrent = <number>observables.pop();\n  }\n\n  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {\n    return <Observable<R>>observables[0];\n  }\n\n  return mergeAll<R>(concurrent)(fromArray<any>(observables, scheduler));\n}\n","import { Subject } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable, connectableObservableDescriptor } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\n\n/* tslint:disable:max-line-length */\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T, O extends ObservableInput<any>>(subject: Subject<T>, selector: (shared: Observable<T>) => O): UnaryFunction<Observable<T>, ConnectableObservable<ObservedValueOf<O>>>;\nexport function multicast<T>(subjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\nexport function multicast<T, O extends ObservableInput<any>>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * ![](multicast.png)\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nexport function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> {\n  return function multicastOperatorFunction(source: Observable<T>): Observable<R> {\n    let subjectFactory: () => Subject<T>;\n    if (typeof subjectOrSubjectFactory === 'function') {\n      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;\n    } else {\n      subjectFactory = function subjectFactory() {\n        return <Subject<T>>subjectOrSubjectFactory;\n      };\n    }\n\n    if (typeof selector === 'function') {\n      return source.lift(new MulticastOperator(subjectFactory, selector));\n    }\n\n    const connectable: any = Object.create(source, connectableObservableDescriptor);\n    connectable.source = source;\n    connectable.subjectFactory = subjectFactory;\n\n    return <ConnectableObservable<R>> connectable;\n  };\n}\n\nexport class MulticastOperator<T, R> implements Operator<T, R> {\n  constructor(private subjectFactory: () => Subject<T>,\n              private selector: (source: Observable<T>) => Observable<R>) {\n  }\n  call(subscriber: Subscriber<R>, source: any): any {\n    const { selector } = this;\n    const subject = this.subjectFactory();\n    const subscription = selector(subject).subscribe(subscriber);\n    subscription.add(source.subscribe(subject));\n    return subscription;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createPlatformFactory, PlatformRef} from './application_ref';\nimport {PLATFORM_ID} from './application_tokens';\nimport {Console} from './console';\nimport {Injector, StaticProvider} from './di';\nimport {TestabilityRegistry} from './testability/testability';\n\nconst _CORE_PLATFORM_PROVIDERS: StaticProvider[] = [\n  // Set a default platform name for platforms that don't set it explicitly.\n  {provide: PLATFORM_ID, useValue: 'unknown'},\n  {provide: PlatformRef, deps: [Injector]},\n  {provide: TestabilityRegistry, deps: []},\n  {provide: Console, deps: []},\n];\n\n/**\n * This platform has to be included in any other platform\n *\n * @publicApi\n */\nexport const platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {APP_INITIALIZER, ApplicationInitStatus} from './application_init';\nimport {ApplicationRef} from './application_ref';\nimport {APP_ID_RANDOM_PROVIDER} from './application_tokens';\nimport {defaultIterableDiffers, defaultKeyValueDiffers, IterableDiffers, KeyValueDiffers} from './change_detection/change_detection';\nimport {Console} from './console';\nimport {Injector, StaticProvider} from './di';\nimport {Inject, Optional, SkipSelf} from './di/metadata';\nimport {ErrorHandler} from './error_handler';\nimport {DEFAULT_LOCALE_ID, USD_CURRENCY_CODE} from './i18n/localization';\nimport {DEFAULT_CURRENCY_CODE, LOCALE_ID} from './i18n/tokens';\nimport {ivyEnabled} from './ivy_switch';\nimport {ComponentFactoryResolver} from './linker';\nimport {Compiler} from './linker/compiler';\nimport {NgModule} from './metadata';\nimport {SCHEDULER} from './render3/component_ref';\nimport {setLocaleId} from './render3/i18n/i18n_locale_id';\nimport {NgZone} from './zone';\n\ndeclare const $localize: {locale?: string};\n\nexport function _iterableDiffersFactory() {\n  return defaultIterableDiffers;\n}\n\nexport function _keyValueDiffersFactory() {\n  return defaultKeyValueDiffers;\n}\n\nexport function _localeFactory(locale?: string): string {\n  locale = locale || getGlobalLocale();\n  if (ivyEnabled) {\n    setLocaleId(locale);\n  }\n  return locale;\n}\n\n/**\n * Work out the locale from the potential global properties.\n *\n * * Closure Compiler: use `goog.LOCALE`.\n * * Ivy enabled: use `$localize.locale`\n */\nexport function getGlobalLocale(): string {\n  if (typeof ngI18nClosureMode !== 'undefined' && ngI18nClosureMode &&\n      typeof goog !== 'undefined' && goog.LOCALE !== 'en') {\n    // * The default `goog.LOCALE` value is `en`, while Angular used `en-US`.\n    // * In order to preserve backwards compatibility, we use Angular default value over\n    //   Closure Compiler's one.\n    return goog.LOCALE;\n  } else {\n    // KEEP `typeof $localize !== 'undefined' && $localize.locale` IN SYNC WITH THE LOCALIZE\n    // COMPILE-TIME INLINER.\n    //\n    // * During compile time inlining of translations the expression will be replaced\n    //   with a string literal that is the current locale. Other forms of this expression are not\n    //   guaranteed to be replaced.\n    //\n    // * During runtime translation evaluation, the developer is required to set `$localize.locale`\n    //   if required, or just to provide their own `LOCALE_ID` provider.\n    return (ivyEnabled && typeof $localize !== 'undefined' && $localize.locale) ||\n        DEFAULT_LOCALE_ID;\n  }\n}\n\n/**\n * A built-in [dependency injection token](guide/glossary#di-token)\n * that is used to configure the root injector for bootstrapping.\n */\nexport const APPLICATION_MODULE_PROVIDERS: StaticProvider[] = [\n  {\n    provide: ApplicationRef,\n    useClass: ApplicationRef,\n    deps: [NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]\n  },\n  {provide: SCHEDULER, deps: [NgZone], useFactory: zoneSchedulerFactory},\n  {\n    provide: ApplicationInitStatus,\n    useClass: ApplicationInitStatus,\n    deps: [[new Optional(), APP_INITIALIZER]]\n  },\n  {provide: Compiler, useClass: Compiler, deps: []},\n  APP_ID_RANDOM_PROVIDER,\n  {provide: IterableDiffers, useFactory: _iterableDiffersFactory, deps: []},\n  {provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory, deps: []},\n  {\n    provide: LOCALE_ID,\n    useFactory: _localeFactory,\n    deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]\n  },\n  {provide: DEFAULT_CURRENCY_CODE, useValue: USD_CURRENCY_CODE},\n];\n\n/**\n * Schedule work at next available slot.\n *\n * In Ivy this is just `requestAnimationFrame`. For compatibility reasons when bootstrapped\n * using `platformRef.bootstrap` we need to use `NgZone.onStable` as the scheduling mechanism.\n * This overrides the scheduling mechanism in Ivy to `NgZone.onStable`.\n *\n * @param ngZone NgZone to use for scheduling.\n */\nexport function zoneSchedulerFactory(ngZone: NgZone): (fn: () => void) => void {\n  let queue: (() => void)[] = [];\n  ngZone.onStable.subscribe(() => {\n    while (queue.length) {\n      queue.pop()!();\n    }\n  });\n  return function(fn: () => void) {\n    queue.push(fn);\n  };\n}\n\n/**\n * Configures the root injector for an app with\n * providers of `@angular/core` dependencies that `ApplicationRef` needs\n * to bootstrap components.\n *\n * Re-exported by `BrowserModule`, which is included automatically in the root\n * `AppModule` when you create a new app with the CLI `new` command.\n *\n * @publicApi\n */\n@NgModule({providers: APPLICATION_MODULE_PROVIDERS})\nexport class ApplicationModule {\n  // Inject ApplicationRef to make it eager...\n  constructor(appRef: ApplicationRef) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nlet _DOM: DomAdapter = null!;\n\nexport function getDOM(): DomAdapter {\n  return _DOM;\n}\n\nexport function setDOM(adapter: DomAdapter) {\n  _DOM = adapter;\n}\n\nexport function setRootDomAdapter(adapter: DomAdapter) {\n  if (!_DOM) {\n    _DOM = adapter;\n  }\n}\n\n/* tslint:disable:requireParameterType */\n/**\n * Provides DOM operations in an environment-agnostic way.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport abstract class DomAdapter {\n  // Needs Domino-friendly test utility\n  abstract getProperty(el: Element, name: string): any;\n  abstract dispatchEvent(el: any, evt: any): any;\n\n  // Used by router\n  abstract log(error: any): any;\n  abstract logGroup(error: any): any;\n  abstract logGroupEnd(): any;\n\n  // Used by Meta\n  abstract remove(el: any): Node;\n  abstract createElement(tagName: any, doc?: any): HTMLElement;\n  abstract createHtmlDocument(): HTMLDocument;\n  abstract getDefaultDocument(): Document;\n\n  // Used by By.css\n  abstract isElementNode(node: any): boolean;\n\n  // Used by Testability\n  abstract isShadowRoot(node: any): boolean;\n\n  // Used by KeyEventsPlugin\n  abstract onAndCancel(el: any, evt: any, listener: any): Function;\n  abstract supportsDOMEvents(): boolean;\n\n  // Used by PlatformLocation and ServerEventManagerPlugin\n  abstract getGlobalEventTarget(doc: Document, target: string): any;\n\n  // Used by PlatformLocation\n  abstract getHistory(): History;\n  abstract getLocation():\n      any; /** This is the ambient Location definition, NOT Location from @angular/common.  */\n  abstract getBaseHref(doc: Document): string|null;\n  abstract resetBaseElement(): void;\n\n  // TODO: remove dependency in DefaultValueAccessor\n  abstract getUserAgent(): string;\n\n  // Used by AngularProfiler\n  abstract performanceNow(): number;\n\n  // Used by CookieXSRFStrategy\n  abstract supportsCookies(): boolean;\n  abstract getCookie(name: string): string|null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n/**\n * A DI Token representing the main rendering context. In a browser this is the DOM Document.\n *\n * Note: Document might not be available in the Application Context when Application and Rendering\n * Contexts are not the same (e.g. when running the application in a Web Worker).\n *\n * @publicApi\n */\nexport const DOCUMENT = new InjectionToken<Document>('DocumentToken');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵCurrencyIndex, ɵExtraLocaleDataIndex, ɵfindLocaleData, ɵgetLocaleCurrencyCode, ɵgetLocalePluralCase, ɵLocaleDataIndex} from '@angular/core';\n\nimport {CURRENCIES_EN, CurrenciesSymbols} from './currencies';\n\n\n/**\n * Format styles that can be used to represent numbers.\n * @see `getLocaleNumberFormat()`.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport enum NumberFormatStyle {\n  Decimal,\n  Percent,\n  Currency,\n  Scientific\n}\n\n/**\n * Plurality cases used for translating plurals to different languages.\n *\n * @see `NgPlural`\n * @see `NgPluralCase`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport enum Plural {\n  Zero = 0,\n  One = 1,\n  Two = 2,\n  Few = 3,\n  Many = 4,\n  Other = 5,\n}\n\n/**\n * Context-dependant translation forms for strings.\n * Typically the standalone version is for the nominative form of the word,\n * and the format version is used for the genitive case.\n * @see [CLDR website](http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles)\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport enum FormStyle {\n  Format,\n  Standalone\n}\n\n/**\n * String widths available for translations.\n * The specific character widths are locale-specific.\n * Examples are given for the word \"Sunday\" in English.\n *\n * @publicApi\n */\nexport enum TranslationWidth {\n  /** 1 character for `en-US`. For example: 'S' */\n  Narrow,\n  /** 3 characters for `en-US`. For example: 'Sun' */\n  Abbreviated,\n  /** Full length for `en-US`. For example: \"Sunday\" */\n  Wide,\n  /** 2 characters for `en-US`, For example: \"Su\" */\n  Short\n}\n\n/**\n * String widths available for date-time formats.\n * The specific character widths are locale-specific.\n * Examples are given for `en-US`.\n *\n * @see `getLocaleDateFormat()`\n * @see `getLocaleTimeFormat()``\n * @see `getLocaleDateTimeFormat()`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n * @publicApi\n */\nexport enum FormatWidth {\n  /**\n   * For `en-US`, 'M/d/yy, h:mm a'`\n   * (Example: `6/15/15, 9:03 AM`)\n   */\n  Short,\n  /**\n   * For `en-US`, `'MMM d, y, h:mm:ss a'`\n   * (Example: `Jun 15, 2015, 9:03:01 AM`)\n   */\n  Medium,\n  /**\n   * For `en-US`, `'MMMM d, y, h:mm:ss a z'`\n   * (Example: `June 15, 2015 at 9:03:01 AM GMT+1`)\n   */\n  Long,\n  /**\n   * For `en-US`, `'EEEE, MMMM d, y, h:mm:ss a zzzz'`\n   * (Example: `Monday, June 15, 2015 at 9:03:01 AM GMT+01:00`)\n   */\n  Full\n}\n\n/**\n * Symbols that can be used to replace placeholders in number patterns.\n * Examples are based on `en-US` values.\n *\n * @see `getLocaleNumberSymbol()`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport enum NumberSymbol {\n  /**\n   * Decimal separator.\n   * For `en-US`, the dot character.\n   * Example : 2,345`.`67\n   */\n  Decimal,\n  /**\n   * Grouping separator, typically for thousands.\n   * For `en-US`, the comma character.\n   * Example: 2`,`345.67\n   */\n  Group,\n  /**\n   * List-item separator.\n   * Example: \"one, two, and three\"\n   */\n  List,\n  /**\n   * Sign for percentage (out of 100).\n   * Example: 23.4%\n   */\n  PercentSign,\n  /**\n   * Sign for positive numbers.\n   * Example: +23\n   */\n  PlusSign,\n  /**\n   * Sign for negative numbers.\n   * Example: -23\n   */\n  MinusSign,\n  /**\n   * Computer notation for exponential value (n times a power of 10).\n   * Example: 1.2E3\n   */\n  Exponential,\n  /**\n   * Human-readable format of exponential.\n   * Example: 1.2x103\n   */\n  SuperscriptingExponent,\n  /**\n   * Sign for permille (out of 1000).\n   * Example: 23.4‰\n   */\n  PerMille,\n  /**\n   * Infinity, can be used with plus and minus.\n   * Example: ∞, +∞, -∞\n   */\n  Infinity,\n  /**\n   * Not a number.\n   * Example: NaN\n   */\n  NaN,\n  /**\n   * Symbol used between time units.\n   * Example: 10:52\n   */\n  TimeSeparator,\n  /**\n   * Decimal separator for currency values (fallback to `Decimal`).\n   * Example: $2,345.67\n   */\n  CurrencyDecimal,\n  /**\n   * Group separator for currency values (fallback to `Group`).\n   * Example: $2,345.67\n   */\n  CurrencyGroup\n}\n\n/**\n * The value for each day of the week, based on the `en-US` locale\n *\n * @publicApi\n */\nexport enum WeekDay {\n  Sunday = 0,\n  Monday,\n  Tuesday,\n  Wednesday,\n  Thursday,\n  Friday,\n  Saturday\n}\n\n/**\n * Retrieves the locale ID from the currently loaded locale.\n * The loaded locale could be, for example, a global one rather than a regional one.\n * @param locale A locale code, such as `fr-FR`.\n * @returns The locale code. For example, `fr`.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleId(locale: string): string {\n  return ɵfindLocaleData(locale)[ɵLocaleDataIndex.LocaleId];\n}\n\n/**\n * Retrieves day period strings for the given locale.\n *\n * @param locale A locale code for the locale format rules to use.\n * @param formStyle The required grammatical form.\n * @param width The required character width.\n * @returns An array of localized period strings. For example, `[AM, PM]` for `en-US`.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleDayPeriods(\n    locale: string, formStyle: FormStyle, width: TranslationWidth): Readonly<[string, string]> {\n  const data = ɵfindLocaleData(locale);\n  const amPmData = <[string, string][][]>[\n    data[ɵLocaleDataIndex.DayPeriodsFormat], data[ɵLocaleDataIndex.DayPeriodsStandalone]\n  ];\n  const amPm = getLastDefinedValue(amPmData, formStyle);\n  return getLastDefinedValue(amPm, width);\n}\n\n/**\n * Retrieves days of the week for the given locale, using the Gregorian calendar.\n *\n * @param locale A locale code for the locale format rules to use.\n * @param formStyle The required grammatical form.\n * @param width The required character width.\n * @returns An array of localized name strings.\n * For example,`[Sunday, Monday, ... Saturday]` for `en-US`.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleDayNames(\n    locale: string, formStyle: FormStyle, width: TranslationWidth): ReadonlyArray<string> {\n  const data = ɵfindLocaleData(locale);\n  const daysData =\n      <string[][][]>[data[ɵLocaleDataIndex.DaysFormat], data[ɵLocaleDataIndex.DaysStandalone]];\n  const days = getLastDefinedValue(daysData, formStyle);\n  return getLastDefinedValue(days, width);\n}\n\n/**\n * Retrieves months of the year for the given locale, using the Gregorian calendar.\n *\n * @param locale A locale code for the locale format rules to use.\n * @param formStyle The required grammatical form.\n * @param width The required character width.\n * @returns An array of localized name strings.\n * For example,  `[January, February, ...]` for `en-US`.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleMonthNames(\n    locale: string, formStyle: FormStyle, width: TranslationWidth): ReadonlyArray<string> {\n  const data = ɵfindLocaleData(locale);\n  const monthsData =\n      <string[][][]>[data[ɵLocaleDataIndex.MonthsFormat], data[ɵLocaleDataIndex.MonthsStandalone]];\n  const months = getLastDefinedValue(monthsData, formStyle);\n  return getLastDefinedValue(months, width);\n}\n\n/**\n * Retrieves Gregorian-calendar eras for the given locale.\n * @param locale A locale code for the locale format rules to use.\n * @param width The required character width.\n\n * @returns An array of localized era strings.\n * For example, `[AD, BC]` for `en-US`.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleEraNames(\n    locale: string, width: TranslationWidth): Readonly<[string, string]> {\n  const data = ɵfindLocaleData(locale);\n  const erasData = <[string, string][]>data[ɵLocaleDataIndex.Eras];\n  return getLastDefinedValue(erasData, width);\n}\n\n/**\n * Retrieves the first day of the week for the given locale.\n *\n * @param locale A locale code for the locale format rules to use.\n * @returns A day index number, using the 0-based week-day index for `en-US`\n * (Sunday = 0, Monday = 1, ...).\n * For example, for `fr-FR`, returns 1 to indicate that the first day is Monday.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleFirstDayOfWeek(locale: string): WeekDay {\n  const data = ɵfindLocaleData(locale);\n  return data[ɵLocaleDataIndex.FirstDayOfWeek];\n}\n\n/**\n * Range of week days that are considered the week-end for the given locale.\n *\n * @param locale A locale code for the locale format rules to use.\n * @returns The range of day values, `[startDay, endDay]`.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleWeekEndRange(locale: string): [WeekDay, WeekDay] {\n  const data = ɵfindLocaleData(locale);\n  return data[ɵLocaleDataIndex.WeekendRange];\n}\n\n/**\n * Retrieves a localized date-value formating string.\n *\n * @param locale A locale code for the locale format rules to use.\n * @param width The format type.\n * @returns The localized formating string.\n * @see `FormatWidth`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleDateFormat(locale: string, width: FormatWidth): string {\n  const data = ɵfindLocaleData(locale);\n  return getLastDefinedValue(data[ɵLocaleDataIndex.DateFormat], width);\n}\n\n/**\n * Retrieves a localized time-value formatting string.\n *\n * @param locale A locale code for the locale format rules to use.\n * @param width The format type.\n * @returns The localized formatting string.\n * @see `FormatWidth`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n\n * @publicApi\n */\nexport function getLocaleTimeFormat(locale: string, width: FormatWidth): string {\n  const data = ɵfindLocaleData(locale);\n  return getLastDefinedValue(data[ɵLocaleDataIndex.TimeFormat], width);\n}\n\n/**\n * Retrieves a localized date-time formatting string.\n *\n * @param locale A locale code for the locale format rules to use.\n * @param width The format type.\n * @returns The localized formatting string.\n * @see `FormatWidth`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleDateTimeFormat(locale: string, width: FormatWidth): string {\n  const data = ɵfindLocaleData(locale);\n  const dateTimeFormatData = <string[]>data[ɵLocaleDataIndex.DateTimeFormat];\n  return getLastDefinedValue(dateTimeFormatData, width);\n}\n\n/**\n * Retrieves a localized number symbol that can be used to replace placeholders in number formats.\n * @param locale The locale code.\n * @param symbol The symbol to localize.\n * @returns The character for the localized symbol.\n * @see `NumberSymbol`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleNumberSymbol(locale: string, symbol: NumberSymbol): string {\n  const data = ɵfindLocaleData(locale);\n  const res = data[ɵLocaleDataIndex.NumberSymbols][symbol];\n  if (typeof res === 'undefined') {\n    if (symbol === NumberSymbol.CurrencyDecimal) {\n      return data[ɵLocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];\n    } else if (symbol === NumberSymbol.CurrencyGroup) {\n      return data[ɵLocaleDataIndex.NumberSymbols][NumberSymbol.Group];\n    }\n  }\n  return res;\n}\n\n/**\n * Retrieves a number format for a given locale.\n *\n * Numbers are formatted using patterns, like `#,###.00`. For example, the pattern `#,###.00`\n * when used to format the number 12345.678 could result in \"12'345,678\". That would happen if the\n * grouping separator for your language is an apostrophe, and the decimal separator is a comma.\n *\n * <b>Important:</b> The characters `.` `,` `0` `#` (and others below) are special placeholders\n * that stand for the decimal separator, and so on, and are NOT real characters.\n * You must NOT \"translate\" the placeholders. For example, don't change `.` to `,` even though in\n * your language the decimal point is written with a comma. The symbols should be replaced by the\n * local equivalents, using the appropriate `NumberSymbol` for your language.\n *\n * Here are the special characters used in number patterns:\n *\n * | Symbol | Meaning |\n * |--------|---------|\n * | . | Replaced automatically by the character used for the decimal point. |\n * | , | Replaced by the \"grouping\" (thousands) separator. |\n * | 0 | Replaced by a digit (or zero if there aren't enough digits). |\n * | # | Replaced by a digit (or nothing if there aren't enough). |\n * | ¤ | Replaced by a currency symbol, such as $ or USD. |\n * | % | Marks a percent format. The % symbol may change position, but must be retained. |\n * | E | Marks a scientific format. The E symbol may change position, but must be retained. |\n * | ' | Special characters used as literal characters are quoted with ASCII single quotes. |\n *\n * @param locale A locale code for the locale format rules to use.\n * @param type The type of numeric value to be formatted (such as `Decimal` or `Currency`.)\n * @returns The localized format string.\n * @see `NumberFormatStyle`\n * @see [CLDR website](http://cldr.unicode.org/translation/number-patterns)\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleNumberFormat(locale: string, type: NumberFormatStyle): string {\n  const data = ɵfindLocaleData(locale);\n  return data[ɵLocaleDataIndex.NumberFormats][type];\n}\n\n/**\n * Retrieves the symbol used to represent the currency for the main country\n * corresponding to a given locale. For example, '$' for `en-US`.\n *\n * @param locale A locale code for the locale format rules to use.\n * @returns The localized symbol character,\n * or `null` if the main country cannot be determined.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleCurrencySymbol(locale: string): string|null {\n  const data = ɵfindLocaleData(locale);\n  return data[ɵLocaleDataIndex.CurrencySymbol] || null;\n}\n\n/**\n * Retrieves the name of the currency for the main country corresponding\n * to a given locale. For example, 'US Dollar' for `en-US`.\n * @param locale A locale code for the locale format rules to use.\n * @returns The currency name,\n * or `null` if the main country cannot be determined.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleCurrencyName(locale: string): string|null {\n  const data = ɵfindLocaleData(locale);\n  return data[ɵLocaleDataIndex.CurrencyName] || null;\n}\n\n/**\n * Retrieves the default currency code for the given locale.\n *\n * The default is defined as the first currency which is still in use.\n *\n * @param locale The code of the locale whose currency code we want.\n * @returns The code of the default currency for the given locale.\n *\n * @publicApi\n */\nexport function getLocaleCurrencyCode(locale: string): string|null {\n  return ɵgetLocaleCurrencyCode(locale);\n}\n\n/**\n * Retrieves the currency values for a given locale.\n * @param locale A locale code for the locale format rules to use.\n * @returns The currency values.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n */\nfunction getLocaleCurrencies(locale: string): {[code: string]: CurrenciesSymbols} {\n  const data = ɵfindLocaleData(locale);\n  return data[ɵLocaleDataIndex.Currencies];\n}\n\n/**\n * @alias core/ɵgetLocalePluralCase\n * @publicApi\n */\nexport const getLocalePluralCase: (locale: string) => ((value: number) => Plural) =\n    ɵgetLocalePluralCase;\n\nfunction checkFullData(data: any) {\n  if (!data[ɵLocaleDataIndex.ExtraData]) {\n    throw new Error(`Missing extra locale data for the locale \"${\n        data[ɵLocaleDataIndex\n                 .LocaleId]}\". Use \"registerLocaleData\" to load new data. See the \"I18n guide\" on angular.io to know more.`);\n  }\n}\n\n/**\n * Retrieves locale-specific rules used to determine which day period to use\n * when more than one period is defined for a locale.\n *\n * There is a rule for each defined day period. The\n * first rule is applied to the first day period and so on.\n * Fall back to AM/PM when no rules are available.\n *\n * A rule can specify a period as time range, or as a single time value.\n *\n * This functionality is only available when you have loaded the full locale data.\n * See the [\"I18n guide\"](guide/i18n#i18n-pipes).\n *\n * @param locale A locale code for the locale format rules to use.\n * @returns The rules for the locale, a single time value or array of *from-time, to-time*,\n * or null if no periods are available.\n *\n * @see `getLocaleExtraDayPeriods()`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleExtraDayPeriodRules(locale: string): (Time|[Time, Time])[] {\n  const data = ɵfindLocaleData(locale);\n  checkFullData(data);\n  const rules = data[ɵLocaleDataIndex.ExtraData][ɵExtraLocaleDataIndex.ExtraDayPeriodsRules] || [];\n  return rules.map((rule: string|[string, string]) => {\n    if (typeof rule === 'string') {\n      return extractTime(rule);\n    }\n    return [extractTime(rule[0]), extractTime(rule[1])];\n  });\n}\n\n/**\n * Retrieves locale-specific day periods, which indicate roughly how a day is broken up\n * in different languages.\n * For example, for `en-US`, periods are morning, noon, afternoon, evening, and midnight.\n *\n * This functionality is only available when you have loaded the full locale data.\n * See the [\"I18n guide\"](guide/i18n#i18n-pipes).\n *\n * @param locale A locale code for the locale format rules to use.\n * @param formStyle The required grammatical form.\n * @param width The required character width.\n * @returns The translated day-period strings.\n * @see `getLocaleExtraDayPeriodRules()`\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getLocaleExtraDayPeriods(\n    locale: string, formStyle: FormStyle, width: TranslationWidth): string[] {\n  const data = ɵfindLocaleData(locale);\n  checkFullData(data);\n  const dayPeriodsData = <string[][][]>[\n    data[ɵLocaleDataIndex.ExtraData][ɵExtraLocaleDataIndex.ExtraDayPeriodFormats],\n    data[ɵLocaleDataIndex.ExtraData][ɵExtraLocaleDataIndex.ExtraDayPeriodStandalone]\n  ];\n  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];\n  return getLastDefinedValue(dayPeriods, width) || [];\n}\n\n/**\n * Retrieves the writing direction of a specified locale\n * @param locale A locale code for the locale format rules to use.\n * @publicApi\n * @returns 'rtl' or 'ltr'\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n */\nexport function getLocaleDirection(locale: string): 'ltr'|'rtl' {\n  const data = ɵfindLocaleData(locale);\n  return data[ɵLocaleDataIndex.Directionality];\n}\n\n/**\n * Retrieves the first value that is defined in an array, going backwards from an index position.\n *\n * To avoid repeating the same data (as when the \"format\" and \"standalone\" forms are the same)\n * add the first value to the locale data arrays, and add other values only if they are different.\n *\n * @param data The data array to retrieve from.\n * @param index A 0-based index into the array to start from.\n * @returns The value immediately before the given index position.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nfunction getLastDefinedValue<T>(data: T[], index: number): T {\n  for (let i = index; i > -1; i--) {\n    if (typeof data[i] !== 'undefined') {\n      return data[i];\n    }\n  }\n  throw new Error('Locale data API: locale data undefined');\n}\n\n/**\n * Represents a time value with hours and minutes.\n *\n * @publicApi\n */\nexport type Time = {\n  hours: number,\n  minutes: number\n};\n\n/**\n * Extracts the hours and minutes from a string like \"15:45\"\n */\nfunction extractTime(time: string): Time {\n  const [h, m] = time.split(':');\n  return {hours: +h, minutes: +m};\n}\n\n\n\n/**\n * Retrieves the currency symbol for a given currency code.\n *\n * For example, for the default `en-US` locale, the code `USD` can\n * be represented by the narrow symbol `$` or the wide symbol `US$`.\n *\n * @param code The currency code.\n * @param format The format, `wide` or `narrow`.\n * @param locale A locale code for the locale format rules to use.\n *\n * @returns The symbol, or the currency code if no symbol is available.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getCurrencySymbol(code: string, format: 'wide'|'narrow', locale = 'en'): string {\n  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];\n  const symbolNarrow = currency[ɵCurrencyIndex.SymbolNarrow];\n\n  if (format === 'narrow' && typeof symbolNarrow === 'string') {\n    return symbolNarrow;\n  }\n\n  return currency[ɵCurrencyIndex.Symbol] || code;\n}\n\n// Most currencies have cents, that's why the default is 2\nconst DEFAULT_NB_OF_CURRENCY_DIGITS = 2;\n\n/**\n * Reports the number of decimal digits for a given currency.\n * The value depends upon the presence of cents in that particular currency.\n *\n * @param code The currency code.\n * @returns The number of decimal digits, typically 0 or 2.\n * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)\n *\n * @publicApi\n */\nexport function getNumberOfCurrencyDigits(code: string): number {\n  let digits;\n  const currency = CURRENCIES_EN[code];\n  if (currency) {\n    digits = currency[ɵCurrencyIndex.NbOfDigits];\n  }\n  return typeof digits === 'number' ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, Injectable, LOCALE_ID} from '@angular/core';\n\nimport {getLocalePluralCase, Plural} from './locale_data_api';\n\n\n/**\n * @publicApi\n */\nexport abstract class NgLocalization {\n  abstract getPluralCategory(value: any, locale?: string): string;\n}\n\n\n/**\n * Returns the plural category for a given value.\n * - \"=value\" when the case exists,\n * - the plural category otherwise\n */\nexport function getPluralCategory(\n    value: number, cases: string[], ngLocalization: NgLocalization, locale?: string): string {\n  let key = `=${value}`;\n\n  if (cases.indexOf(key) > -1) {\n    return key;\n  }\n\n  key = ngLocalization.getPluralCategory(value, locale);\n\n  if (cases.indexOf(key) > -1) {\n    return key;\n  }\n\n  if (cases.indexOf('other') > -1) {\n    return 'other';\n  }\n\n  throw new Error(`No plural message found for value \"${value}\"`);\n}\n\n/**\n * Returns the plural case based on the locale\n *\n * @publicApi\n */\n@Injectable()\nexport class NgLocaleLocalization extends NgLocalization {\n  constructor(@Inject(LOCALE_ID) protected locale: string) {\n    super();\n  }\n\n  getPluralCategory(value: any, locale?: string): string {\n    const plural = getLocalePluralCase(locale || this.locale)(value);\n\n    switch (plural) {\n      case Plural.Zero:\n        return 'zero';\n      case Plural.One:\n        return 'one';\n      case Plural.Two:\n        return 'two';\n      case Plural.Few:\n        return 'few';\n      case Plural.Many:\n        return 'many';\n      default:\n        return 'other';\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Directive, DoCheck, EmbeddedViewRef, Input, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDiffers, NgIterable, TemplateRef, TrackByFunction, ViewContainerRef} from '@angular/core';\n\n/**\n * @publicApi\n */\nexport class NgForOfContext<T, U extends NgIterable<T> = NgIterable<T>> {\n  constructor(public $implicit: T, public ngForOf: U, public index: number, public count: number) {}\n\n  get first(): boolean {\n    return this.index === 0;\n  }\n\n  get last(): boolean {\n    return this.index === this.count - 1;\n  }\n\n  get even(): boolean {\n    return this.index % 2 === 0;\n  }\n\n  get odd(): boolean {\n    return !this.even;\n  }\n}\n\n/**\n * A [structural directive](guide/structural-directives) that renders\n * a template for each item in a collection.\n * The directive is placed on an element, which becomes the parent\n * of the cloned templates.\n *\n * The `ngForOf` directive is generally used in the\n * [shorthand form](guide/structural-directives#the-asterisk--prefix) `*ngFor`.\n * In this form, the template to be rendered for each iteration is the content\n * of an anchor element containing the directive.\n *\n * The following example shows the shorthand syntax with some options,\n * contained in an `<li>` element.\n *\n * ```\n * <li *ngFor=\"let item of items; index as i; trackBy: trackByFn\">...</li>\n * ```\n *\n * The shorthand form expands into a long form that uses the `ngForOf` selector\n * on an `<ng-template>` element.\n * The content of the `<ng-template>` element is the `<li>` element that held the\n * short-form directive.\n *\n * Here is the expanded version of the short-form example.\n *\n * ```\n * <ng-template ngFor let-item [ngForOf]=\"items\" let-i=\"index\" [ngForTrackBy]=\"trackByFn\">\n *   <li>...</li>\n * </ng-template>\n * ```\n *\n * Angular automatically expands the shorthand syntax as it compiles the template.\n * The context for each embedded view is logically merged to the current component\n * context according to its lexical position.\n *\n * When using the shorthand syntax, Angular allows only [one structural directive\n * on an element](guide/structural-directives#one-structural-directive-per-host-element).\n * If you want to iterate conditionally, for example,\n * put the `*ngIf` on a container element that wraps the `*ngFor` element.\n * For futher discussion, see\n * [Structural Directives](guide/structural-directives#one-per-element).\n *\n * @usageNotes\n *\n * ### Local variables\n *\n * `NgForOf` provides exported values that can be aliased to local variables.\n * For example:\n *\n *  ```\n * <li *ngFor=\"let user of users; index as i; first as isFirst\">\n *    {{i}}/{{users.length}}. {{user}} <span *ngIf=\"isFirst\">default</span>\n * </li>\n * ```\n *\n * The following exported values can be aliased to local variables:\n *\n * - `$implicit: T`: The value of the individual items in the iterable (`ngForOf`).\n * - `ngForOf: NgIterable<T>`: The value of the iterable expression. Useful when the expression is\n * more complex then a property access, for example when using the async pipe (`userStreams |\n * async`).\n * - `index: number`: The index of the current item in the iterable.\n * - `count: number`: The length of the iterable.\n * - `first: boolean`: True when the item is the first item in the iterable.\n * - `last: boolean`: True when the item is the last item in the iterable.\n * - `even: boolean`: True when the item has an even index in the iterable.\n * - `odd: boolean`: True when the item has an odd index in the iterable.\n *\n * ### Change propagation\n *\n * When the contents of the iterator changes, `NgForOf` makes the corresponding changes to the DOM:\n *\n * * When an item is added, a new instance of the template is added to the DOM.\n * * When an item is removed, its template instance is removed from the DOM.\n * * When items are reordered, their respective templates are reordered in the DOM.\n *\n * Angular uses object identity to track insertions and deletions within the iterator and reproduce\n * those changes in the DOM. This has important implications for animations and any stateful\n * controls that are present, such as `<input>` elements that accept user input. Inserted rows can\n * be animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state\n * such as user input.\n * For more on animations, see [Transitions and Triggers](guide/transition-and-triggers).\n *\n * The identities of elements in the iterator can change while the data does not.\n * This can happen, for example, if the iterator is produced from an RPC to the server, and that\n * RPC is re-run. Even if the data hasn't changed, the second response produces objects with\n * different identities, and Angular must tear down the entire DOM and rebuild it (as if all old\n * elements were deleted and all new elements inserted).\n *\n * To avoid this expensive operation, you can customize the default tracking algorithm.\n * by supplying the `trackBy` option to `NgForOf`.\n * `trackBy` takes a function that has two arguments: `index` and `item`.\n * If `trackBy` is given, Angular tracks changes by the return value of the function.\n *\n * @see [Structural Directives](guide/structural-directives)\n * @ngModule CommonModule\n * @publicApi\n */\n@Directive({selector: '[ngFor][ngForOf]'})\nexport class NgForOf<T, U extends NgIterable<T> = NgIterable<T>> implements DoCheck {\n  /**\n   * The value of the iterable expression, which can be used as a\n   * [template input variable](guide/structural-directives#template-input-variable).\n   */\n  @Input()\n  set ngForOf(ngForOf: U&NgIterable<T>|undefined|null) {\n    this._ngForOf = ngForOf;\n    this._ngForOfDirty = true;\n  }\n  /**\n   * A function that defines how to track changes for items in the iterable.\n   *\n   * When items are added, moved, or removed in the iterable,\n   * the directive must re-render the appropriate DOM nodes.\n   * To minimize churn in the DOM, only nodes that have changed\n   * are re-rendered.\n   *\n   * By default, the change detector assumes that\n   * the object instance identifies the node in the iterable.\n   * When this function is supplied, the directive uses\n   * the result of calling this function to identify the item node,\n   * rather than the identity of the object itself.\n   *\n   * The function receives two inputs,\n   * the iteration index and the associated node data.\n   */\n  @Input()\n  set ngForTrackBy(fn: TrackByFunction<T>) {\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null && typeof fn !== 'function') {\n      // TODO(vicb): use a log service once there is a public one available\n      if (<any>console && <any>console.warn) {\n        console.warn(\n            `trackBy must be a function, but received ${JSON.stringify(fn)}. ` +\n            `See https://angular.io/api/common/NgForOf#change-propagation for more information.`);\n      }\n    }\n    this._trackByFn = fn;\n  }\n\n  get ngForTrackBy(): TrackByFunction<T> {\n    return this._trackByFn;\n  }\n\n  private _ngForOf: U|undefined|null = null;\n  private _ngForOfDirty: boolean = true;\n  private _differ: IterableDiffer<T>|null = null;\n  // TODO(issue/24571): remove '!'.\n  private _trackByFn!: TrackByFunction<T>;\n\n  constructor(\n      private _viewContainer: ViewContainerRef,\n      private _template: TemplateRef<NgForOfContext<T, U>>, private _differs: IterableDiffers) {}\n\n  /**\n   * A reference to the template that is stamped out for each item in the iterable.\n   * @see [template reference variable](guide/template-reference-variables)\n   */\n  @Input()\n  set ngForTemplate(value: TemplateRef<NgForOfContext<T, U>>) {\n    // TODO(TS2.1): make TemplateRef<Partial<NgForRowOf<T>>> once we move to TS v2.1\n    // The current type is too restrictive; a template that just uses index, for example,\n    // should be acceptable.\n    if (value) {\n      this._template = value;\n    }\n  }\n\n  /**\n   * Applies the changes when needed.\n   */\n  ngDoCheck(): void {\n    if (this._ngForOfDirty) {\n      this._ngForOfDirty = false;\n      // React on ngForOf changes only once all inputs have been initialized\n      const value = this._ngForOf;\n      if (!this._differ && value) {\n        try {\n          this._differ = this._differs.find(value).create(this.ngForTrackBy);\n        } catch {\n          throw new Error(`Cannot find a differ supporting object '${value}' of type '${\n              getTypeName(value)}'. NgFor only supports binding to Iterables such as Arrays.`);\n        }\n      }\n    }\n    if (this._differ) {\n      const changes = this._differ.diff(this._ngForOf);\n      if (changes) this._applyChanges(changes);\n    }\n  }\n\n  private _applyChanges(changes: IterableChanges<T>) {\n    const insertTuples: RecordViewTuple<T, U>[] = [];\n    changes.forEachOperation(\n        (item: IterableChangeRecord<any>, adjustedPreviousIndex: number|null,\n         currentIndex: number|null) => {\n          if (item.previousIndex == null) {\n            // NgForOf is never \"null\" or \"undefined\" here because the differ detected\n            // that a new item needs to be inserted from the iterable. This implies that\n            // there is an iterable value for \"_ngForOf\".\n            const view = this._viewContainer.createEmbeddedView(\n                this._template, new NgForOfContext<T, U>(null!, this._ngForOf!, -1, -1),\n                currentIndex === null ? undefined : currentIndex);\n            const tuple = new RecordViewTuple<T, U>(item, view);\n            insertTuples.push(tuple);\n          } else if (currentIndex == null) {\n            this._viewContainer.remove(\n                adjustedPreviousIndex === null ? undefined : adjustedPreviousIndex);\n          } else if (adjustedPreviousIndex !== null) {\n            const view = this._viewContainer.get(adjustedPreviousIndex)!;\n            this._viewContainer.move(view, currentIndex);\n            const tuple = new RecordViewTuple(item, <EmbeddedViewRef<NgForOfContext<T, U>>>view);\n            insertTuples.push(tuple);\n          }\n        });\n\n    for (let i = 0; i < insertTuples.length; i++) {\n      this._perViewChange(insertTuples[i].view, insertTuples[i].record);\n    }\n\n    for (let i = 0, ilen = this._viewContainer.length; i < ilen; i++) {\n      const viewRef = <EmbeddedViewRef<NgForOfContext<T, U>>>this._viewContainer.get(i);\n      viewRef.context.index = i;\n      viewRef.context.count = ilen;\n      viewRef.context.ngForOf = this._ngForOf!;\n    }\n\n    changes.forEachIdentityChange((record: any) => {\n      const viewRef =\n          <EmbeddedViewRef<NgForOfContext<T, U>>>this._viewContainer.get(record.currentIndex);\n      viewRef.context.$implicit = record.item;\n    });\n  }\n\n  private _perViewChange(\n      view: EmbeddedViewRef<NgForOfContext<T, U>>, record: IterableChangeRecord<any>) {\n    view.context.$implicit = record.item;\n  }\n\n  /**\n   * Asserts the correct type of the context for the template that `NgForOf` will render.\n   *\n   * The presence of this method is a signal to the Ivy template type-check compiler that the\n   * `NgForOf` structural directive renders its template with a specific context type.\n   */\n  static ngTemplateContextGuard<T, U extends NgIterable<T>>(dir: NgForOf<T, U>, ctx: any):\n      ctx is NgForOfContext<T, U> {\n    return true;\n  }\n}\n\nclass RecordViewTuple<T, U extends NgIterable<T>> {\n  constructor(public record: any, public view: EmbeddedViewRef<NgForOfContext<T, U>>) {}\n}\n\nfunction getTypeName(type: any): string {\n  return type['name'] || typeof type;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModule} from '@angular/core';\nimport {COMMON_DIRECTIVES} from './directives/index';\nimport {NgLocaleLocalization, NgLocalization} from './i18n/localization';\nimport {COMMON_PIPES} from './pipes/index';\n\n\n// Note: This does not contain the location providers,\n// as they need some platform specific implementations to work.\n/**\n * Exports all the basic Angular directives and pipes,\n * such as `NgIf`, `NgForOf`, `DecimalPipe`, and so on.\n * Re-exported by `BrowserModule`, which is included automatically in the root\n * `AppModule` when you create a new app with the CLI `new` command.\n *\n * * The `providers` options configure the NgModule's injector to provide\n * localization dependencies to members.\n * * The `exports` options make the declared directives and pipes available for import\n * by other NgModules.\n *\n * @publicApi\n */\n@NgModule({\n  declarations: [COMMON_DIRECTIVES, COMMON_PIPES],\n  exports: [COMMON_DIRECTIVES, COMMON_PIPES],\n  providers: [\n    {provide: NgLocalization, useClass: NgLocaleLocalization},\n  ],\n})\nexport class CommonModule {\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵparseCookieValue as parseCookieValue, ɵsetRootDomAdapter as setRootDomAdapter} from '@angular/common';\nimport {ɵglobal as global} from '@angular/core';\n\nimport {GenericBrowserDomAdapter} from './generic_browser_adapter';\n\nconst nodeContains: (this: Node, other: Node) => boolean = (() => {\n  if (global['Node']) {\n    return global['Node'].prototype.contains || function(this: Node, node: any) {\n      return !!(this.compareDocumentPosition(node) & 16);\n    };\n  }\n\n  return undefined as any;\n})();\n\n/**\n * A `DomAdapter` powered by full browser DOM APIs.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\n/* tslint:disable:requireParameterType no-console */\nexport class BrowserDomAdapter extends GenericBrowserDomAdapter {\n  static makeCurrent() {\n    setRootDomAdapter(new BrowserDomAdapter());\n  }\n  getProperty(el: Node, name: string): any {\n    return (<any>el)[name];\n  }\n\n  log(error: string): void {\n    if (window.console) {\n      window.console.log && window.console.log(error);\n    }\n  }\n\n  logGroup(error: string): void {\n    if (window.console) {\n      window.console.group && window.console.group(error);\n    }\n  }\n\n  logGroupEnd(): void {\n    if (window.console) {\n      window.console.groupEnd && window.console.groupEnd();\n    }\n  }\n\n  onAndCancel(el: Node, evt: any, listener: any): Function {\n    el.addEventListener(evt, listener, false);\n    // Needed to follow Dart's subscription semantic, until fix of\n    // https://code.google.com/p/dart/issues/detail?id=17406\n    return () => {\n      el.removeEventListener(evt, listener, false);\n    };\n  }\n  dispatchEvent(el: Node, evt: any) {\n    el.dispatchEvent(evt);\n  }\n  remove(node: Node): Node {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n    return node;\n  }\n  getValue(el: any): string {\n    return el.value;\n  }\n  createElement(tagName: string, doc?: Document): HTMLElement {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElement(tagName);\n  }\n  createHtmlDocument(): HTMLDocument {\n    return document.implementation.createHTMLDocument('fakeTitle');\n  }\n  getDefaultDocument(): Document {\n    return document;\n  }\n\n  isElementNode(node: Node): boolean {\n    return node.nodeType === Node.ELEMENT_NODE;\n  }\n\n  isShadowRoot(node: any): boolean {\n    return node instanceof DocumentFragment;\n  }\n\n  getGlobalEventTarget(doc: Document, target: string): EventTarget|null {\n    if (target === 'window') {\n      return window;\n    }\n    if (target === 'document') {\n      return doc;\n    }\n    if (target === 'body') {\n      return doc.body;\n    }\n    return null;\n  }\n  getHistory(): History {\n    return window.history;\n  }\n  getLocation(): Location {\n    return window.location;\n  }\n  getBaseHref(doc: Document): string|null {\n    const href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  resetBaseElement(): void {\n    baseElement = null;\n  }\n  getUserAgent(): string {\n    return window.navigator.userAgent;\n  }\n  performanceNow(): number {\n    // performance.now() is not available in all browsers, see\n    // https://caniuse.com/high-resolution-time\n    return window.performance && window.performance.now ? window.performance.now() :\n                                                          new Date().getTime();\n  }\n\n  supportsCookies(): boolean {\n    return true;\n  }\n\n  getCookie(name: string): string|null {\n    return parseCookieValue(document.cookie, name);\n  }\n}\n\nlet baseElement: HTMLElement|null = null;\nfunction getBaseElementHref(): string|null {\n  if (!baseElement) {\n    baseElement = document.querySelector('base')!;\n    if (!baseElement) {\n      return null;\n    }\n  }\n  return baseElement.getAttribute('href');\n}\n\n// based on urlUtils.js in AngularJS 1\nlet urlParsingNode: any;\nfunction relativePath(url: any): string {\n  if (!urlParsingNode) {\n    urlParsingNode = document.createElement('a');\n  }\n  urlParsingNode.setAttribute('href', url);\n  return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :\n                                                       '/' + urlParsingNode.pathname;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵDomAdapter as DomAdapter} from '@angular/common';\n\n\n\n/**\n * Provides DOM operations in any browser environment.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport abstract class GenericBrowserDomAdapter extends DomAdapter {\n  constructor() {\n    super();\n  }\n\n  supportsDOMEvents(): boolean {\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function parseCookieValue(cookieStr: string, name: string): string|null {\n  name = encodeURIComponent(name);\n  for (const cookie of cookieStr.split(';')) {\n    const eqIndex = cookie.indexOf('=');\n    const [cookieName, cookieValue]: string[] =\n        eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];\n    if (cookieName.trim() === name) {\n      return decodeURIComponent(cookieValue);\n    }\n  }\n  return null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, ɵgetDOM as getDOM} from '@angular/common';\nimport {APP_INITIALIZER, ApplicationInitStatus, Inject, InjectionToken, Injector, StaticProvider} from '@angular/core';\n\n/**\n * An id that identifies a particular application being bootstrapped, that should\n * match across the client/server boundary.\n */\nexport const TRANSITION_ID = new InjectionToken('TRANSITION_ID');\n\nexport function appInitializerFactory(transitionId: string, document: any, injector: Injector) {\n  return () => {\n    // Wait for all application initializers to be completed before removing the styles set by\n    // the server.\n    injector.get(ApplicationInitStatus).donePromise.then(() => {\n      const dom = getDOM();\n      const styles: any[] =\n          Array.prototype.slice.apply(document.querySelectorAll(`style[ng-transition]`));\n      styles.filter(el => el.getAttribute('ng-transition') === transitionId)\n          .forEach(el => dom.remove(el));\n    });\n  };\n}\n\nexport const SERVER_TRANSITION_PROVIDERS: StaticProvider[] = [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: appInitializerFactory,\n    deps: [TRANSITION_ID, DOCUMENT, Injector],\n    multi: true\n  },\n];\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵgetDOM as getDOM} from '@angular/common';\nimport {GetTestability, setTestabilityGetter, Testability, TestabilityRegistry, ɵglobal as global} from '@angular/core';\n\nexport class BrowserGetTestability implements GetTestability {\n  static init() {\n    setTestabilityGetter(new BrowserGetTestability());\n  }\n\n  addToWindow(registry: TestabilityRegistry): void {\n    global['getAngularTestability'] = (elem: any, findInAncestors: boolean = true) => {\n      const testability = registry.findTestabilityInTree(elem, findInAncestors);\n      if (testability == null) {\n        throw new Error('Could not find testability for element.');\n      }\n      return testability;\n    };\n\n    global['getAllAngularTestabilities'] = () => registry.getAllTestabilities();\n\n    global['getAllAngularRootElements'] = () => registry.getAllRootElements();\n\n    const whenAllStable = (callback: any /** TODO #9100 */) => {\n      const testabilities = global['getAllAngularTestabilities']();\n      let count = testabilities.length;\n      let didWork = false;\n      const decrement = function(didWork_: any /** TODO #9100 */) {\n        didWork = didWork || didWork_;\n        count--;\n        if (count == 0) {\n          callback(didWork);\n        }\n      };\n      testabilities.forEach(function(testability: any /** TODO #9100 */) {\n        testability.whenStable(decrement);\n      });\n    };\n\n    if (!global['frameworkStabilizers']) {\n      global['frameworkStabilizers'] = [];\n    }\n    global['frameworkStabilizers'].push(whenAllStable);\n  }\n\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null {\n    if (elem == null) {\n      return null;\n    }\n    const t = registry.getTestability(elem);\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n    if (getDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry, (<any>elem).host, true);\n    }\n    return this.findTestabilityInTree(registry, elem.parentElement, true);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {APP_INITIALIZER, ApplicationRef, DebugNode, NgProbeToken, NgZone, Optional, Provider, ɵgetDebugNodeR2} from '@angular/core';\n\nimport {exportNgVar} from '../util';\n\nconst CORE_TOKENS = (() => ({\n                       'ApplicationRef': ApplicationRef,\n                       'NgZone': NgZone,\n                     }))();\n\nconst INSPECT_GLOBAL_NAME = 'probe';\nconst CORE_TOKENS_GLOBAL_NAME = 'coreTokens';\n\n/**\n * Returns a {@link DebugElement} for the given native DOM element, or\n * null if the given native element does not have an Angular view associated\n * with it.\n */\nexport function inspectNativeElementR2(element: any): DebugNode|null {\n  return ɵgetDebugNodeR2(element);\n}\n\nexport function _createNgProbeR2(coreTokens: NgProbeToken[]): any {\n  exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElementR2);\n  exportNgVar(CORE_TOKENS_GLOBAL_NAME, {...CORE_TOKENS, ..._ngProbeTokensToMap(coreTokens || [])});\n  return () => inspectNativeElementR2;\n}\n\nfunction _ngProbeTokensToMap(tokens: NgProbeToken[]): {[name: string]: any} {\n  return tokens.reduce((prev: any, t: any) => (prev[t.name] = t.token, prev), {});\n}\n\n/**\n * In Ivy, we don't support NgProbe because we have our own set of testing utilities\n * with more robust functionality.\n *\n * We shouldn't bring in NgProbe because it prevents DebugNode and friends from\n * tree-shaking properly.\n */\nexport const ELEMENT_PROBE_PROVIDERS__POST_R3__ = [];\n\n/**\n * Providers which support debugging Angular applications (e.g. via `ng.probe`).\n */\nexport const ELEMENT_PROBE_PROVIDERS__PRE_R3__: Provider[] = [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: _createNgProbeR2,\n    deps: [\n      [NgProbeToken, new Optional()],\n    ],\n    multi: true,\n  },\n];\n\nexport const ELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS__PRE_R3__;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵgetDOM as getDOM} from '@angular/common';\nimport {Inject, Injectable, InjectionToken, NgZone} from '@angular/core';\n\n/**\n * The injection token for the event-manager plug-in service.\n *\n * @publicApi\n */\nexport const EVENT_MANAGER_PLUGINS =\n    new InjectionToken<EventManagerPlugin[]>('EventManagerPlugins');\n\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\n@Injectable()\nexport class EventManager {\n  private _plugins: EventManagerPlugin[];\n  private _eventNameToPlugin = new Map<string, EventManagerPlugin>();\n\n  /**\n   * Initializes an instance of the event-manager service.\n   */\n  constructor(@Inject(EVENT_MANAGER_PLUGINS) plugins: EventManagerPlugin[], private _zone: NgZone) {\n    plugins.forEach(p => p.manager = this);\n    this._plugins = plugins.slice().reverse();\n  }\n\n  /**\n   * Registers a handler for a specific element and event.\n   *\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns  A callback function that can be used to remove the handler.\n   */\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler);\n  }\n\n  /**\n   * Registers a global handler for an event in a target view.\n   *\n   * @param target A target for global event notifications. One of \"window\", \"document\", or \"body\".\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns A callback function that can be used to remove the handler.\n   */\n  addGlobalEventListener(target: string, eventName: string, handler: Function): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addGlobalEventListener(target, eventName, handler);\n  }\n\n  /**\n   * Retrieves the compilation zone in which event listeners are registered.\n   */\n  getZone(): NgZone {\n    return this._zone;\n  }\n\n  /** @internal */\n  _findPluginFor(eventName: string): EventManagerPlugin {\n    const plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n\n    const plugins = this._plugins;\n    for (let i = 0; i < plugins.length; i++) {\n      const plugin = plugins[i];\n      if (plugin.supports(eventName)) {\n        this._eventNameToPlugin.set(eventName, plugin);\n        return plugin;\n      }\n    }\n    throw new Error(`No event manager plugin found for event ${eventName}`);\n  }\n}\n\nexport abstract class EventManagerPlugin {\n  constructor(private _doc: any) {}\n\n  // TODO(issue/24571): remove '!'.\n  manager!: EventManager;\n\n  abstract supports(eventName: string): boolean;\n\n  abstract addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n\n  addGlobalEventListener(element: string, eventName: string, handler: Function): Function {\n    const target: HTMLElement = getDOM().getGlobalEventTarget(this._doc, element);\n    if (!target) {\n      throw new Error(`Unsupported event target ${target} for event ${eventName}`);\n    }\n    return this.addEventListener(target, eventName, handler);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, ɵgetDOM as getDOM} from '@angular/common';\nimport {Inject, Injectable, OnDestroy} from '@angular/core';\n\n@Injectable()\nexport class SharedStylesHost {\n  /** @internal */\n  protected _stylesSet = new Set<string>();\n\n  addStyles(styles: string[]): void {\n    const additions = new Set<string>();\n    styles.forEach(style => {\n      if (!this._stylesSet.has(style)) {\n        this._stylesSet.add(style);\n        additions.add(style);\n      }\n    });\n    this.onStylesAdded(additions);\n  }\n\n  onStylesAdded(additions: Set<string>): void {}\n\n  getAllStyles(): string[] {\n    return Array.from(this._stylesSet);\n  }\n}\n\n@Injectable()\nexport class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {\n  private _hostNodes = new Set<Node>();\n  private _styleNodes = new Set<Node>();\n  constructor(@Inject(DOCUMENT) private _doc: any) {\n    super();\n    this._hostNodes.add(_doc.head);\n  }\n\n  private _addStylesToHost(styles: Set<string>, host: Node): void {\n    styles.forEach((style: string) => {\n      const styleEl = this._doc.createElement('style');\n      styleEl.textContent = style;\n      this._styleNodes.add(host.appendChild(styleEl));\n    });\n  }\n\n  addHost(hostNode: Node): void {\n    this._addStylesToHost(this._stylesSet, hostNode);\n    this._hostNodes.add(hostNode);\n  }\n\n  removeHost(hostNode: Node): void {\n    this._hostNodes.delete(hostNode);\n  }\n\n  onStylesAdded(additions: Set<string>): void {\n    this._hostNodes.forEach(hostNode => this._addStylesToHost(additions, hostNode));\n  }\n\n  ngOnDestroy(): void {\n    this._styleNodes.forEach(styleNode => getDOM().remove(styleNode));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {APP_ID, Inject, Injectable, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, ViewEncapsulation} from '@angular/core';\n\nimport {EventManager} from './events/event_manager';\nimport {DomSharedStylesHost} from './shared_styles_host';\n\nexport const NAMESPACE_URIS: {[ns: string]: string} = {\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'xml': 'http://www.w3.org/XML/1998/namespace',\n  'xmlns': 'http://www.w3.org/2000/xmlns/',\n};\n\nconst COMPONENT_REGEX = /%COMP%/g;\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\n\nexport const COMPONENT_VARIABLE = '%COMP%';\nexport const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nexport const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n\nexport function shimContentAttribute(componentShortId: string): string {\n  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n\nexport function shimHostAttribute(componentShortId: string): string {\n  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n\nexport function flattenStyles(\n    compId: string, styles: Array<any|any[]>, target: string[]): string[] {\n  for (let i = 0; i < styles.length; i++) {\n    let style = styles[i];\n\n    if (Array.isArray(style)) {\n      flattenStyles(compId, style, target);\n    } else {\n      style = style.replace(COMPONENT_REGEX, compId);\n      target.push(style);\n    }\n  }\n  return target;\n}\n\nfunction decoratePreventDefault(eventHandler: Function): Function {\n  // `DebugNode.triggerEventHandler` needs to know if the listener was created with\n  // decoratePreventDefault or is a listener added outside the Angular context so it can handle the\n  // two differently. In the first case, the special '__ngUnwrap__' token is passed to the unwrap\n  // the listener (see below).\n  return (event: any) => {\n    // Ivy uses '__ngUnwrap__' as a special token that allows us to unwrap the function\n    // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`. The debug_node\n    // can inspect the listener toString contents for the existence of this special token. Because\n    // the token is a string literal, it is ensured to not be modified by compiled code.\n    if (event === '__ngUnwrap__') {\n      return eventHandler;\n    }\n\n    const allowDefaultBehavior = eventHandler(event);\n    if (allowDefaultBehavior === false) {\n      // TODO(tbosch): move preventDefault into event plugins...\n      event.preventDefault();\n      event.returnValue = false;\n    }\n\n    return undefined;\n  };\n}\n\nlet hasLoggedNativeEncapsulationWarning = false;\n\n@Injectable()\nexport class DomRendererFactory2 implements RendererFactory2 {\n  private rendererByCompId = new Map<string, Renderer2>();\n  private defaultRenderer: Renderer2;\n\n  constructor(\n      private eventManager: EventManager, private sharedStylesHost: DomSharedStylesHost,\n      @Inject(APP_ID) private appId: string) {\n    this.defaultRenderer = new DefaultDomRenderer2(eventManager);\n  }\n\n  createRenderer(element: any, type: RendererType2|null): Renderer2 {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n    switch (type.encapsulation) {\n      case ViewEncapsulation.Emulated: {\n        let renderer = this.rendererByCompId.get(type.id);\n        if (!renderer) {\n          renderer = new EmulatedEncapsulationDomRenderer2(\n              this.eventManager, this.sharedStylesHost, type, this.appId);\n          this.rendererByCompId.set(type.id, renderer);\n        }\n        (<EmulatedEncapsulationDomRenderer2>renderer).applyToHost(element);\n        return renderer;\n      }\n      case 1:\n      case ViewEncapsulation.ShadowDom:\n        // TODO(FW-2290): remove the `case 1:` fallback logic and the warning in v12.\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n            !hasLoggedNativeEncapsulationWarning && type.encapsulation === 1) {\n          hasLoggedNativeEncapsulationWarning = true;\n          console.warn(\n              'ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.');\n        }\n\n        return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);\n      default: {\n        if (!this.rendererByCompId.has(type.id)) {\n          const styles = flattenStyles(type.id, type.styles, []);\n          this.sharedStylesHost.addStyles(styles);\n          this.rendererByCompId.set(type.id, this.defaultRenderer);\n        }\n        return this.defaultRenderer;\n      }\n    }\n  }\n\n  begin() {}\n  end() {}\n}\n\nclass DefaultDomRenderer2 implements Renderer2 {\n  data: {[key: string]: any} = Object.create(null);\n\n  constructor(private eventManager: EventManager) {}\n\n  destroy(): void {}\n\n  destroyNode: null;\n\n  createElement(name: string, namespace?: string): any {\n    if (namespace) {\n      // In cases where Ivy (not ViewEngine) is giving us the actual namespace, the look up by key\n      // will result in undefined, so we just return the namespace here.\n      return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n    }\n\n    return document.createElement(name);\n  }\n\n  createComment(value: string): any {\n    return document.createComment(value);\n  }\n\n  createText(value: string): any {\n    return document.createTextNode(value);\n  }\n\n  appendChild(parent: any, newChild: any): void {\n    parent.appendChild(newChild);\n  }\n\n  insertBefore(parent: any, newChild: any, refChild: any): void {\n    if (parent) {\n      parent.insertBefore(newChild, refChild);\n    }\n  }\n\n  removeChild(parent: any, oldChild: any): void {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n\n  selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): any {\n    let el: any = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) :\n                                                       selectorOrNode;\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    if (!preserveContent) {\n      el.textContent = '';\n    }\n    return el;\n  }\n\n  parentNode(node: any): any {\n    return node.parentNode;\n  }\n\n  nextSibling(node: any): any {\n    return node.nextSibling;\n  }\n\n  setAttribute(el: any, name: string, value: string, namespace?: string): void {\n    if (namespace) {\n      name = namespace + ':' + name;\n      // TODO(FW-811): Ivy may cause issues here because it's passing around\n      // full URIs for namespaces, therefore this lookup will fail.\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n\n  removeAttribute(el: any, name: string, namespace?: string): void {\n    if (namespace) {\n      // TODO(FW-811): Ivy may cause issues here because it's passing around\n      // full URIs for namespaces, therefore this lookup will fail.\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        // TODO(FW-811): Since ivy is passing around full URIs for namespaces\n        // this could result in properties like `http://www.w3.org/2000/svg:cx=\"123\"`,\n        // which is wrong.\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n\n  addClass(el: any, name: string): void {\n    el.classList.add(name);\n  }\n\n  removeClass(el: any, name: string): void {\n    el.classList.remove(name);\n  }\n\n  setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void {\n    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {\n      el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n\n  removeStyle(el: any, style: string, flags: RendererStyleFlags2): void {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.removeProperty(style);\n    } else {\n      // IE requires '' instead of null\n      // see https://github.com/angular/angular/issues/7916\n      el.style[style] = '';\n    }\n  }\n\n  setProperty(el: any, name: string, value: any): void {\n    NG_DEV_MODE && checkNoSyntheticProp(name, 'property');\n    el[name] = value;\n  }\n\n  setValue(node: any, value: string): void {\n    node.nodeValue = value;\n  }\n\n  listen(target: 'window'|'document'|'body'|any, event: string, callback: (event: any) => boolean):\n      () => void {\n    NG_DEV_MODE && checkNoSyntheticProp(event, 'listener');\n    if (typeof target === 'string') {\n      return <() => void>this.eventManager.addGlobalEventListener(\n          target, event, decoratePreventDefault(callback));\n    }\n    return <() => void>this.eventManager.addEventListener(\n               target, event, decoratePreventDefault(callback)) as () => void;\n  }\n}\n\nconst AT_CHARCODE = (() => '@'.charCodeAt(0))();\nfunction checkNoSyntheticProp(name: string, nameKind: string) {\n  if (name.charCodeAt(0) === AT_CHARCODE) {\n    throw new Error(`Found the synthetic ${nameKind} ${\n        name}. Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.`);\n  }\n}\n\nclass EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {\n  private contentAttr: string;\n  private hostAttr: string;\n\n  constructor(\n      eventManager: EventManager, sharedStylesHost: DomSharedStylesHost,\n      private component: RendererType2, appId: string) {\n    super(eventManager);\n    const styles = flattenStyles(appId + '-' + component.id, component.styles, []);\n    sharedStylesHost.addStyles(styles);\n\n    this.contentAttr = shimContentAttribute(appId + '-' + component.id);\n    this.hostAttr = shimHostAttribute(appId + '-' + component.id);\n  }\n\n  applyToHost(element: any) {\n    super.setAttribute(element, this.hostAttr, '');\n  }\n\n  createElement(parent: any, name: string): Element {\n    const el = super.createElement(parent, name);\n    super.setAttribute(el, this.contentAttr, '');\n    return el;\n  }\n}\n\nclass ShadowDomRenderer extends DefaultDomRenderer2 {\n  private shadowRoot: any;\n\n  constructor(\n      eventManager: EventManager, private sharedStylesHost: DomSharedStylesHost,\n      private hostEl: any, component: RendererType2) {\n    super(eventManager);\n    this.shadowRoot = (hostEl as any).attachShadow({mode: 'open'});\n    this.sharedStylesHost.addHost(this.shadowRoot);\n    const styles = flattenStyles(component.id, component.styles, []);\n    for (let i = 0; i < styles.length; i++) {\n      const styleEl = document.createElement('style');\n      styleEl.textContent = styles[i];\n      this.shadowRoot.appendChild(styleEl);\n    }\n  }\n\n  private nodeOrShadowRoot(node: any): any {\n    return node === this.hostEl ? this.shadowRoot : node;\n  }\n\n  destroy() {\n    this.sharedStylesHost.removeHost(this.shadowRoot);\n  }\n\n  appendChild(parent: any, newChild: any): void {\n    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n  }\n  insertBefore(parent: any, newChild: any, refChild: any): void {\n    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n  }\n  removeChild(parent: any, oldChild: any): void {\n    return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);\n  }\n  parentNode(node: any): any {\n    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\n\nimport {EventManagerPlugin} from './event_manager';\n\n@Injectable()\nexport class DomEventsPlugin extends EventManagerPlugin {\n  constructor(@Inject(DOCUMENT) doc: any) {\n    super(doc);\n  }\n\n  // This plugin should come last in the list of plugins, because it accepts all\n  // events.\n  supports(eventName: string): boolean {\n    return true;\n  }\n\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    element.addEventListener(eventName, handler as EventListener, false);\n    return () => this.removeEventListener(element, eventName, handler as EventListener);\n  }\n\n  removeEventListener(target: any, eventName: string, callback: Function): void {\n    return target.removeEventListener(eventName, callback as EventListener);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, InjectionToken, NgModule, Optional, Provider, ɵConsole as Console} from '@angular/core';\n\nimport {EVENT_MANAGER_PLUGINS, EventManagerPlugin} from './event_manager';\n\n\n\n/**\n * Supported HammerJS recognizer event names.\n */\nconst EVENT_NAMES = {\n  // pan\n  'pan': true,\n  'panstart': true,\n  'panmove': true,\n  'panend': true,\n  'pancancel': true,\n  'panleft': true,\n  'panright': true,\n  'panup': true,\n  'pandown': true,\n  // pinch\n  'pinch': true,\n  'pinchstart': true,\n  'pinchmove': true,\n  'pinchend': true,\n  'pinchcancel': true,\n  'pinchin': true,\n  'pinchout': true,\n  // press\n  'press': true,\n  'pressup': true,\n  // rotate\n  'rotate': true,\n  'rotatestart': true,\n  'rotatemove': true,\n  'rotateend': true,\n  'rotatecancel': true,\n  // swipe\n  'swipe': true,\n  'swipeleft': true,\n  'swiperight': true,\n  'swipeup': true,\n  'swipedown': true,\n  // tap\n  'tap': true,\n  'doubletap': true\n};\n\n/**\n * DI token for providing [HammerJS](https://hammerjs.github.io/) support to Angular.\n * @see `HammerGestureConfig`\n *\n * @ngModule HammerModule\n * @publicApi\n */\nexport const HAMMER_GESTURE_CONFIG = new InjectionToken<HammerGestureConfig>('HammerGestureConfig');\n\n\n/**\n * Function that loads HammerJS, returning a promise that is resolved once HammerJs is loaded.\n *\n * @publicApi\n */\nexport type HammerLoader = () => Promise<void>;\n\n/**\n * Injection token used to provide a {@link HammerLoader} to Angular.\n *\n * @publicApi\n */\nexport const HAMMER_LOADER = new InjectionToken<HammerLoader>('HammerLoader');\n\nexport interface HammerInstance {\n  on(eventName: string, callback?: Function): void;\n  off(eventName: string, callback?: Function): void;\n  destroy?(): void;\n}\n\n/**\n * An injectable [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n * for gesture recognition. Configures specific event recognition.\n * @publicApi\n */\n@Injectable()\nexport class HammerGestureConfig {\n  /**\n   * A set of supported event names for gestures to be used in Angular.\n   * Angular supports all built-in recognizers, as listed in\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   */\n  events: string[] = [];\n\n  /**\n   * Maps gesture event names to a set of configuration options\n   * that specify overrides to the default values for specific properties.\n   *\n   * The key is a supported event name to be configured,\n   * and the options object contains a set of properties, with override values\n   * to be applied to the named recognizer event.\n   * For example, to disable recognition of the rotate event, specify\n   *  `{\"rotate\": {\"enable\": false}}`.\n   *\n   * Properties that are not present take the HammerJS default values.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   *\n   */\n  overrides: {[key: string]: Object} = {};\n\n  /**\n   * Properties whose default values can be overridden for a given event.\n   * Different sets of properties apply to different events.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   */\n  options?: {\n    cssProps?: any;\n    domEvents?: boolean;\n    enable?: boolean | ((manager: any) => boolean);\n    preset?: any[];\n    touchAction?: string;\n    recognizers?: any[];\n    inputClass?: any;\n    inputTarget?: EventTarget;\n  };\n\n  /**\n   * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n   * and attaches it to a given HTML element.\n   * @param element The element that will recognize gestures.\n   * @returns A HammerJS event-manager object.\n   */\n  buildHammer(element: HTMLElement): HammerInstance {\n    const mc = new Hammer!(element, this.options);\n\n    mc.get('pinch').set({enable: true});\n    mc.get('rotate').set({enable: true});\n\n    for (const eventName in this.overrides) {\n      mc.get(eventName).set(this.overrides[eventName]);\n    }\n\n    return mc;\n  }\n}\n\n/**\n * Event plugin that adds Hammer support to an application.\n *\n * @ngModule HammerModule\n */\n@Injectable()\nexport class HammerGesturesPlugin extends EventManagerPlugin {\n  constructor(\n      @Inject(DOCUMENT) doc: any,\n      @Inject(HAMMER_GESTURE_CONFIG) private _config: HammerGestureConfig, private console: Console,\n      @Optional() @Inject(HAMMER_LOADER) private loader?: HammerLoader|null) {\n    super(doc);\n  }\n\n  supports(eventName: string): boolean {\n    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n      return false;\n    }\n\n    if (!(window as any).Hammer && !this.loader) {\n      this.console.warn(\n          `The \"${eventName}\" event cannot be bound because Hammer.JS is not ` +\n          `loaded and no custom loader has been specified.`);\n      return false;\n    }\n\n    return true;\n  }\n\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    const zone = this.manager.getZone();\n    eventName = eventName.toLowerCase();\n\n    // If Hammer is not present but a loader is specified, we defer adding the event listener\n    // until Hammer is loaded.\n    if (!(window as any).Hammer && this.loader) {\n      // This `addEventListener` method returns a function to remove the added listener.\n      // Until Hammer is loaded, the returned function needs to *cancel* the registration rather\n      // than remove anything.\n      let cancelRegistration = false;\n      let deregister: Function = () => {\n        cancelRegistration = true;\n      };\n\n      this.loader()\n          .then(() => {\n            // If Hammer isn't actually loaded when the custom loader resolves, give up.\n            if (!(window as any).Hammer) {\n              this.console.warn(\n                  `The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n              deregister = () => {};\n              return;\n            }\n\n            if (!cancelRegistration) {\n              // Now that Hammer is loaded and the listener is being loaded for real,\n              // the deregistration function changes from canceling registration to removal.\n              deregister = this.addEventListener(element, eventName, handler);\n            }\n          })\n          .catch(() => {\n            this.console.warn(\n                `The \"${eventName}\" event cannot be bound because the custom ` +\n                `Hammer.JS loader failed.`);\n            deregister = () => {};\n          });\n\n      // Return a function that *executes* `deregister` (and not `deregister` itself) so that we\n      // can change the behavior of `deregister` once the listener is added. Using a closure in\n      // this way allows us to avoid any additional data structures to track listener removal.\n      return () => {\n        deregister();\n      };\n    }\n\n    return zone.runOutsideAngular(() => {\n      // Creating the manager bind events, must be done outside of angular\n      const mc = this._config.buildHammer(element);\n      const callback = function(eventObj: HammerInput) {\n        zone.runGuarded(function() {\n          handler(eventObj);\n        });\n      };\n      mc.on(eventName, callback);\n      return () => {\n        mc.off(eventName, callback);\n        // destroy mc to prevent memory leak\n        if (typeof mc.destroy === 'function') {\n          mc.destroy();\n        }\n      };\n    });\n  }\n\n  isCustomEvent(eventName: string): boolean {\n    return this._config.events.indexOf(eventName) > -1;\n  }\n}\n\n/**\n * In Ivy, support for Hammer gestures is optional, so applications must\n * import the `HammerModule` at root to turn on support. This means that\n * Hammer-specific code can be tree-shaken away if not needed.\n */\nexport const HAMMER_PROVIDERS__POST_R3__ = [];\n\n/**\n * In View Engine, support for Hammer gestures is built-in by default.\n */\nexport const HAMMER_PROVIDERS__PRE_R3__: Provider[] = [\n  {\n    provide: EVENT_MANAGER_PLUGINS,\n    useClass: HammerGesturesPlugin,\n    multi: true,\n    deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Console, [new Optional(), HAMMER_LOADER]]\n  },\n  {provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: []},\n];\n\nexport const HAMMER_PROVIDERS = HAMMER_PROVIDERS__PRE_R3__;\n\n/**\n * Adds support for HammerJS.\n *\n * Import this module at the root of your application so that Angular can work with\n * HammerJS to detect gesture events.\n *\n * Note that applications still need to include the HammerJS script itself. This module\n * simply sets up the coordination layer between HammerJS and Angular's EventManager.\n *\n * @publicApi\n */\n@NgModule({providers: HAMMER_PROVIDERS__PRE_R3__})\nexport class HammerModule {\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, ɵgetDOM as getDOM} from '@angular/common';\nimport {Inject, Injectable, NgZone} from '@angular/core';\nimport {EventManagerPlugin} from './event_manager';\n\n/**\n * Defines supported modifiers for key events.\n */\nconst MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];\n\nconst DOM_KEY_LOCATION_NUMPAD = 3;\n\n// Map to convert some key or keyIdentifier values to what will be returned by getEventKey\nconst _keyMap: {[k: string]: string} = {\n  // The following values are here for cross-browser compatibility and to match the W3C standard\n  // cf https://www.w3.org/TR/DOM-Level-3-Events-key/\n  '\\b': 'Backspace',\n  '\\t': 'Tab',\n  '\\x7F': 'Delete',\n  '\\x1B': 'Escape',\n  'Del': 'Delete',\n  'Esc': 'Escape',\n  'Left': 'ArrowLeft',\n  'Right': 'ArrowRight',\n  'Up': 'ArrowUp',\n  'Down': 'ArrowDown',\n  'Menu': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'Win': 'OS'\n};\n\n// There is a bug in Chrome for numeric keypad keys:\n// https://code.google.com/p/chromium/issues/detail?id=155654\n// 1, 2, 3 ... are reported as A, B, C ...\nconst _chromeNumKeyPadMap = {\n  'A': '1',\n  'B': '2',\n  'C': '3',\n  'D': '4',\n  'E': '5',\n  'F': '6',\n  'G': '7',\n  'H': '8',\n  'I': '9',\n  'J': '*',\n  'K': '+',\n  'M': '-',\n  'N': '.',\n  'O': '/',\n  '\\x60': '0',\n  '\\x90': 'NumLock'\n};\n\n\n/**\n * Retrieves modifiers from key-event objects.\n */\nconst MODIFIER_KEY_GETTERS: {[key: string]: (event: KeyboardEvent) => boolean} = {\n  'alt': (event: KeyboardEvent) => event.altKey,\n  'control': (event: KeyboardEvent) => event.ctrlKey,\n  'meta': (event: KeyboardEvent) => event.metaKey,\n  'shift': (event: KeyboardEvent) => event.shiftKey\n};\n\n/**\n * @publicApi\n * A browser plug-in that provides support for handling of key events in Angular.\n */\n@Injectable()\nexport class KeyEventsPlugin extends EventManagerPlugin {\n  /**\n   * Initializes an instance of the browser plug-in.\n   * @param doc The document in which key events will be detected.\n   */\n  constructor(@Inject(DOCUMENT) doc: any) {\n    super(doc);\n  }\n\n  /**\n   * Reports whether a named key event is supported.\n   * @param eventName The event name to query.\n   * @return True if the named key event is supported.\n   */\n  supports(eventName: string): boolean {\n    return KeyEventsPlugin.parseEventName(eventName) != null;\n  }\n\n  /**\n   * Registers a handler for a specific element and key event.\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the key event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns The key event that was registered.\n   */\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    const parsedEvent = KeyEventsPlugin.parseEventName(eventName)!;\n\n    const outsideHandler =\n        KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());\n\n    return this.manager.getZone().runOutsideAngular(() => {\n      return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);\n    });\n  }\n\n  static parseEventName(eventName: string): {fullKey: string, domEventName: string}|null {\n    const parts: string[] = eventName.toLowerCase().split('.');\n\n    const domEventName = parts.shift();\n    if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {\n      return null;\n    }\n\n    const key = KeyEventsPlugin._normalizeKey(parts.pop()!);\n\n    let fullKey = '';\n    MODIFIER_KEYS.forEach(modifierName => {\n      const index: number = parts.indexOf(modifierName);\n      if (index > -1) {\n        parts.splice(index, 1);\n        fullKey += modifierName + '.';\n      }\n    });\n    fullKey += key;\n\n    if (parts.length != 0 || key.length === 0) {\n      // returning null instead of throwing to let another plugin process the event\n      return null;\n    }\n\n    // NOTE: Please don't rewrite this as so, as it will break JSCompiler property renaming.\n    //       The code must remain in the `result['domEventName']` form.\n    // return {domEventName, fullKey};\n    const result: {fullKey: string, domEventName: string} = {} as any;\n    result['domEventName'] = domEventName;\n    result['fullKey'] = fullKey;\n    return result;\n  }\n\n  static getEventFullKey(event: KeyboardEvent): string {\n    let fullKey = '';\n    let key = getEventKey(event);\n    key = key.toLowerCase();\n    if (key === ' ') {\n      key = 'space';  // for readability\n    } else if (key === '.') {\n      key = 'dot';  // because '.' is used as a separator in event names\n    }\n    MODIFIER_KEYS.forEach(modifierName => {\n      if (modifierName != key) {\n        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];\n        if (modifierGetter(event)) {\n          fullKey += modifierName + '.';\n        }\n      }\n    });\n    fullKey += key;\n    return fullKey;\n  }\n\n  /**\n   * Configures a handler callback for a key event.\n   * @param fullKey The event name that combines all simultaneous keystrokes.\n   * @param handler The function that responds to the key event.\n   * @param zone The zone in which the event occurred.\n   * @returns A callback function.\n   */\n  static eventCallback(fullKey: any, handler: Function, zone: NgZone): Function {\n    return (event: any /** TODO #9100 */) => {\n      if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {\n        zone.runGuarded(() => handler(event));\n      }\n    };\n  }\n\n  /** @internal */\n  static _normalizeKey(keyName: string): string {\n    // TODO: switch to a Map if the mapping grows too much\n    switch (keyName) {\n      case 'esc':\n        return 'escape';\n      default:\n        return keyName;\n    }\n  }\n}\n\nfunction getEventKey(event: any): string {\n  let key = event.key;\n  if (key == null) {\n    key = event.keyIdentifier;\n    // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and\n    // Safari cf\n    // https://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces\n    if (key == null) {\n      return 'Unidentified';\n    }\n    if (key.startsWith('U+')) {\n      key = String.fromCharCode(parseInt(key.substring(2), 16));\n      if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {\n        // There is a bug in Chrome for numeric keypad keys:\n        // https://code.google.com/p/chromium/issues/detail?id=155654\n        // 1, 2, 3 ... are reported as A, B, C ...\n        key = (_chromeNumKeyPadMap as any)[key];\n      }\n    }\n  }\n\n  return _keyMap[key] || key;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CommonModule, DOCUMENT, ɵPLATFORM_BROWSER_ID as PLATFORM_BROWSER_ID} from '@angular/common';\nimport {APP_ID, ApplicationModule, createPlatformFactory, ErrorHandler, Inject, ModuleWithProviders, NgModule, NgZone, Optional, PLATFORM_ID, PLATFORM_INITIALIZER, platformCore, PlatformRef, RendererFactory2, Sanitizer, SkipSelf, StaticProvider, Testability, ɵConsole as Console, ɵINJECTOR_SCOPE as INJECTOR_SCOPE, ɵsetDocument} from '@angular/core';\n\nimport {BrowserDomAdapter} from './browser/browser_adapter';\nimport {SERVER_TRANSITION_PROVIDERS, TRANSITION_ID} from './browser/server-transition';\nimport {BrowserGetTestability} from './browser/testability';\nimport {ELEMENT_PROBE_PROVIDERS} from './dom/debug/ng_probe';\nimport {DomRendererFactory2} from './dom/dom_renderer';\nimport {DomEventsPlugin} from './dom/events/dom_events';\nimport {EVENT_MANAGER_PLUGINS, EventManager} from './dom/events/event_manager';\nimport {HAMMER_PROVIDERS} from './dom/events/hammer_gestures';\nimport {KeyEventsPlugin} from './dom/events/key_events';\nimport {DomSharedStylesHost, SharedStylesHost} from './dom/shared_styles_host';\nimport {DomSanitizer, DomSanitizerImpl} from './security/dom_sanitization_service';\n\nexport function initDomAdapter() {\n  BrowserDomAdapter.makeCurrent();\n  BrowserGetTestability.init();\n}\n\nexport function errorHandler(): ErrorHandler {\n  return new ErrorHandler();\n}\n\nexport function _document(): any {\n  // Tell ivy about the global document\n  ɵsetDocument(document);\n  return document;\n}\n\nexport const INTERNAL_BROWSER_PLATFORM_PROVIDERS: StaticProvider[] = [\n  {provide: PLATFORM_ID, useValue: PLATFORM_BROWSER_ID},\n  {provide: PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true},\n  {provide: DOCUMENT, useFactory: _document, deps: []},\n];\n\nconst BROWSER_SANITIZATION_PROVIDERS__PRE_R3__: StaticProvider[] = [\n  {provide: Sanitizer, useExisting: DomSanitizer},\n  {provide: DomSanitizer, useClass: DomSanitizerImpl, deps: [DOCUMENT]},\n];\n\nexport const BROWSER_SANITIZATION_PROVIDERS__POST_R3__ = [];\n\n/**\n * @security Replacing built-in sanitization providers exposes the application to XSS risks.\n * Attacker-controlled data introduced by an unsanitized provider could expose your\n * application to XSS risks. For more detail, see the [Security Guide](https://g.co/ng/security).\n * @publicApi\n */\nexport const BROWSER_SANITIZATION_PROVIDERS = BROWSER_SANITIZATION_PROVIDERS__PRE_R3__;\n\n/**\n * A factory function that returns a `PlatformRef` instance associated with browser service\n * providers.\n *\n * @publicApi\n */\nexport const platformBrowser: (extraProviders?: StaticProvider[]) => PlatformRef =\n    createPlatformFactory(platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\n\nexport const BROWSER_MODULE_PROVIDERS: StaticProvider[] = [\n  BROWSER_SANITIZATION_PROVIDERS,\n  {provide: INJECTOR_SCOPE, useValue: 'root'},\n  {provide: ErrorHandler, useFactory: errorHandler, deps: []},\n  {\n    provide: EVENT_MANAGER_PLUGINS,\n    useClass: DomEventsPlugin,\n    multi: true,\n    deps: [DOCUMENT, NgZone, PLATFORM_ID]\n  },\n  {provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [DOCUMENT]},\n  HAMMER_PROVIDERS,\n  {\n    provide: DomRendererFactory2,\n    useClass: DomRendererFactory2,\n    deps: [EventManager, DomSharedStylesHost, APP_ID]\n  },\n  {provide: RendererFactory2, useExisting: DomRendererFactory2},\n  {provide: SharedStylesHost, useExisting: DomSharedStylesHost},\n  {provide: DomSharedStylesHost, useClass: DomSharedStylesHost, deps: [DOCUMENT]},\n  {provide: Testability, useClass: Testability, deps: [NgZone]},\n  {provide: EventManager, useClass: EventManager, deps: [EVENT_MANAGER_PLUGINS, NgZone]},\n  ELEMENT_PROBE_PROVIDERS,\n];\n\n/**\n * Exports required infrastructure for all Angular apps.\n * Included by default in all Angular apps created with the CLI\n * `new` command.\n * Re-exports `CommonModule` and `ApplicationModule`, making their\n * exports and providers available to all apps.\n *\n * @publicApi\n */\n@NgModule({providers: BROWSER_MODULE_PROVIDERS, exports: [CommonModule, ApplicationModule]})\nexport class BrowserModule {\n  constructor(@Optional() @SkipSelf() @Inject(BrowserModule) parentModule: BrowserModule|null) {\n    if (parentModule) {\n      throw new Error(\n          `BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);\n    }\n  }\n\n  /**\n   * Configures a browser-based app to transition from a server-rendered app, if\n   * one is present on the page.\n   *\n   * @param params An object containing an identifier for the app to transition.\n   * The ID must match between the client and server versions of the app.\n   * @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.\n   */\n  static withServerTransition(params: {appId: string}): ModuleWithProviders<BrowserModule> {\n    return {\n      ngModule: BrowserModule,\n      providers: [\n        {provide: APP_ID, useValue: params.appId},\n        {provide: TRANSITION_ID, useExisting: APP_ID},\n        SERVER_TRANSITION_PROVIDERS,\n      ],\n    };\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const PLATFORM_BROWSER_ID = 'browser';\nexport const PLATFORM_SERVER_ID = 'server';\nexport const PLATFORM_WORKER_APP_ID = 'browserWorkerApp';\nexport const PLATFORM_WORKER_UI_ID = 'browserWorkerUi';\n\n/**\n * Returns whether a platform id represents a browser platform.\n * @publicApi\n */\nexport function isPlatformBrowser(platformId: Object): boolean {\n  return platformId === PLATFORM_BROWSER_ID;\n}\n\n/**\n * Returns whether a platform id represents a server platform.\n * @publicApi\n */\nexport function isPlatformServer(platformId: Object): boolean {\n  return platformId === PLATFORM_SERVER_ID;\n}\n\n/**\n * Returns whether a platform id represents a web worker app platform.\n * @publicApi\n */\nexport function isPlatformWorkerApp(platformId: Object): boolean {\n  return platformId === PLATFORM_WORKER_APP_ID;\n}\n\n/**\n * Returns whether a platform id represents a web worker UI platform.\n * @publicApi\n */\nexport function isPlatformWorkerUi(platformId: Object): boolean {\n  return platformId === PLATFORM_WORKER_UI_ID;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* tslint:disable:no-console  */\nurlParamsToForm();\n\nexport function getIntParameter(name: string) {\n  return parseInt(getStringParameter(name), 10);\n}\n\nexport function getStringParameter(name: string) {\n  const els = document.querySelectorAll(`input[name=\"${name}\"]`);\n  let value: any;\n  let el: any;\n\n  for (let i = 0; i < els.length; i++) {\n    el = els[i];\n    const type = el.type;\n    if ((type != 'radio' && type != 'checkbox') || el.checked) {\n      value = el.value;\n      break;\n    }\n  }\n\n  if (value == null) {\n    throw new Error(`Could not find and input field with name ${name}`);\n  }\n\n  return value;\n}\n\nexport function bindAction(selector: string, callback: () => void) {\n  document.querySelector(selector)!.addEventListener('click', callback);\n}\n\n\nexport function profile(create: () => void, destroy: () => void, name: string) {\n  return function() {\n    // 'console.profile' is experimental and was removed from DOM lib in TS 3.9\n    (window.console as any).profile(name);\n    const noOfRuns = 150;\n    let durations: number[] = [];\n    let count = 0;\n    while (count++ < noOfRuns) {\n      const start = window.performance.now();\n      create();\n      const end = window.performance.now() - start;\n      durations.push(end);\n      destroy();\n    }\n    // 'console.profileEnd' is experimental and was removed from DOM lib in TS 3.9\n    (window.console as any).profileEnd();\n    reportProfileResults(durations, noOfRuns);\n  };\n}\n\nfunction reportProfileResults(durations: number[], count: number) {\n  const totalDuration = durations.reduce((soFar: number, duration: number) => soFar + duration, 0);\n  const avgDuration = (totalDuration / count).toFixed(2);\n  const minDuration = durations\n                          .reduce(\n                              (soFar: number, duration: number) => Math.min(soFar, duration),\n                              Number.MAX_SAFE_INTEGER)\n                          .toFixed(2);\n  window.console.log(\n      `Iterations: ${count}; cold time: ${durations[0].toFixed(2)} ms; average time: ${\n          avgDuration} ms / iteration; best time: ${minDuration} ms`);\n}\n\n// helper script that will read out the url parameters\n// and store them in appropriate form fields on the page\nfunction urlParamsToForm() {\n  const regex = /(\\w+)=(\\w+)/g;\n  const search = decodeURIComponent(location.search);\n  let match: any[]|null;\n  while (match = regex.exec(search)) {\n    const name = match[1];\n    const value = match[2];\n    const els = document.querySelectorAll('input[name=\"' + name + '\"]');\n    let el: any;\n    for (let i = 0; i < els.length; i++) {\n      el = els[i];\n      if (el.type === 'radio' || el.type === 'checkbox') {\n        el.checked = el.value === value;\n      } else {\n        el.value = value;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef, NgModuleRef} from '@angular/core';\n\nimport {bindAction} from '../../util';\n\nimport {JsWebFrameworksComponent, JsWebFrameworksModule, RowData} from './rows';\n\n\nfunction _random(max: number) {\n  return Math.round(Math.random() * 1000) % max;\n}\n\nfunction buildData(count: number): Array<RowData> {\n  const data: Array<RowData> = [];\n  for (let i = 0; i < count; i++) {\n    data.push({\n      id: i,\n      label: ADJECTIVES[_random(ADJECTIVES.length)] + ' ' + COLOURS[_random(COLOURS.length)] + ' ' +\n          NOUNS[_random(NOUNS.length)]\n    });\n  }\n  return data;\n}\n\nconst ADJECTIVES = [\n  'pretty',      'large',   'big',       'small', 'tall',      'short',    'long',\n  'handsome',    'plain',   'quaint',    'clean', 'elegant',   'easy',     'angry',\n  'crazy',       'helpful', 'mushy',     'odd',   'unsightly', 'adorable', 'important',\n  'inexpensive', 'cheap',   'expensive', 'fancy'\n];\nconst COLOURS = [\n  'red', 'yellow', 'blue', 'green', 'pink', 'brown', 'purple', 'brown', 'white', 'black', 'orange'\n];\nconst NOUNS = [\n  'table', 'chair', 'house', 'bbq', 'desk', 'car', 'pony', 'cookie', 'sandwich', 'burger', 'pizza',\n  'mouse', 'keyboard'\n];\n\nexport function init(moduleRef: NgModuleRef<JsWebFrameworksModule>) {\n  let component: JsWebFrameworksComponent;\n  let appRef: ApplicationRef;\n\n  function create1K() {\n    component.data = buildData(1 * 1000);\n    appRef.tick();\n  }\n\n  function create10K() {\n    component.data = buildData(10 * 1000);\n    appRef.tick();\n  }\n\n  function deleteAll() {\n    component.data = [];\n    appRef.tick();\n  }\n\n  function update() {\n    for (let i = 0; i < component.data.length; i += 10) {\n      component.data[i].label += ' !!!';\n    }\n    appRef.tick();\n  }\n\n  function swapRows() {\n    const data = component.data;\n    if (data.length > 998) {\n      const a = data[1];\n      data[1] = data[998];\n      data[998] = a;\n    }\n    appRef.tick();\n  }\n\n  const injector = moduleRef.injector;\n  appRef = injector.get(ApplicationRef);\n\n  component = appRef.components[0].instance;\n\n  bindAction('#create1KRows', create1K);\n  bindAction('#create10KRows', create10K);\n  bindAction('#deleteAll', deleteAll);\n  bindAction('#update', update);\n  bindAction('#swap', swapRows);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {OpaqueViewState} from '../interfaces/view';\nimport {getLView} from '../state';\n\n/**\n * Returns the current OpaqueViewState instance.\n *\n * Used in conjunction with the restoreView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @codeGenApi\n */\nexport function ɵɵgetCurrentView(): OpaqueViewState {\n  return getLView() as any as OpaqueViewState;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ApplicationRef, Component, NgModule} from '@angular/core';\nimport {BrowserModule} from '@angular/platform-browser';\n\nexport interface RowData {\n  id: number;\n  label: string;\n}\n\n\n@Component({\n  selector: 'js-web-frameworks',\n  template: `\n    <table class=\"table table-hover table-striped test-data\">\n        <tbody>\n            <tr [class.danger]=\"item.id === selected\" *ngFor=\"let item of data; trackBy: itemById\">\n                <td class=\"col-md-1\">{{item.id}}</td>\n                <td class=\"col-md-4\">\n                    <a href=\"#\" (click)=\"select(item.id); $event.preventDefault()\">{{item.label}}</a>\n                </td>\n                <td class=\"col-md-1\">\n                  <a href=\"#\" (click)=\"delete(item.id); $event.preventDefault()\">\n                    <span class=\"glyphicon glyphicon-remove\" aria-hidden=\"true\"></span>\n                  </a>\n                </td>\n                <td class=\"col-md-6\"></td>\n            </tr>\n        </tbody>\n    </table>\n  `\n})\nexport class JsWebFrameworksComponent {\n  data: Array<RowData> = [];\n  selected: number|null;\n\n  constructor(private _appRef: ApplicationRef) {}\n\n  itemById(index: number, item: RowData) {\n    return item.id;\n  }\n\n  select(itemId: number) {\n    this.selected = itemId;\n    this._appRef.tick();\n  }\n\n  delete(itemId: number) {\n    const data = this.data;\n    for (let i = 0, l = data.length; i < l; i++) {\n      if (data[i].id === itemId) {\n        data.splice(i, 1);\n        break;\n      }\n    }\n    this._appRef.tick();\n  }\n}\n\n@NgModule({\n  imports: [BrowserModule],\n  declarations: [JsWebFrameworksComponent],\n  bootstrap: [JsWebFrameworksComponent],\n})\nexport class JsWebFrameworksModule {\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertFirstCreatePass} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {registerPostOrderHooks} from '../hooks';\nimport {ComponentTemplate} from '../interfaces/definition';\nimport {LocalRefExtractor, TAttributes, TContainerNode, TNodeType} from '../interfaces/node';\nimport {isDirectiveHost} from '../interfaces/type_checks';\nimport {HEADER_OFFSET, LView, RENDERER, TView, TViewType} from '../interfaces/view';\nimport {appendChild} from '../node_manipulation';\nimport {getLView, getTView, setCurrentTNode} from '../state';\nimport {getConstant} from '../util/view_utils';\nimport {addToViewTree, createDirectivesInstances, createLContainer, createTView, getOrCreateTNode, resolveDirectives, saveResolvedLocalsInData} from './shared';\n\n\n\nfunction templateFirstCreatePass(\n    index: number, tView: TView, lView: LView, templateFn: ComponentTemplate<any>|null,\n    decls: number, vars: number, tagName?: string|null, attrsIndex?: number|null,\n    localRefsIndex?: number|null): TContainerNode {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  // TODO(pk): refactor getOrCreateTNode to have the \"create\" only version\n  const tNode = getOrCreateTNode(\n      tView, index, TNodeType.Container, tagName || null,\n      getConstant<TAttributes>(tViewConsts, attrsIndex));\n\n  resolveDirectives(tView, lView, tNode, getConstant<string[]>(tViewConsts, localRefsIndex));\n  registerPostOrderHooks(tView, tNode);\n\n  const embeddedTView = tNode.tViews = createTView(\n      TViewType.Embedded, tNode, templateFn, decls, vars, tView.directiveRegistry,\n      tView.pipeRegistry, null, tView.schemas, tViewConsts);\n\n  if (tView.queries !== null) {\n    tView.queries.template(tView, tNode);\n    embeddedTView.queries = tView.queries.embeddedTView(tNode);\n  }\n\n  return tNode;\n}\n\n/**\n * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.\n *\n * <ng-template #foo>\n *    <div></div>\n * </ng-template>\n *\n * @param index The index of the container in the data array\n * @param templateFn Inline template\n * @param decls The number of nodes, local refs, and pipes for this template\n * @param vars The number of bindings for this template\n * @param tagName The name of the container element, if applicable\n * @param attrsIndex Index of template attributes in the `consts` array.\n * @param localRefs Index of the local references in the `consts` array.\n * @param localRefExtractor A function which extracts local-refs values from the template.\n *        Defaults to the current element associated with the local-ref.\n *\n * @codeGenApi\n */\nexport function ɵɵtemplate(\n    index: number, templateFn: ComponentTemplate<any>|null, decls: number, vars: number,\n    tagName?: string|null, attrsIndex?: number|null, localRefsIndex?: number|null,\n    localRefExtractor?: LocalRefExtractor) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  const tNode = tView.firstCreatePass ? templateFirstCreatePass(\n                                            adjustedIndex, tView, lView, templateFn, decls, vars,\n                                            tagName, attrsIndex, localRefsIndex) :\n                                        tView.data[adjustedIndex] as TContainerNode;\n  setCurrentTNode(tNode, false);\n\n  const comment = lView[RENDERER].createComment(ngDevMode ? 'container' : '');\n  appendChild(tView, lView, comment, tNode);\n  attachPatchData(comment, lView);\n\n  addToViewTree(lView, lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode));\n\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n  }\n\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode, localRefExtractor);\n  }\n}\n","import * as i0 from '@angular/core';\nimport {JsWebFrameworksComponent, JsWebFrameworksModule} from './rows';\nexport const JsWebFrameworksComponentNgFactory: i0.ɵNgModuleFactory<any> = new i0.ɵNgModuleFactory(JsWebFrameworksComponent);\nexport const JsWebFrameworksModuleNgFactory: i0.ɵNgModuleFactory<any> = new i0.ɵNgModuleFactory(JsWebFrameworksModule);\nexport const ɵNonEmptyModule = true;","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {enableProdMode} from '@angular/core';\nimport {platformBrowser} from '@angular/platform-browser';\n\nimport {init} from './init';\nimport {JsWebFrameworksModuleNgFactory} from './rows.ngfactory';\n\nenableProdMode();\nplatformBrowser().bootstrapModuleFactory(JsWebFrameworksModuleNgFactory).then(init);\n"]}